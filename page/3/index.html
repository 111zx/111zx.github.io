<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="https://github.com/111zx/111zx.github.io/page/3/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="zx">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://github.com/111zx/111zx.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-tips" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/12/tips/" class="article-date">
  <time datetime="2020-05-12T15:17:31.000Z" itemprop="datePublished">2020-05-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/12/tips/">tips</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-时间复杂度为O-NlogN-的数组排序"><a href="#1-时间复杂度为O-NlogN-的数组排序" class="headerlink" title="1. 时间复杂度为O(NlogN)的数组排序"></a>1. 时间复杂度为O(NlogN)的数组排序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(nums);<span class="comment">//nums是一个一维数组</span></span><br></pre></td></tr></table></figure>

<h2 id="2-代替n-2的位运算"><a href="#2-代替n-2的位运算" class="headerlink" title="2. 代替n/2的位运算"></a>2. 代替n/2的位运算</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n &gt;&gt; <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<h2 id="3-找出数组中最大的元素"><a href="#3-找出数组中最大的元素" class="headerlink" title="3. 找出数组中最大的元素"></a>3. 找出数组中最大的元素</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">方法一</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">return</span> Arrays.stream(nums).max().getAsInt();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">方法二</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">List&lt;Integer&gt; list1 = Arrays.stream(nums).boxed().collect(Collectors.toList());</span><br><span class="line"><span class="keyword">return</span> Collections.max(list1);</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/111zx/111zx.github.io/2020/05/12/tips/" data-id="ckbbzdvsm000at8ubfv7d5vhc" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-leetcode" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/12/leetcode/" class="article-date">
  <time datetime="2020-05-12T02:24:08.000Z" itemprop="datePublished">2020-05-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/12/leetcode/">leetcode</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="53-最大序列和"><a href="#53-最大序列和" class="headerlink" title="53. 最大序列和"></a>53. 最大序列和</h2><h5 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h5><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p>示例:</p>
<p>输入: [-2,1,-3,4,-1,2,1,-5,4],<br>输出: 6<br>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</p>
<p>来源：力扣（LeetCode）</p>
<hr>
<h5 id="1-贪心算法"><a href="#1-贪心算法" class="headerlink" title="1. 贪心算法"></a>1. 贪心算法</h5><h6 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h6><ul>
<li>以 i - 1 下标的元素为结尾的最大序列和为正时，sum = sum + nums[i];以 i - 1 下标的元素为结尾的最大序列和为负时，sum = nums[i]</li>
<li>每次得到序列和后和目前最大序列和比较，根据情况判断是否更新最大序列和的值</li>
</ul>
<h6 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h6><ul>
<li>O(n)</li>
</ul>
<h6 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h6><ul>
<li>O(1)</li>
</ul>
<h6 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   贪心算法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">method1</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">       <span class="keyword">int</span> max = nums[<span class="number">0</span>];</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>,sum = <span class="number">0</span>; i &lt; nums.length; i++)</span><br><span class="line">           <span class="comment">/*</span></span><br><span class="line"><span class="comment">           计算以i下标结尾的最大序列和</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">           max = (sum = sum &lt; <span class="number">0</span> ? nums[i] : sum + 					nums[i]) &gt; max ? sum : max;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">return</span> max;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-动态规划"><a href="#2-动态规划" class="headerlink" title="2. 动态规划"></a>2. 动态规划</h5><h6 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h6><ul>
<li>计算以每个下标为结尾的最大序列和</li>
<li>转移方程：nums[i] = nums[i - 1] &gt; 0 ? nums[i] + nums[ i - 1] : nums[i]</li>
<li>完成计算之后nums数组成为最大序列和数组</li>
</ul>
<h6 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h6><p>O(n)</p>
<h6 id="空间复杂度-1"><a href="#空间复杂度-1" class="headerlink" title="空间复杂度"></a>空间复杂度</h6><p>O(1)</p>
<h6 id="java代码实现"><a href="#java代码实现" class="headerlink" title="java代码实现"></a>java代码实现</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">method2</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; nums.length &gt; <span class="number">1</span> &amp;&amp; i &lt; nums.length; i++) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//构造最大序列和数组（以每个下标为结尾的最大序列和的值）</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i - <span class="number">1</span>] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                nums[i] = nums[i] + nums[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            max = Math.max(max,nums[i]);<span class="comment">//保存最大数据</span></span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="3-分治算法"><a href="#3-分治算法" class="headerlink" title="3.*分治算法"></a>3.*分治算法</h5><h6 id="思路分析-2"><a href="#思路分析-2" class="headerlink" title="思路分析"></a>思路分析</h6><ul>
<li><p>需要维护4个变量：</p>
<ul>
<li>lsum：前序列以做区间为端点的最大子段和</li>
<li>rsum：当前序列以做区间为端点的最大子段和</li>
<li>isum：区间和</li>
<li>msum：当前序列的最大子段和（最后求出[0,nums.length - 1]的值即可）</li>
</ul>
</li>
<li><p>每次合并4个变量的变更依据：</p>
<ul>
<li>新子段的lSum等于左区间的lSum或者左区间的 区间和 加上右区间的lSum</li>
<li>新子段的rSum等于右区间的rSum或者右区间的 区间和 加上左区间的rSum</li>
<li>新子段的区间和等于左右区间的区间和之和</li>
<li><strong>新子段的最大子段和，其子段有可能穿过左右区间，或左区间，或右区间</strong></li>
</ul>
</li>
</ul>
<h6 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h6><p>O(n)</p>
<h6 id="空间复杂度-2"><a href="#空间复杂度-2" class="headerlink" title="空间复杂度"></a>空间复杂度</h6><p>O(logn)</p>
<h6 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 输入校验</span></span><br><span class="line">       <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length &lt;= <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> len = nums.length;<span class="comment">// 获取输入长度</span></span><br><span class="line">       <span class="keyword">return</span> getInfo(nums, <span class="number">0</span>, len - <span class="number">1</span>).mSum;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">wtevTree</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> lSum;<span class="comment">// 以左区间为端点的最大子段和</span></span><br><span class="line">       <span class="keyword">int</span> rSum;<span class="comment">// 以右区间为端点的最大子段和</span></span><br><span class="line">       <span class="keyword">int</span> iSum;<span class="comment">// 区间所有数的和</span></span><br><span class="line">       <span class="keyword">int</span> mSum;<span class="comment">// 该区间的最大子段和</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// 构造函数</span></span><br><span class="line">       wtevTree(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> i, <span class="keyword">int</span> m) &#123;</span><br><span class="line">           lSum = l;</span><br><span class="line">           rSum = r;</span><br><span class="line">           iSum = i;</span><br><span class="line">           mSum = m;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 通过既有的属性，计算上一层的属性,一步步往上返回,获得线段树</span></span><br><span class="line">   <span class="function">wtevTree <span class="title">pushUp</span><span class="params">(wtevTree leftT, wtevTree rightT)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 新子段的lSum等于左区间的lSum或者左区间的 区间和 加上右区间的lSum</span></span><br><span class="line">       <span class="keyword">int</span> l = Math.max(leftT.lSum, leftT.iSum + rightT.lSum);</span><br><span class="line">       <span class="comment">// 新子段的rSum等于右区间的rSum或者右区间的 区间和 加上左区间的rSum</span></span><br><span class="line">       <span class="keyword">int</span> r = Math.max(leftT.rSum + rightT.iSum, rightT.rSum);</span><br><span class="line">       <span class="comment">// 新子段的区间和等于左右区间的区间和之和</span></span><br><span class="line">       <span class="keyword">int</span> i = leftT.iSum + rightT.iSum;</span><br><span class="line">       <span class="comment">// 新子段的最大子段和，其子段有可能穿过左右区间，或左区间，或右区间</span></span><br><span class="line">       <span class="keyword">int</span> m = Math.max(leftT.rSum + rightT.lSum, Math.max(leftT.mSum, rightT.mSum));</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> wtevTree(l, r, i, m);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 递归建立和获得输入区间所有子段的结构</span></span><br><span class="line">   <span class="function">wtevTree <span class="title">getInfo</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 若区间长度为1，其四个子段均为其值</span></span><br><span class="line">       <span class="keyword">if</span> (left == right)</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">new</span> wtevTree(nums[left], nums[left], nums[left], nums[left]);</span><br><span class="line">       <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;<span class="comment">// 获得中间点mid</span></span><br><span class="line">       wtevTree leftT = getInfo(nums, left, mid);</span><br><span class="line">       wtevTree rightT = getInfo(nums, mid + <span class="number">1</span>, right);<span class="comment">//mid+1,左右区间没有交集。</span></span><br><span class="line">       <span class="keyword">return</span> pushUp(leftT, rightT);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h2 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a>15. 三数之和</h2><h6 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h6><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。</p>
<p>注意：答案中不可以包含重复的三元组。</p>
<p> 示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">给定数组 nums &#x3D; [-1, 0, 1, 2, -1, -4]，</span><br><span class="line"></span><br><span class="line">满足要求的三元组集合为：</span><br><span class="line">[</span><br><span class="line">  [-1, 0, 1],</span><br><span class="line">  [-1, -1, 2]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>来源：力扣（LeetCode）</p>
<h6 id="思路分析-3"><a href="#思路分析-3" class="headerlink" title="思路分析"></a>思路分析</h6><ul>
<li>和二数和比较 a + b = 9,三数和变为 a + b = -c.其中重要的一点是需要去重。为了去重可以<strong>先将数组排序</strong>，在遇到nums[i] == nums[i - 1]直接跳过就可以了</li>
<li>最外层循环nums.length - 2次，循环过后不用考虑之前下标的元素，如果再考虑的话会出现重复</li>
</ul>
<h6 id="时间复杂度-3"><a href="#时间复杂度-3" class="headerlink" title="时间复杂度"></a>时间复杂度</h6><p>O(logn) +O(n^2)</p>
<h6 id="空间复杂度-3"><a href="#空间复杂度-3" class="headerlink" title="空间复杂度"></a>空间复杂度</h6><p>O(n)</p>
<h6 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums)&#123;</span><br><span class="line">       Arrays.sort(nums);</span><br><span class="line">       ArrayList&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">2</span>; i++) &#123;</span><br><span class="line">           </span><br><span class="line">           <span class="comment">//去重</span></span><br><span class="line">           <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>])&#123;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">           <span class="keyword">int</span> k = i + <span class="number">1</span>,j = nums.length - <span class="number">1</span>;</span><br><span class="line">           <span class="keyword">while</span>(k &lt; j)&#123;</span><br><span class="line">               <span class="keyword">if</span>(nums[j] + nums[k] == -nums[i])&#123;</span><br><span class="line">                   ArrayList&lt;Integer&gt; set = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                   set.add(nums[i]);</span><br><span class="line">                   set.add(nums[j]);</span><br><span class="line">                   set.add(nums[k]);</span><br><span class="line">                   list.add(set);</span><br><span class="line">                   k++;</span><br><span class="line">                   </span><br><span class="line">                   <span class="comment">//去重</span></span><br><span class="line">                   <span class="keyword">while</span>(k &lt; j &amp;&amp; nums[k -<span class="number">1</span>] == nums[k])&#123;</span><br><span class="line">                       k++;</span><br><span class="line">                   &#125;</span><br><span class="line">                   </span><br><span class="line">                   j--;</span><br><span class="line">                   </span><br><span class="line">                   <span class="comment">//去重</span></span><br><span class="line">                   <span class="keyword">while</span>(k &lt; j &amp;&amp; nums[j] == nums[k - <span class="number">1</span>])&#123;</span><br><span class="line">                       j--;</span><br><span class="line">                   &#125;</span><br><span class="line">                   </span><br><span class="line">               &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[j] + nums[k] &lt; -nums[i])&#123;<span class="comment">//小于nums[i],左端的指针向右移动，寻找更大的组合</span></span><br><span class="line">                   k++;</span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;<span class="comment">//大于nums[i],右端的指针向左移动，寻找更小的组合</span></span><br><span class="line">                   j--;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="最佳股票投资方案"><a href="#最佳股票投资方案" class="headerlink" title="最佳股票投资方案"></a>最佳股票投资方案</h1><h2 id="1-可购买1次"><a href="#1-可购买1次" class="headerlink" title="1.可购买1次"></a>1.可购买1次</h2><h4 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h4><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。</p>
<p>注意：你不能在买入股票前卖出股票。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出，最大利润 &#x3D; 6-1 &#x3D; 5 。</span><br><span class="line">     注意利润不能是 7-1 &#x3D; 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</span><br><span class="line"></span><br><span class="line">来源：力扣（LeetCode）</span><br></pre></td></tr></table></figure>

<h4 id="思路分析-4"><a href="#思路分析-4" class="headerlink" title="思路分析"></a>思路分析</h4><ul>
<li>从第一天的股价开始，需要一个minprice记录最小股价和一个maxprofit记录最大利润</li>
<li>循环n次，最后的maxprofit即是最大利润</li>
</ul>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul>
<li>时间复杂度O(n)</li>
<li>空间复杂度O(1)</li>
</ul>
<h4 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">method</span><span class="params">(<span class="keyword">int</span>[] prices)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> minprice = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> maxprofit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//记录最小股价</span></span><br><span class="line">            <span class="keyword">if</span>(prices[i] &lt; minprice)&#123;</span><br><span class="line">                minprice = prices[i];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//记录最大利润</span></span><br><span class="line">            <span class="keyword">if</span>(prices[i] - minprice &gt;maxprofit)&#123;</span><br><span class="line">                maxprofit = prices[i] - minprice;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxprofit;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="2-可购买任意次"><a href="#2-可购买任意次" class="headerlink" title="2. 可购买任意次"></a>2. 可购买任意次</h2><h4 id="问题描述-3"><a href="#问题描述-3" class="headerlink" title="问题描述"></a>问题描述</h4><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p>
<p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p>示例1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 7</span><br><span class="line">解释: 在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 3 天（股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5-1 &#x3D; 4 。</span><br><span class="line">     随后，在第 4 天（股票价格 &#x3D; 3）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出, 这笔交易所能获得利润 &#x3D; 6-3 &#x3D; 3 。</span><br><span class="line"></span><br><span class="line">来源：力扣（LeetCode）</span><br></pre></td></tr></table></figure>

<h4 id="思路分析-5"><a href="#思路分析-5" class="headerlink" title="思路分析"></a>思路分析</h4><ul>
<li><p>两个状态变量</p>
<ul>
<li>cash：不持有股票的最大利润</li>
<li>hold：持有股票的最大利润</li>
</ul>
</li>
<li><p>状态转移方程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cash = Math.max(cash, hold + prices[i]);</span><br><span class="line">hold = Math.max(hold, cash - prices[i]);</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>两个方程先后顺序可以互换，cash和hold只能有一个发生变化，所以不需要临时变量<br>比如cash变为hold + prices[i] - fee，cash - prices[i] = hold + prices[i] - fee - prices[i] = hold -fee，永远小于 hold</strong></li>
</ul>
</li>
<li><p><strong>为什么不用临时变量</strong></p>
</li>
</ul>
<h4 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul>
<li>时间复杂度O(n)</li>
<li>空间复杂度O(1)</li>
</ul>
<h4 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">method6</span><span class="params">(<span class="keyword">int</span>[] prices)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cash = <span class="number">0</span>, hold = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//cash只能有一个发生变化，所以不需要临时变量</span></span><br><span class="line">            cash = Math.max(cash, hold + prices[i]);</span><br><span class="line">            hold = Math.max(hold, cash - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cash;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="3-可购买任意次（冷冻期）"><a href="#3-可购买任意次（冷冻期）" class="headerlink" title="3. 可购买任意次（冷冻期）"></a>3. 可购买任意次（冷冻期）</h2><h4 id="问题描述-4"><a href="#问题描述-4" class="headerlink" title="问题描述"></a>问题描述</h4><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。</p>
<p>注意：你不能在买入股票前卖出股票。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出，最大利润 &#x3D; 6-1 &#x3D; 5 。</span><br><span class="line">     注意利润不能是 7-1 &#x3D; 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</span><br><span class="line"></span><br><span class="line">来源：力扣（LeetCode）</span><br></pre></td></tr></table></figure>

<h4 id="思路分析-6"><a href="#思路分析-6" class="headerlink" title="思路分析"></a>思路分析</h4><ul>
<li><strong>为什么不用临时变量和用临时变量</strong></li>
<li>添加一个变量<ul>
<li>cool：记录冷冻期的最大利润</li>
</ul>
</li>
<li>和上面第二个问题的区别：在不持有股票的时候<strong>不再是从上一次持有股票的时候</strong>减去今天的股价，而<strong>是从上一个冷冻期</strong>减去今天的股价。</li>
</ul>
<h4 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul>
<li>时间复杂度O(n)</li>
<li>空间复杂度O(1)</li>
</ul>
<h4 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">没用临时变量</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">method3</span><span class="params">(<span class="keyword">int</span>[] prices)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cash = <span class="number">0</span>, hold = -prices[<span class="number">0</span>],cool = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            cash = Math.max(cash, cool + prices[i]);</span><br><span class="line">            cool = Math.max(cash,cool);</span><br><span class="line">            hold = Math.max(hold, cash - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cash;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">用临时变量之后</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cash = <span class="number">0</span>, hold = -prices[<span class="number">0</span>],cool = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cash2 = <span class="number">0</span>, hold2 = -prices[<span class="number">0</span>],cool2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//重点在这三个表达式顺序，有没有依赖关系，在这个问题有，最好加上临时变量，或者按照method3的顺序，再只含有cash 和 hold的没有依赖关系，所以不用临时变量</span></span><br><span class="line">            hold = Math.max(hold2, cool2 - prices[i]);</span><br><span class="line">            cool = Math.max(cash2,cool2);</span><br><span class="line">            cash = Math.max(cash2, hold2 + prices[i]);</span><br><span class="line">            </span><br><span class="line">            hold2 = hold;</span><br><span class="line">            cool2 = cool;</span><br><span class="line">            cash2 = cash;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cash;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="4-可购买任意次（手续费）"><a href="#4-可购买任意次（手续费）" class="headerlink" title="4. 可购买任意次（手续费）"></a>4. 可购买任意次（手续费）</h2><h4 id="问题描述-5"><a href="#问题描述-5" class="headerlink" title="问题描述"></a>问题描述</h4><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p>
<p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p>示例1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 7</span><br><span class="line">解释: 在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 3 天（股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5-1 &#x3D; 4 。</span><br><span class="line">     随后，在第 4 天（股票价格 &#x3D; 3）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出, 这笔交易所能获得利润 &#x3D; 6-3 &#x3D; 3 。</span><br><span class="line"></span><br><span class="line">来源：力扣（LeetCode）</span><br></pre></td></tr></table></figure>

<h4 id="思路分析-7"><a href="#思路分析-7" class="headerlink" title="思路分析"></a>思路分析</h4><ul>
<li>和第二个问题区别：再不持有股票有可能<strong>发生卖股票的活动时</strong>，需要减去fee</li>
</ul>
<h4 id="复杂度分析-3"><a href="#复杂度分析-3" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul>
<li>时间复杂度O(n)</li>
<li>空间复杂度O(1)</li>
</ul>
<h4 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">method6</span><span class="params">(<span class="keyword">int</span>[] prices,<span class="keyword">int</span> fee)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cash = <span class="number">0</span>, hold = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//cash和hold只能有一个发生变化，所以不需要临时变量</span></span><br><span class="line">            <span class="comment">//比如cash变为hold + prices[i] - fee，cash - prices[i] = hold + prices[i] - fee - prices[i] = hold -fee，永远小于 hold</span></span><br><span class="line">            cash = Math.max(cash, hold + prices[i] - fee);</span><br><span class="line">            hold = Math.max(hold, cash - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cash;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="5-可购买2次"><a href="#5-可购买2次" class="headerlink" title="5. 可购买2次"></a>5. 可购买2次</h2><h4 id="问题描述-6"><a href="#问题描述-6" class="headerlink" title="问题描述"></a>问题描述</h4><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。</p>
<p>注意：你不能在买入股票前卖出股票。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出，最大利润 &#x3D; 6-1 &#x3D; 5 。</span><br><span class="line">     注意利润不能是 7-1 &#x3D; 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</span><br><span class="line"></span><br><span class="line">来源：力扣（LeetCode）</span><br></pre></td></tr></table></figure>

<h4 id="思路分析-8"><a href="#思路分析-8" class="headerlink" title="思路分析"></a>思路分析</h4><ol>
<li><p>判断数组的长度和是否为空</p>
</li>
<li><p>确定两个状态数组</p>
<ul>
<li>dp0: 不持有股票时的最大利润</li>
<li>dp1: 持有股票后的最大利润</li>
</ul>
</li>
<li><p>初始化：dp0 全部位0；dp1根据股价变化</p>
</li>
<li><p><strong>状态转移方程</strong></p>
<ul>
<li><p><strong>为什么dp0是j-1，而dp1是j？</strong></p>
<p>因为dp0表示的是不持有股票，如果需要买的话，肯定是上一次卖玩后买所以是j-1次；</p>
<p>而dp1是持有股票，需要卖的话一定是这次不持有股票（买或者不买）的数据，j次。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp0[i][j] &#x3D; Math.max(dp0[i-1][j],dp1[i-1][j-1] + prices[i]);</span><br><span class="line">dp1[i][j] &#x3D; Math.max(dp1[i-1][j],dp0[i-1][j] - prices[i]);</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="复杂度分析-4"><a href="#复杂度分析-4" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(n),可优化，第6个问题即优化后的版本</li>
</ul>
<h4 id="代码实现-7"><a href="#代码实现-7" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">method4</span><span class="params">(<span class="keyword">int</span>[] prices)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(prices.length == <span class="number">0</span> &amp;&amp; prices == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> max = <span class="number">0</span>,k = <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> days = prices.length;</span><br><span class="line">            <span class="keyword">int</span>[][] dp0 = <span class="keyword">new</span> <span class="keyword">int</span>[days][k + <span class="number">1</span>];<span class="comment">//不持有股票时的最大利润</span></span><br><span class="line">            <span class="keyword">int</span>[][] dp1 = <span class="keyword">new</span> <span class="keyword">int</span>[days][k + <span class="number">1</span>]; <span class="comment">//持有股票后的最大利润</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//初始化dp数组:dp0不持有即全部为0，自动初始化即可完成;dp1在第一天持有股票最大利润只能是-prices[0]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            dp1[<span class="number">0</span>][i] = -prices[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//第二天到最后一天最大利润要根据当天股价决定</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; days; i++) &#123;</span><br><span class="line">            dp1[i][<span class="number">0</span>] = Math.max(dp1[i - <span class="number">1</span>][<span class="number">0</span>],-prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; days; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; k + <span class="number">1</span>; j++) &#123;</span><br><span class="line">                dp0[i][j] = Math.max(dp0[i-<span class="number">1</span>][j],dp1[i-<span class="number">1</span>][j-<span class="number">1</span>] + prices[i]);</span><br><span class="line">                dp1[i][j] = Math.max(dp1[i-<span class="number">1</span>][j],dp0[i-<span class="number">1</span>][j] - prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            max = Math.max(dp0[days - <span class="number">1</span>][i],max);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="6-可购买k次"><a href="#6-可购买k次" class="headerlink" title="6. 可购买k次"></a>6. 可购买k次</h2><h4 id="问题描述-7"><a href="#问题描述-7" class="headerlink" title="问题描述"></a>问题描述</h4><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。</p>
<p>注意：你不能在买入股票前卖出股票。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出，最大利润 &#x3D; 6-1 &#x3D; 5 。</span><br><span class="line">     注意利润不能是 7-1 &#x3D; 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</span><br><span class="line"></span><br><span class="line">来源：力扣（LeetCode）</span><br></pre></td></tr></table></figure>

<h4 id="思路分析-9"><a href="#思路分析-9" class="headerlink" title="思路分析"></a>思路分析</h4><ol>
<li><p>判断数组的长度和是否为空</p>
</li>
<li><p>确定两个状态数组</p>
<ol>
<li>dp0: 不持有股票时的最大利润</li>
<li>dp1: 持有股票后的最大利润</li>
</ol>
</li>
<li><p>初始化：dp0 全部位0；dp1根据股价变化</p>
</li>
<li><p>状态转移方程</p>
<ul>
<li><strong>为什么dp0是j-1，而dp1是j？</strong></li>
</ul>
<p>因为dp0表示的是不持有股票，如果需要买的话，肯定是上一次卖玩后买所以是j-1次；</p>
<p>而dp1是持有股票，需要卖的话一定是这次不持有股票（买或者不买）的数据，j次。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp0[j] &#x3D; Math.max(dp0[j],dp1[j-1] + prices[i]);</span><br><span class="line">dp1[j] &#x3D; Math.max(dp1[j],dp0[j] - prices[i]);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>在购买days / 2 次以上时，会出现错误，因为最多days / 2次即可完成所有情况，超过即可看作没有规定购买次数，回到第2个问题，要分类讨论</strong></p>
</li>
</ol>
<h4 id="复杂度分析-5"><a href="#复杂度分析-5" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)</li>
</ul>
<h4 id="代码实现-8"><a href="#代码实现-8" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">method5</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span>[] prices)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.length == <span class="number">0</span> &amp;&amp; prices == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> days = prices.length;</span><br><span class="line">    </span><br><span class="line">    	<span class="comment">//最多购卖 days / 2次，如果超出，按照无限制处理，回到了任意次</span></span><br><span class="line">        <span class="keyword">if</span>(k &gt; days / <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; days; i++) &#123;</span><br><span class="line">                max += Math.max(prices[i+<span class="number">1</span>] - prices[i],<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> max;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">int</span>[] dp0 = <span class="keyword">new</span> <span class="keyword">int</span>[k + <span class="number">1</span>];<span class="comment">//不持有股票时的最大利润</span></span><br><span class="line">        <span class="keyword">int</span>[] dp1 = <span class="keyword">new</span> <span class="keyword">int</span>[k + <span class="number">1</span>]; <span class="comment">//持有股票后的最大利润</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            dp1[i] = -prices[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; days - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            dp1[<span class="number">0</span>] = Math.max(dp1[<span class="number">0</span>], - prices[i]);<span class="comment">//初始化，db1[0]即上次</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; k + <span class="number">1</span>; j++) &#123;</span><br><span class="line">                dp0[j] = Math.max(dp0[j],dp1[j-<span class="number">1</span>] + prices[i]);</span><br><span class="line">                dp1[j] = Math.max(dp1[j],dp0[j] - prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            max = Math.max(dp0[i],max);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="523-连续的子数组和"><a href="#523-连续的子数组和" class="headerlink" title="523. 连续的子数组和"></a>523. 连续的子数组和</h1><h6 id="问题描述-8"><a href="#问题描述-8" class="headerlink" title="问题描述"></a>问题描述</h6><p>给定一个包含非负数的数组和一个目标整数 k，编写一个函数来判断该数组是否含有连续的子数组，其大小至少为 2，总和为 k 的倍数，即总和为 n*k，其中 n 也是一个整数。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [23,2,4,6,7], k &#x3D; 6</span><br><span class="line">输出: True</span><br><span class="line">解释: [2,4] 是一个大小为 2 的子数组，并且和为 6。</span><br></pre></td></tr></table></figure>

<p>来源：力扣（LeetCode）</p>
<h6 id="思路分析-10"><a href="#思路分析-10" class="headerlink" title="思路分析"></a>思路分析</h6><ul>
<li>利用Hashmap</li>
</ul>
<h6 id="时间复杂度-4"><a href="#时间复杂度-4" class="headerlink" title="时间复杂度"></a>时间复杂度</h6><h6 id="空间复杂度-4"><a href="#空间复杂度-4" class="headerlink" title="空间复杂度"></a>空间复杂度</h6><h6 id="代码实现-9"><a href="#代码实现-9" class="headerlink" title="代码实现"></a>代码实现</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h1 id><a href="#" class="headerlink" title></a></h1>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/111zx/111zx.github.io/2020/05/12/leetcode/" data-id="ckbbzdvs80004t8ubdpgh1t35" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-集合" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/31/%E9%9B%86%E5%90%88/" class="article-date">
  <time datetime="2020-03-31T01:55:33.000Z" itemprop="datePublished">2020-03-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/31/%E9%9B%86%E5%90%88/">集合</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<h1 id="集合框架的概述"><a href="#集合框架的概述" class="headerlink" title="集合框架的概述"></a>集合框架的概述</h1><h2 id="集合与数组的比较"><a href="#集合与数组的比较" class="headerlink" title="集合与数组的比较"></a>集合与数组的比较</h2><ul>
<li><p>集合与数组都是对多个数据进行存储的，简称Java容器</p>
<ul>
<li><p>说明：<strong>此时的存储主要是内存层面的存储</strong>，不涉及到持久化(硬盘)的存储。例如.txt,.sql都是硬盘存储</p>
<h4 id="数组在存储多个数据方面的优缺点"><a href="#数组在存储多个数据方面的优缺点" class="headerlink" title="数组在存储多个数据方面的优缺点"></a>数组在存储多个数据方面的优缺点</h4></li>
<li><p>优点：</p>
<ul>
<li>一旦初始化以后，<strong>长度是确定的</strong></li>
<li>数组一旦定义好，元素的类型也确定了，只能操作<strong>确定类型</strong>的数据。Object[] arr可以实现<strong>多态</strong></li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>一旦初始化好，长度不可修改</li>
<li>数组中提供的操作等<strong>方法非常有限</strong>，效率低</li>
<li>获取数组中<strong>实际元素的个数，数组中没有</strong>现成的方法</li>
<li>数组存储数据的特点：<strong>有序，可重复</strong>。对于无序，不可重复的需求，不能满足</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="集合框架体系"><a href="#集合框架体系" class="headerlink" title="集合框架体系"></a>集合框架体系</h2><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>大概分为Collection和Map两种体系</p>
<ul>
<li>Collection接口，单列集合，用来存储一个一个的对象<ul>
<li>List：有序，可重复。<strong>“动态”</strong>数组</li>
<li>Set：无序，不可重复。类似于高中课本上的集合</li>
</ul>
</li>
<li>Map接口：双列集合，用来存储一对（key，value）的数组。类似于高中课本上的函数y = value（key），一个key不可以对应多个value</li>
</ul>
<hr>
<h3 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h3><h4 id="方法总结"><a href="#方法总结" class="headerlink" title="方法总结"></a>方法总结</h4><h5 id="add"><a href="#add" class="headerlink" title="add()"></a>add()</h5><h5 id="addAll"><a href="#addAll" class="headerlink" title="addAll()"></a>addAll()</h5><ul>
<li>将一个集合中的元素全部加到当前集合</li>
</ul>
<h5 id="isEmpty"><a href="#isEmpty" class="headerlink" title="isEmpty()"></a>isEmpty()</h5><h5 id="clear"><a href="#clear" class="headerlink" title="clear()"></a>clear()</h5><ul>
<li>清空集合元素的<strong>数据</strong></li>
</ul>
<h5 id="contains"><a href="#contains" class="headerlink" title="contains()"></a>contains()</h5><ul>
<li><p>判断当前集合中是否包含括号内元素</p>
</li>
<li><p>调用的是括号内类元素的内置<strong>equals()方法</strong>，String类（重写了equals()方法，比的是变量）和一般的没有重写equals()方法的类contains()结果会有出入</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> Collection coll = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        coll.add(<span class="keyword">new</span> String(<span class="string">"Tom"</span>));</span><br><span class="line">        coll.add(<span class="keyword">new</span> Person(<span class="string">"jerry"</span>,<span class="number">20</span>));</span><br><span class="line">		System.out.println(coll.contains(<span class="keyword">new</span> String(<span class="string">"Tom"</span>)));<span class="comment">//equals比内容</span></span><br><span class="line">		System.out.println(coll.contains(<span class="keyword">new</span> Person(<span class="string">"jerry"</span>,<span class="number">20</span>)));<span class="comment">//equals比地址</span></span><br><span class="line">输出：</span><br><span class="line">    <span class="keyword">true</span></span><br><span class="line">    <span class="keyword">false</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="containsAll"><a href="#containsAll" class="headerlink" title="containsAll()"></a>containsAll()</h5><ul>
<li>判断括号内集合中的元素是否<strong>都包含</strong>在当前集合内</li>
</ul>
<h5 id="remove"><a href="#remove" class="headerlink" title="remove()"></a>remove()</h5><ul>
<li>也会调用<strong>equals()</strong>方法</li>
</ul>
<h5 id="removeAll"><a href="#removeAll" class="headerlink" title="removeAll()"></a>removeAll()</h5><ul>
<li><strong>差集</strong></li>
<li>从当前集合移除括号内集合所有的元素</li>
</ul>
<h5 id="retainAll"><a href="#retainAll" class="headerlink" title="retainAll()"></a>retainAll()</h5><ul>
<li>当前集合和括号内集合的<strong>交集</strong></li>
</ul>
<h5 id="equals"><a href="#equals" class="headerlink" title="equals()"></a>equals()</h5><ul>
<li>比较括号内元素是否相等</li>
</ul>
<h5 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode()"></a>hashCode()</h5><ul>
<li>根据集合内元素，返回哈希值</li>
</ul>
<h5 id="toArray"><a href="#toArray" class="headerlink" title="toArray()"></a>toArray()</h5><ul>
<li>集合转换为数组</li>
<li>数组转变为集合：<ul>
<li>ArrayList list = Arrays.asList({1,2,3})</li>
<li><strong>ArrayList list = Arrays.asList(new int[]{1,2,3})</strong>会出错，被认为是一个数组元素</li>
<li><strong>ArrayList list = Arrays.asList(new Integer[]{1,2,3})</strong>正确，包装类被认为是两个元素</li>
</ul>
</li>
</ul>
<h5 id="iterator"><a href="#iterator" class="headerlink" title="iterator()"></a>iterator()</h5><ul>
<li><p>集合元素的遍历，实现了Iterator接口</p>
</li>
<li><p>hasNext()和next()方法的使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Iterator iterator = coll1.iterator();<span class="comment">//iterator是一个对象实现了Iterator接口，不是容器</span></span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>迭代器执行原理</p>
<ul>
<li>hasNext()只是判断下一个地址有没有数据</li>
<li>next()是指针下移一个位置，指针一开始再第一个的钱一个位置</li>
</ul>
</li>
<li><p>错误写法</p>
<ul>
<li><pre><code class="java"><span class="keyword">while</span>((iterator.next() != <span class="keyword">null</span>)){<span class="comment">//每次调用next()都会下移一位，会丢数据</span>
    <span class="comment">//有可能while循环里的元素是最后一个，不是空，但是执行完之后下移一个，指针变为空，会出空指针现异常</span>
            System.out.println(iterator.next());
        }
&lt;!--￼<span class="number">2</span>--&gt;</code></pre>
</li>
</ul>
</li>
<li><p>每次调用iterator()方法，会生成一个迭代器</p>
</li>
<li><p>remove()方法</p>
<ul>
<li><pre><code class="java"><span class="comment">//删除集合中的"Tom"元素</span>
<span class="keyword">while</span>(iterator.hasNext()){
            Object obj = iterator.next();
            <span class="keyword">if</span>(obj.equals(<span class="string">"Tom"</span>)){
                iterator.remove();
            }
        }
&lt;!--￼<span class="number">3</span>--&gt;</code></pre>
</li>
</ul>
</li>
<li><p><strong>内部调用的还是Iterator</strong></p>
</li>
</ul>
<h4 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h4><h5 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h5><ul>
<li><strong>有序，可重复</strong></li>
<li>每个元素都有对应的顺序索引</li>
<li>ArrayList,LinkedList和Vector区别和联系<ul>
<li>相同点：<ul>
<li>都实现了List接口，存储有序，可重复的</li>
</ul>
</li>
<li>不同点<ul>
<li>Vector是1.2出现的，古老版本。<strong>效率低，线程安全</strong>。底层使用<strong>Object[]</strong>实现。利用了synchronized关键字。</li>
<li>ArrayList：<strong>效率高，线程不安全</strong>。底层使用<strong>Object[]</strong>实现。删除操作时顺序执行。例如，在10000个元素中删掉第三个元素，从第4个到第10000个元素都得变化。</li>
<li>LinkedList：底层是使用<strong>双向链表</strong>。对于频繁插入和<strong>删除</strong>操作，效率比ArrayList高</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h5><h6 id="源码分析（jdk7）"><a href="#源码分析（jdk7）" class="headerlink" title="源码分析（jdk7）"></a>源码分析（jdk7）</h6><ul>
<li><p>底层：Object[] element</p>
</li>
<li><p>构造函数：ArrayList list = new ArrayList（）。<strong>默认</strong>初始有<strong>10</strong>个元素</p>
<ul>
<li><pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>{
        <span class="keyword">super</span>();
        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)
            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+
                                               initialCapacity);
        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];
    }
<span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>{
        <span class="keyword">this</span>(<span class="number">10</span>);
    }
&lt;!--￼<span class="number">4</span>--&gt;</code></pre>
</li>
</ul>
</li>
<li><p><strong>扩容源码</strong></p>
<ul>
<li><pre><code class="java"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>{
        <span class="comment">// overflow-conscious code</span>
        <span class="keyword">int</span> oldCapacity = elementData.length;
        <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);<span class="comment">//变更为1.5倍</span>

    <span class="comment">//如果不够，变为传过来的参数minCapacity</span>
        <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)
            newCapacity = minCapacity;

    <span class="comment">//如果还不够，变为一个提前设置的最大值</span>
    <span class="comment">//再不够，到整型最大值，不够就error</span>
        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)
            newCapacity = hugeCapacity(minCapacity);
        <span class="comment">// minCapacity is usually close to size, so this is a win:建立一个新的数组，把原来的值copy进去，再赋值给elementData</span>
        elementData = Arrays.copyOf(elementData, newCapacity);
    }
&lt;!--￼<span class="number">5</span>--&gt;</code></pre>
</li>
</ul>
</li>
<li><p>此一次调用<strong>add()</strong>方法时，才创建了长度为10的数组，并将数组添加到集合中、</p>
<ul>
<li><pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>{
        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span>
        elementData[size++] = e;
        <span class="keyword">return</span> <span class="keyword">true</span>;
    }
<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>{
        ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));
    }

<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateCapacity</span><span class="params">(Object[] elementData, <span class="keyword">int</span> minCapacity)</span> </span>{
        <span class="comment">//DEFAULT_CAPACITY为10，是默认值</span>
        <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
            <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);
        }
        <span class="keyword">return</span> minCapacity;
        }
<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>{
        modCount++;

        <span class="comment">// overflow-conscious code</span>
        <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)
            grow(minCapacity);
    }
&lt;!--￼<span class="number">6</span>--&gt;</code></pre>
</li>
</ul>
</li>
<li><p>add()</p>
<ul>
<li><pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>{
        linkLast(e);
        <span class="keyword">return</span> <span class="keyword">true</span>;
    }

<span class="comment">/**</span>
<span class="comment">     * Links e as last element.</span>
<span class="comment">     */</span>
<span class="comment">//链表的尾部加如节点</span>
<span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>{
        <span class="keyword">final</span> Node&lt;E&gt; l = last;
        <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);
        last = newNode;
        <span class="keyword">if</span> (l == <span class="keyword">null</span>)<span class="comment">//空的时候</span>
            first = newNode;
        <span class="keyword">else</span>
            l.next = newNode;
        size++;
        modCount++;
    }
&lt;!--￼<span class="number">7</span>--&gt;
</code></pre>
</li>
</ul>
</li>
</ul>
<h6 id="addAll-ArrayList"><a href="#addAll-ArrayList" class="headerlink" title="addAll(ArrayList)"></a>addAll(ArrayList)</h6><ul>
<li><pre><code class="java">list.addAll(list1)<span class="comment">//list1的元素全部添加到list中</span>
&lt;!--￼<span class="number">8</span>--&gt;
</code></pre>
</li>
</ul>
<h6 id="indexof-Object"><a href="#indexof-Object" class="headerlink" title="indexof(Object)"></a>indexof(Object)</h6><ul>
<li><pre><code class="java"><span class="keyword">int</span> index = list.indexOf(<span class="number">123</span>)<span class="comment">//判断123在list的第一次出现的位置上，没有的化返回-1</span>
&lt;!--￼<span class="number">9</span>--&gt;
</code></pre>
</li>
</ul>
<h6 id="remove-index"><a href="#remove-index" class="headerlink" title="remove(index)"></a>remove(index)</h6><ul>
<li><p>和Collection中的remove()不同，这个是删除索引位置，而前一个是删除指定内容元素</p>
</li>
<li><pre><code class="java">list.remove(<span class="number">4</span>)<span class="comment">//返回删除索引位置4上的元素</span>
list.add(<span class="number">2</span>)
list.remove(<span class="number">2</span>)<span class="comment">//会出现错误，没有调用Collection的remove，而停在了List的remove上</span>
&lt;!--￼<span class="number">10</span>--&gt;
</code></pre>
</li>
</ul>
<h6 id="sublist-indexl，indexr"><a href="#sublist-indexl，indexr" class="headerlink" title="sublist(indexl，indexr)"></a>sublist(indexl，indexr)</h6><ul>
<li><pre><code class="java"><span class="comment">//返回一个左闭右开的一子集和，不会对原来的集合造成影响</span>
list.sublist(<span class="number">2</span>，<span class="number">4</span>)
&lt;!--￼<span class="number">11</span>--&gt;

- ```java
  map.put(key1,value1)<span class="comment">//首先调用key1所在类的hashCode()计算key1哈希值，此哈希值经过某种计算之后，会得到在Entry数组中的存放位置</span>
      <span class="comment">//如果位置上为空，则(key1,value1)添加成功</span>
      <span class="comment">//如果不为空（意味着此位置存在一个或者多个元素（多个存放在链表上）），则需要比较key和其他数据的哈希值</span>
          <span class="comment">//如果key1的哈希值和其他的哈希值都不相同，则添加成功</span>
          <span class="comment">//如果存在哈希值相同，调用key1所在类的equals方法</span>
              <span class="comment">//如果返回false，此时添加成功</span>
              <span class="comment">//如果返回true，使用value1替换相同key的value值。（修改了key1值相同的value值）</span>
  &lt;!--￼<span class="number">12</span>--&gt;

- 底层是以一个数组Entry[]存储，每个数组的对象包含<span class="number">4</span>个属性。其中next将每个数组对象组织成了链表</code></pre>
</li>
<li><p>put(key,value) </p>
<ul>
<li><pre><code class="java"><span class="number">1</span>. <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>{
<span class="number">2</span>. <span class="comment">// HashMap 允许存放 null 键和 null 值。</span>
<span class="number">3</span>. <span class="comment">// 当 key 为 null 时，调用 putForNullKey 方法，将 value 放置在数组第一个位置。</span>
<span class="number">4</span>.         <span class="keyword">if</span> (key == <span class="keyword">null</span>)
<span class="number">5</span>.             <span class="keyword">return</span> putForNullKey(value);
<span class="number">6</span>. <span class="comment">// 根据 key 的 keyCode 重新计算 hash 值。</span>
<span class="number">7</span>.         <span class="keyword">int</span> hash = hash(key.hashCode());
<span class="number">8</span>. <span class="comment">// 搜索指定 hash 值在对应 table 中的索引。</span>
<span class="number">9</span>.         <span class="keyword">int</span> i = indexFor(hash, table.length);
<span class="number">10</span>. <span class="comment">// 如果 i 索引处的 Entry 不为 null，通过循环不断遍历 e 元素的下一个元素。</span>
<span class="number">11</span>.     <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) {
<span class="number">12</span>.         Object k;
<span class="number">13</span>.         <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) {
<span class="number">14</span>.             V oldValue = e.value;
<span class="number">15</span>.             e.value = value;
<span class="number">16</span>.             e.recordAccess(<span class="keyword">this</span>);
<span class="number">17</span>.             <span class="keyword">return</span> oldValue;
<span class="number">18</span>.         }
<span class="number">19</span>.        }
<span class="number">20</span>. <span class="comment">// 如果 i 索引处的 Entry 为 null，表明此处还没有 Entry。</span>
<span class="number">21</span>.     modCount++;
<span class="number">22</span>. <span class="comment">// 将 key、value 添加到 i 索引处。</span>
<span class="number">23</span>.     addEntry(hash, key, value, i);
<span class="number">24</span>.     <span class="keyword">return</span> <span class="keyword">null</span>;
<span class="number">25</span>. }
&lt;!--￼<span class="number">13</span>--&gt;

- resize(<span class="number">2</span> * table.length)

&lt;!--￼<span class="number">14</span>--&gt;

- transfer(newTable, rehash)

  &lt;!--￼<span class="number">15</span>--&gt;


</code></pre>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>*hash(int h)</p>
<ul>
<li><pre><code class="java"><span class="comment">//hash(int h)方法根据 key 的 hashCode 重新计算一次散列。此算法加入了高位计算，防</span>
<span class="comment">//止低位不变，高位变化时，造成的 hash 冲突</span>
<span class="number">1</span>. <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> h)</span> </span>{
<span class="number">2</span>.         h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);
<span class="number">3</span>.         <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);
<span class="number">4</span>. }
&lt;!--￼<span class="number">16</span>--&gt;</code></pre>
</li>
</ul>
</li>
<li><p>get(Object key)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line"><span class="number">2</span>. 		<span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line"><span class="number">3</span>. 			<span class="keyword">return</span> getForNullKey();</span><br><span class="line"><span class="number">4</span>. 		<span class="keyword">int</span> hash = hash(key.hashCode());</span><br><span class="line"><span class="number">5</span>. 		<span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];e != <span class="keyword">null</span>;e = e.next)&#123;</span><br><span class="line"><span class="number">8</span>. 			Object k;</span><br><span class="line"><span class="number">9</span>. 			<span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k)))</span><br><span class="line"><span class="number">10</span>. 			<span class="keyword">return</span> e.value;</span><br><span class="line"><span class="number">11</span>. 		&#125;</span><br><span class="line"><span class="number">12</span>. 	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"><span class="number">13</span>. &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>getForNullKey()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在下标为1的数组元素开始遍历链表，找到key为NULL的value</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">getForNullKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[<span class="number">0</span>]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.key == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> e.value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>构造器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//默认数组长度16和负载因子0.75</span></span><br><span class="line">        <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)<span class="comment">//数组长度非法</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)<span class="comment">//数组长度超出最大值，强行以最大值构造</span></span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))<span class="comment">//负载因子非法</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                               loadFactor);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Find a power of 2 &gt;= initialCapacity</span></span><br><span class="line">        <span class="keyword">int</span> capacity = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (capacity &lt; initialCapacity)</span><br><span class="line">            capacity &lt;&lt;= <span class="number">1</span>;<span class="comment">//从2^0开始，保证数组的长度是2^n，有利于查找时的效率优化h&amp;（length-1）</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="comment">//最大不扩容数组长度 capacity * loadFactor</span></span><br><span class="line">        threshold = (<span class="keyword">int</span>)Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">        table = <span class="keyword">new</span> Entry[capacity];</span><br><span class="line">        useAltHashing = sun.misc.VM.isBooted() &amp;&amp;</span><br><span class="line">                (capacity &gt;= Holder.ALTERNATIVE_HASHING_THRESHOLD);</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<ul>
<li><p>remove</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//简单的链表删除节点操作</span></span><br><span class="line"><span class="comment">//根据hashcode算hash，再根据hash算index然后判断，删除</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">removeEntryForKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key);</span><br><span class="line">        <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">        Entry&lt;K,V&gt; prev = table[i];</span><br><span class="line">        Entry&lt;K,V&gt; e = prev;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">            Object k;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                modCount++;</span><br><span class="line">                size--;</span><br><span class="line">                <span class="keyword">if</span> (prev == e)</span><br><span class="line">                    table[i] = next;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    prev.next = next;</span><br><span class="line">                e.recordRemoval(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">return</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">            prev = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>Fail-Fast机制</p>
<ul>
<li><p>由于HashMap是线程不安全的，所以当有其他的线程修改了Map，modCount这个值就会发生改变，迭代器初始化过程中会将这个值赋值为expectedModCount。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. HashIterator() &#123;</span><br><span class="line"><span class="number">2</span>. 		expectedModCount = modCount;</span><br><span class="line"><span class="number">3</span>. 		<span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123; <span class="comment">// advance to first entry</span></span><br><span class="line"><span class="number">4</span>. 			Entry[] t = table;</span><br><span class="line"><span class="number">5</span>. 			<span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>)</span><br><span class="line"><span class="number">6</span>. 				;</span><br><span class="line"><span class="number">7</span>. 		&#125;</span><br><span class="line"><span class="number">8</span>. &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在迭代过程中，会判断expectedModCount 和 modCount值是否相等，不相等就会抛出ConcurrentModificationException异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. <span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">nextEntry</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="number">2</span>.	 	<span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line"><span class="number">3</span>.	 		<span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br></pre></td></tr></table></figure>
</li>
<li><p>编写依赖于此异常的程序的做法是错误的，正确做法是：迭代器的快速失败行为应该仅用于检测程序错误</p>
</li>
</ul>
</li>
</ul>
<h6 id="jdk8"><a href="#jdk8" class="headerlink" title="jdk8"></a>jdk8</h6><ul>
<li><p>一开始没有创建数组，put时创建</p>
</li>
<li><p>HashMap的属性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认的初始容量为 16</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br><span class="line"><span class="comment">//最大的容量上限为 2^30</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="comment">//默认的负载因子为 0.75</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"><span class="comment">//变成树型结构的临界值为 8</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"><span class="comment">//恢复链式结构的临界值为 6</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"><span class="comment">//哈希表</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"><span class="comment">//哈希表中键值对的个数</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"><span class="comment">//哈希表被修改的次数</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"><span class="comment">//它是通过 capacity*load factor 计算出来的，当 size 到达这个值时，</span></span><br><span class="line">就会进行扩容操作</span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"><span class="comment">//负载因子</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"><span class="comment">//当哈希表的大小超过这个阈值，才会把链式结构转化成树型结构，否则仅采取扩容来尝试减少冲突</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>HashMap中的节点不再是Entry，而实Node,具体作用和Entry相同</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"> <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line"> <span class="keyword">final</span> K key;</span><br><span class="line"> V value;</span><br><span class="line"> Node&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>get()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//get 方法主要调用的是 getNode 方法，所以重点要看 getNode 方法的实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">	Node&lt;K,V&gt; e;</span><br><span class="line">	<span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span>: e.value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">	Node&lt;K,V&gt;[] tab; </span><br><span class="line">   Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">	<span class="comment">//如果哈希表不为空 &amp;&amp; key 对应的桶上不为空</span></span><br><span class="line">	<span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;(first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="comment">//是否直接命中</span></span><br><span class="line">		<span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">		((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">			<span class="keyword">return</span> first;</span><br><span class="line">		<span class="comment">//判断是否有后续节点</span></span><br><span class="line">		<span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">//如果当前的桶是采用红黑树处理冲突，则调用红黑树的 get 方法去获取节点</span></span><br><span class="line">			<span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">				<span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">			<span class="comment">//不是红黑树的话，那就是传统的链式结构了，通过循环的方法判断链中是否存在该 key</span></span><br><span class="line">		 <span class="keyword">do</span> &#123;</span><br><span class="line">			 <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; </span><br><span class="line">			key.equals(k))))</span><br><span class="line">					<span class="keyword">return</span> e;</span><br><span class="line">					 &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>put()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">//如果哈希表为空，新创建一个新哈希表</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">//如果哈希表的对应位置为空，则直接插入键值对</span></span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            <span class="comment">//如果哈希值和key值都相等，那么出现重复的键值对，到最后换value即可</span></span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                e = p;</span><br><span class="line">            <span class="comment">//如果链表的结构已经编程了红黑树，那么进行红黑树插值处理</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="comment">//如果不是红黑树结构，那么就是链表结构，进行遍历查找相同key值节点</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                    <span class="comment">//如果没找到相等key值得节点，那么就在链表的末尾直接插入节点</span></span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                        <span class="comment">//如果一个链表的长度大于等于8，就会判断数组长度是否大于64</span></span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//如果找到了key值相同的节点，那么将p的信息修改为相同节点的信息</span></span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//修改key值相同的节点的value值</span></span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>resize()</strong></p>
<ul>
<li><strong>和jdk7有所不同，表现在从旧表网新表插入数据时的方法</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">        <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;<span class="comment">//旧表的长度</span></span><br><span class="line">        <span class="keyword">int</span> oldThr = threshold;<span class="comment">//旧表的阈值</span></span><br><span class="line">        <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//如果旧表的长度大于0</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//如果旧表的长度大于最大值，赋值最大值，不可再扩容</span></span><br><span class="line">            <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">                threshold = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">return</span> oldTab;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果新表的长度（2倍）合法的话，阈值也翻一倍</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">                newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//带有初始阈值参数的构造器，哈希表长度变为传进来的参数</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">            newCap = oldThr;</span><br><span class="line">    <span class="comment">//如股票还没有创建表，则初始化表的长度和阈值</span></span><br><span class="line">        <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">            newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">            newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//如果新的阈值等于0，则根据哈希表的长度计算阈值</span></span><br><span class="line">        <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                      (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        threshold = newThr;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">    <span class="comment">//根据新表的长度创建新表</span></span><br><span class="line">            Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">        table = newTab;</span><br><span class="line">        <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">                Node&lt;K,V&gt; e;</span><br><span class="line">                <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="comment">//如果位置为空，直接插入</span></span><br><span class="line">                    <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                        newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                    <span class="comment">//有树结构，树插入</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                    <span class="comment">//链表插入</span></span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    扩容每次乘以2的原因：增加了1位数据，n-1 相比 之前的 n - 1必定是多了一位1</span></span><br><span class="line"><span class="comment">                    这一位和原来的hash值进行 &amp; 操作时，只有两种情况：</span></span><br><span class="line"><span class="comment">                    等于0，计算结果和原来相同，位置不变</span></span><br><span class="line"><span class="comment">                    等于1，计算结果比原来相比，多了一个固定的值：2^( n-1 )</span></span><br><span class="line"><span class="comment">                    这样一来  原来位置的数据必定分成两拨存储：一部分在x，另一部分在x + 2^( n-1 )存，这样必定减少了冲突的概率</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                    <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                        Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; next;</span><br><span class="line">                        <span class="keyword">do</span> &#123;</span><br><span class="line">                            next = e.next;</span><br><span class="line">                            <span class="comment">////不需要移动的数据</span></span><br><span class="line">                            <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;  </span><br><span class="line">                                <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                    loHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = e;</span><br><span class="line">                                loTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">//需要移动的数据</span></span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                  hiHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = e;</span><br><span class="line">                                hiTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; </span><br><span class="line">                        <span class="comment">//分批插入新的链表中</span></span><br><span class="line">                        <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j] = loHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j + oldCap] = hiHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newTab;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>红黑树插值操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">putTreeVal</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">int</span> h, K k, V v)</span> </span>&#123;</span><br><span class="line">            Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">boolean</span> searched = <span class="keyword">false</span>;</span><br><span class="line">            TreeNode&lt;K,V&gt; root = (parent != <span class="keyword">null</span>) ? root() : <span class="keyword">this</span>;</span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> dir, ph; K pk;</span><br><span class="line">                <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                    dir = -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                    dir = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="keyword">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">                    <span class="keyword">return</span> p;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                          (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                         (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!searched) &#123;</span><br><span class="line">                        TreeNode&lt;K,V&gt; q, ch;</span><br><span class="line">                        searched = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="keyword">if</span> (((ch = p.left) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                             (q = ch.find(h, k, kc)) != <span class="keyword">null</span>) ||</span><br><span class="line">                            ((ch = p.right) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                             (q = ch.find(h, k, kc)) != <span class="keyword">null</span>))</span><br><span class="line">                            <span class="keyword">return</span> q;</span><br><span class="line">                    &#125;</span><br><span class="line">                    dir = tieBreakOrder(k, pk);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">                <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    Node&lt;K,V&gt; xpn = xp.next;</span><br><span class="line">                    TreeNode&lt;K,V&gt; x = map.newTreeNode(h, k, v, xpn);</span><br><span class="line">                    <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                        xp.left = x;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        xp.right = x;</span><br><span class="line">                    xp.next = x;</span><br><span class="line">                    x.parent = x.prev = xp;</span><br><span class="line">                    <span class="keyword">if</span> (xpn != <span class="keyword">null</span>)</span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)xpn).prev = x;</span><br><span class="line">                    moveRootToFront(tab, balanceInsertion(root, x));</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>红黑树获取节点操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">getTreeNode</span><span class="params">(<span class="keyword">int</span> h, Object k)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> ((parent != <span class="keyword">null</span>) ? root() : <span class="keyword">this</span>).find(h, k, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line"> <span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">find</span><span class="params">(<span class="keyword">int</span> h, Object k, Class&lt;?&gt; kc)</span> </span>&#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; p = <span class="keyword">this</span>;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> ph, dir; K pk;</span><br><span class="line">                TreeNode&lt;K,V&gt; pl = p.left, pr = p.right, q;</span><br><span class="line">                <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                    p = pl;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                    p = pr;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="keyword">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">                    <span class="keyword">return</span> p;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (pl == <span class="keyword">null</span>)</span><br><span class="line">                    p = pr;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (pr == <span class="keyword">null</span>)</span><br><span class="line">                    p = pl;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((kc != <span class="keyword">null</span> ||</span><br><span class="line">                          (kc = comparableClassFor(k)) != <span class="keyword">null</span>) &amp;&amp;</span><br><span class="line">                         (dir = compareComparables(kc, k, pk)) != <span class="number">0</span>)</span><br><span class="line">                    p = (dir &lt; <span class="number">0</span>) ? pl : pr;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((q = pr.find(h, k, kc)) != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> q;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    p = pl;</span><br><span class="line">            &#125; <span class="keyword">while</span> (p != <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>remove()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ?</span><br><span class="line">            <span class="keyword">null</span> : e.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, index;</span><br><span class="line">    <span class="comment">//如果哈希表不为空，且哈希表的长度大于0，并且计算出来的位置信息不是空，继续</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node&lt;K,V&gt; node = <span class="keyword">null</span>, e; K k; V v;</span><br><span class="line">            <span class="comment">//如果找到了hash值和key值都相等的节点，记录节点信息</span></span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                node = p;</span><br><span class="line">            <span class="comment">//如果在哈希表的元素上已经形成了链表，那么进行遍历操作</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//如果已经形成了红黑树，进行红黑树查询节点操作</span></span><br><span class="line">                <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">                <span class="comment">//如果没有形成红黑树，那么进行链表查询</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//</span></span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                            ((k = e.key) == key ||</span><br><span class="line">                             (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                            node = e;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        p = e;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                                 (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">                <span class="comment">//查找得到的Node是红黑树节点，那么进行树的删除节点操作</span></span><br><span class="line">                <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</span><br><span class="line">                <span class="comment">//如果节点是哈希表中存放的链表头，那么直接指向下一个节点即可</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                    tab[index] = node.next;</span><br><span class="line">                <span class="comment">//如果是链表里面的节点，那么进行链表删除节点操作</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    p.next = node.next;</span><br><span class="line">                ++modCount;</span><br><span class="line">                --size;</span><br><span class="line">                afterNodeRemoval(node);</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>红黑树删除节点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">removeTreeNode</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> n;</span><br><span class="line">            <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">int</span> index = (n - <span class="number">1</span>) &amp; hash;</span><br><span class="line">            TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index], root = first, rl;</span><br><span class="line">            TreeNode&lt;K,V&gt; succ = (TreeNode&lt;K,V&gt;)next, pred = prev;</span><br><span class="line">            <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">                tab[index] = first = succ;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                pred.next = succ;</span><br><span class="line">            <span class="keyword">if</span> (succ != <span class="keyword">null</span>)</span><br><span class="line">                succ.prev = pred;</span><br><span class="line">            <span class="keyword">if</span> (first == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span> (root.parent != <span class="keyword">null</span>)</span><br><span class="line">                root = root.root();</span><br><span class="line">            <span class="keyword">if</span> (root == <span class="keyword">null</span> || root.right == <span class="keyword">null</span> ||</span><br><span class="line">                (rl = root.left) == <span class="keyword">null</span> || rl.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">                tab[index] = first.untreeify(map);  <span class="comment">// too small</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            TreeNode&lt;K,V&gt; p = <span class="keyword">this</span>, pl = left, pr = right, replacement;</span><br><span class="line">            <span class="keyword">if</span> (pl != <span class="keyword">null</span> &amp;&amp; pr != <span class="keyword">null</span>) &#123;</span><br><span class="line">                TreeNode&lt;K,V&gt; s = pr, sl;</span><br><span class="line">                <span class="keyword">while</span> ((sl = s.left) != <span class="keyword">null</span>) <span class="comment">// find successor</span></span><br><span class="line">                    s = sl;</span><br><span class="line">                <span class="keyword">boolean</span> c = s.red; s.red = p.red; p.red = c; <span class="comment">// swap colors</span></span><br><span class="line">                TreeNode&lt;K,V&gt; sr = s.right;</span><br><span class="line">                TreeNode&lt;K,V&gt; pp = p.parent;</span><br><span class="line">                <span class="keyword">if</span> (s == pr) &#123; <span class="comment">// p was s's direct parent</span></span><br><span class="line">                    p.parent = s;</span><br><span class="line">                    s.right = p;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    TreeNode&lt;K,V&gt; sp = s.parent;</span><br><span class="line">                    <span class="keyword">if</span> ((p.parent = sp) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (s == sp.left)</span><br><span class="line">                            sp.left = p;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            sp.right = p;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> ((s.right = pr) != <span class="keyword">null</span>)</span><br><span class="line">                        pr.parent = s;</span><br><span class="line">                &#125;</span><br><span class="line">                p.left = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> ((p.right = sr) != <span class="keyword">null</span>)</span><br><span class="line">                    sr.parent = p;</span><br><span class="line">                <span class="keyword">if</span> ((s.left = pl) != <span class="keyword">null</span>)</span><br><span class="line">                    pl.parent = s;</span><br><span class="line">                <span class="keyword">if</span> ((s.parent = pp) == <span class="keyword">null</span>)</span><br><span class="line">                    root = s;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.left)</span><br><span class="line">                    pp.left = s;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    pp.right = s;</span><br><span class="line">                <span class="keyword">if</span> (sr != <span class="keyword">null</span>)</span><br><span class="line">                    replacement = sr;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    replacement = p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (pl != <span class="keyword">null</span>)</span><br><span class="line">                replacement = pl;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (pr != <span class="keyword">null</span>)</span><br><span class="line">                replacement = pr;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                replacement = p;</span><br><span class="line">            <span class="keyword">if</span> (replacement != p) &#123;</span><br><span class="line">                TreeNode&lt;K,V&gt; pp = replacement.parent = p.parent;</span><br><span class="line">                <span class="keyword">if</span> (pp == <span class="keyword">null</span>)</span><br><span class="line">                    root = replacement;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.left)</span><br><span class="line">                    pp.left = replacement;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    pp.right = replacement;</span><br><span class="line">                p.left = p.right = p.parent = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            TreeNode&lt;K,V&gt; r = p.red ? root : balanceDeletion(root, replacement);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (replacement == p) &#123;  <span class="comment">// detach</span></span><br><span class="line">                TreeNode&lt;K,V&gt; pp = p.parent;</span><br><span class="line">                p.parent = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (pp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (p == pp.left)</span><br><span class="line">                        pp.left = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.right)</span><br><span class="line">                        pp.right = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (movable)</span><br><span class="line">                moveRootToFront(tab, r);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>hash()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h;</span><br><span class="line">    <span class="comment">//为什么不直接用hashCode的值参加计算，而实使用 (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</span></span><br><span class="line">    <span class="comment">//为了避免hashCode在N很小的情况下，如果hashCode的高16位变化很大，而低16位很少变化；即使变化了，也只有低16位和n-1进行与操作，很容易造成冲突</span></span><br><span class="line">        <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//哈希表的长度必定会被设置成为一个2的整数次幂</span></span><br><span class="line"><span class="comment">//如果为13会是16，27会成为32</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line"> n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line"> n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line"> n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line"> n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line"> n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line"> <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_C</span><br><span class="line">APACITY : n + <span class="number">1</span>; &#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><pre><code class="java"> <span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">putTreeVal</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</span></span>
<span class="function"><span class="params">                                       <span class="keyword">int</span> h, K k, V v)</span> </span>{
            Class&lt;?&gt; kc = <span class="keyword">null</span>;
            <span class="keyword">boolean</span> searched = <span class="keyword">false</span>;
            TreeNode&lt;K,V&gt; root = (parent != <span class="keyword">null</span>) ? root() : <span class="keyword">this</span>;
            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) {
                <span class="keyword">int</span> dir, ph; K pk;
                <span class="keyword">if</span> ((ph = p.hash) &gt; h)
                    dir = -<span class="number">1</span>;
                <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)
                    dir = <span class="number">1</span>;
                <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="keyword">null</span> &amp;&amp; k.equals(pk)))
                    <span class="keyword">return</span> p;
                <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;
                          (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||
                         (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>) {
                    <span class="keyword">if</span> (!searched) {
                        TreeNode&lt;K,V&gt; q, ch;
                        searched = <span class="keyword">true</span>;
                        <span class="keyword">if</span> (((ch = p.left) != <span class="keyword">null</span> &amp;&amp;
                             (q = ch.find(h, k, kc)) != <span class="keyword">null</span>) ||
                            ((ch = p.right) != <span class="keyword">null</span> &amp;&amp;
                             (q = ch.find(h, k, kc)) != <span class="keyword">null</span>))
                            <span class="keyword">return</span> q;
                    }
                    dir = tieBreakOrder(k, pk);
                }

                TreeNode&lt;K,V&gt; xp = p;
                <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) {
                    Node&lt;K,V&gt; xpn = xp.next;
                    TreeNode&lt;K,V&gt; x = map.newTreeNode(h, k, v, xpn);
                    <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)
                        xp.left = x;
                    <span class="keyword">else</span>
                        xp.right = x;
                    xp.next = x;
                    x.parent = x.prev = xp;
                    <span class="keyword">if</span> (xpn != <span class="keyword">null</span>)
                        ((TreeNode&lt;K,V&gt;)xpn).prev = x;
                    moveRootToFront(tab, balanceInsertion(root, x));
                    <span class="keyword">return</span> <span class="keyword">null</span>;
                }
            }
        }
&lt;!--￼<span class="number">33</span>--&gt;</code></pre>
</li>
<li><p>有三个HashMap引用的方法</p>
<ul>
<li><pre><code class="java"><span class="comment">//将节点放到链表尾部</span>
<span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>{ <span class="comment">// move node to last</span>
        LinkedHashMap.Entry&lt;K,V&gt; last;
        <span class="keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) {
            LinkedHashMap.Entry&lt;K,V&gt; p =
                (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;
            p.after = <span class="keyword">null</span>;
            <span class="keyword">if</span> (b == <span class="keyword">null</span>)
                head = a;
            <span class="keyword">else</span>
                b.after = a;
            <span class="keyword">if</span> (a != <span class="keyword">null</span>)
                a.before = b;
            <span class="keyword">else</span>
                last = b;
            <span class="keyword">if</span> (last == <span class="keyword">null</span>)
                head = p;
            <span class="keyword">else</span> {
                p.before = last;
                last.after = p;
            }
            tail = p;
            ++modCount;
        }
    }
&lt;!--￼<span class="number">34</span>--&gt;</code></pre>
</li>
<li><pre><code class="java"><span class="comment">//删除头节点，在哈希表插入节点时使用</span>
<span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>{ <span class="comment">// possibly remove eldest</span>
        LinkedHashMap.Entry&lt;K,V&gt; first;
        <span class="keyword">if</span> (evict &amp;&amp; (first = head) != <span class="keyword">null</span> &amp;&amp; removeEldestEntry(first)) {
            K key = first.key;
            removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);
        }
    }
&lt;!--￼<span class="number">35</span>--&gt;</code></pre>
</li>
</ul>
</li>
<li><p>values(),遍历顺序和key一样</p>
<ul>
<li><pre><code class="java">Collection values = map.values()
&lt;!--￼<span class="number">36</span>--&gt;
</code></pre>
</li>
</ul>
</li>
</ul>
<h4 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h4><ul>
<li><p>TreeMap是按照key进行排序的，key必须是由同一个类创建的对象</p>
<ul>
<li><p>自然排序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//key所在的对象实现Compaaeble，实现ToComparable方法</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>定制排序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TreeMap map = new TreeMap(new Comparator()&#123;</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(object o1,object o2)</span></span>&#123;</span><br><span class="line">....</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h4 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h4><h5 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h5><ul>
<li><p>处理配置文件，key和value都是String类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Properties pros = <span class="keyword">new</span> Properties;</span><br><span class="line">String name = pros.getProperty(<span class="string">"name"</span>);</span><br></pre></td></tr></table></figure>





</li>
</ul>
<h4 id="Collections工具类"><a href="#Collections工具类" class="headerlink" title="Collections工具类"></a>Collections工具类</h4><h5 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h5><ul>
<li><p>可以操作Collection和Map的工具类</p>
</li>
<li><p>Collections和Collection的区别</p>
</li>
</ul>
<h5 id="常用方法（都是static方法）"><a href="#常用方法（都是static方法）" class="headerlink" title="常用方法（都是static方法）"></a>常用方法（都是static方法）</h5><h6 id="reverse-list"><a href="#reverse-list" class="headerlink" title="reverse(list)"></a>reverse(list)</h6><ul>
<li><p>反转List中元素的顺序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collections.reverse(list)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h6 id="shuffle-list"><a href="#shuffle-list" class="headerlink" title="shuffle(list)"></a>shuffle(list)</h6><ul>
<li><p>list随机排列，每次都不一样</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collections.shuffle(list)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h6 id="sort-list"><a href="#sort-list" class="headerlink" title="sort(list)"></a>sort(list)</h6><ul>
<li>自然排序</li>
</ul>
<h6 id="sort-list-Comparator"><a href="#sort-list-Comparator" class="headerlink" title="sort(list,Comparator)"></a>sort(list,Comparator)</h6><ul>
<li>定制排序</li>
</ul>
<h6 id="swap-list-i-j"><a href="#swap-list-i-j" class="headerlink" title="swap(list,i,j)"></a>swap(list,i,j)</h6><ul>
<li>交换list中i和j位置的数据</li>
</ul>
<h6 id="max-Collection"><a href="#max-Collection" class="headerlink" title="max(Collection)"></a>max(Collection)</h6><ul>
<li>自然排序最大/小值</li>
</ul>
<h6 id="max-Collection-Comparator"><a href="#max-Collection-Comparator" class="headerlink" title="max(Collection,Comparator)"></a>max(Collection,Comparator)</h6><ul>
<li>定制排序最大/小值</li>
</ul>
<h6 id="frequency-Collection-Object"><a href="#frequency-Collection-Object" class="headerlink" title="frequency(Collection,Object)"></a>frequency(Collection,Object)</h6><ul>
<li>返回集合指定元素的个数</li>
</ul>
<h6 id="copy-list1-list2"><a href="#copy-list1-list2" class="headerlink" title="*copy(list1,list2)"></a>*copy(list1,list2)</h6><ul>
<li><p>错误做法1</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ArrayList list2 = <span class="keyword">new</span> ArrayList();</span><br><span class="line">Collections.copy(list2,list1);</span><br><span class="line"><span class="comment">//抛出异常，list2的长度是0，不合适</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>错误做法2</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ArrayList list2 = <span class="keyword">new</span> ArrayList(list1.size());</span><br><span class="line">Collections.copy(list2,list1);</span><br><span class="line"><span class="comment">//只是造了一个list1.size()的数组（没有存元素），list1.size()表示的是存由元素的数组元素的个数。</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>正确做法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List dest = Arrays.asList(<span class="keyword">new</span> Object[list.size()])</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>list2中的元素复制到list1中</p>
<ul>
<li>多了之后只覆盖前面的list2的个数</li>
</ul>
</li>
</ul>
<h6 id="replaceAll-list-oldVal-newVal"><a href="#replaceAll-list-oldVal-newVal" class="headerlink" title="replaceAll(list,oldVal,newVal)"></a>replaceAll(list,oldVal,newVal)</h6><ul>
<li>newVal替换list中所有的oldVal值</li>
</ul>
<h6 id="线程安全集合"><a href="#线程安全集合" class="headerlink" title="线程安全集合"></a>线程安全集合</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List list1 = Collections.synchronizedList(list);</span><br><span class="line"><span class="comment">//list1就会变成线程安全的</span></span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/111zx/111zx.github.io/2020/03/31/%E9%9B%86%E5%90%88/" data-id="ckbbzdvt0000jt8ub5j9406kz" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-java面试点" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/27/java%E9%9D%A2%E8%AF%95%E7%82%B9/" class="article-date">
  <time datetime="2020-03-27T09:31:58.000Z" itemprop="datePublished">2020-03-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/27/java%E9%9D%A2%E8%AF%95%E7%82%B9/">java面试点</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><ol>
<li>说说JVM内存模型。</li>
<li>线程的程序计数器是干什么用的？</li>
<li>说说堆里面的垃圾回收算法？为什么新生代用复制算法，老年代用标记整理、标记压缩？</li>
<li>了解CMS这个垃圾回收器吗？说说它的工作流程？</li>
<li>CMS在并发标记的时候，用户线程也会不停的产生一些大对象，Remark再次标记的时候可能会花上很多时间，说说你的优化方案？</li>
</ol>
<p>.java - javac -&gt;class - JVM - &gt;各种操作系统的机器码</p>
<p>.class 会通过类装载子系统加载到 运行时数据区 最后由字节码执行引擎来执行</p>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><ol>
<li>tcp time_wait和close_wait区别以及产生原因，过多的话处理方法？ </li>
</ol>
<h2 id="springboot"><a href="#springboot" class="headerlink" title="springboot"></a>springboot</h2><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><ol>
<li><p>数据库的锁</p>
</li>
<li><p>索引方面<br>索引是帮助MySQL高校获取数据的排好序的数据结构<br>索引数据结构<br> 二叉排序树</p>
<pre><code>缺点：若是非递增序列，则变成线性的链表，查询效率低下</code></pre><p> 红黑树</p>
<pre><code>二叉平衡：差距大于2时平衡
    缺点：数据量很大时，树高度也很大，效率很低</code></pre><p> Hash表<br> B-Tree叶节点具有相同的深度，叶结点指针为空</p>
<pre><code>所有索引元素不重复
节点中的数据索引从左到右递增排列</code></pre><p> B+Tree（叶子节点间双向指针）（MySQL索引）</p>
<pre><code>每次从磁盘拿来一个索引 在内存中查找（速度比磁盘io快很多）
MySQL 一个节点16KB
非叶子节点不存储data，只存储索引，叶子节点用指针连接，提高区间访问的性能
非叶子节点不存储data的原因;让一个节点的索引更多，提高查询效率。</code></pre><p> 存储引擎是形容数据表的<br> InnoiDB</p>
<pre><code>索引和数据存储在一起
聚集索引
    数据和索引放在一起
非聚集索引
    数据和索引分开
为什么InnoDB表必须要主键，并且推荐用整型的自增主键？
    没有主键就没有什么作为索引形成索引的B+树结构，如果没有设置索引，MYsql会自动设置一个主键。整型的存储空间更小，更好比较。自增是因为

为什么hash快但是不用hash用B+树
    ：hash只能单点查找，而B+树可以范围查找。</code></pre><p> 联合索引的底层存储结构长什么样子</p>
</li>
</ol>
<pre><code>MyISAM
    索引文件和数据文件是分离的</code></pre><ol start="3">
<li>为啥索引用b+树，比较其他数据结构，他的优点是啥</li>
<li>查询语句走不走索引</li>
<li>sql语句执行慢的可能原因</li>
</ol>
<h2 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h2><ol start="6">
<li>redis基本数据结构 </li>
</ol>
<h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><ol>
<li>三次握手，四次挥手</li>
<li>https概念</li>
</ol>
<p>##java SE<br>3. 数组和arraylist的区别<br>4. Hashmap<br>5. Hashset<br>6. 并发模块：两个关键字<br>7. 接口和抽象类</p>
<h2 id="自增变量"><a href="#自增变量" class="headerlink" title="自增变量"></a>自增变量</h2><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><ol start="11">
<li>进程和线程，为什么需要线程程</li>
<li>保证线程安全的方法。Lock加锁复习，synchronized优化复习</li>
<li>Linux内核，操作系统？C++</li>
<li>Linux查找那个线程使用CPU最大</li>
<li>消息队列原理</li>
</ol>
<h2 id="spring-mvc"><a href="#spring-mvc" class="headerlink" title="spring mvc"></a>spring mvc</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/111zx/111zx.github.io/2020/03/27/java%E9%9D%A2%E8%AF%95%E7%82%B9/" data-id="ckbbzdvst000dt8ube5xyd1ky" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-软件过程管理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/26/%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B%E7%AE%A1%E7%90%86/" class="article-date">
  <time datetime="2020-03-26T04:31:17.000Z" itemprop="datePublished">2020-03-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/26/%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B%E7%AE%A1%E7%90%86/">软件过程管理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<p>title: 软件过程管理<br>date: 2020-03-19 11:10:24<br>tags:</p>
<hr>
<h2 id="项目集成管理"><a href="#项目集成管理" class="headerlink" title="项目集成管理"></a>项目集成管理</h2><h3 id="需求获取"><a href="#需求获取" class="headerlink" title="需求获取"></a>需求获取</h3><h3 id="过程（已经有了用户需求）"><a href="#过程（已经有了用户需求）" class="headerlink" title="过程（已经有了用户需求）"></a>过程（已经有了用户需求）</h3><ol>
<li>制定项目章程<br> sponsor（sign）</li>
<li>指定项目管理计划<br> PM（plan）</li>
<li>指导和管理项目的工作</li>
<li>管理项目的知识</li>
<li>监管和控制项目工作</li>
<li>执行整体的变更控制</li>
<li>关闭项目</li>
</ol>
<p>战略规划：<br>    通过分析组织的优势和劣势，研究商业环境的机会和威胁，预测未来趋势，预测对新产品和服务的需求来确定长远的目标<br>SWOT：<br>    优势，劣势，机会和威胁。</p>
<p>选择项目的方法<br>    缩小项目的范围，没有足够的时间和资源完成所有<br>    1.关注广泛的组织需求<br>        很多人认同这个项目又很高的价值（即使没有理由）<br>    2. 为IT项目分类<br>        …<br>    3. 财务分析<br>        NPV<br>            Net Present Value<br>            time value of time<br>        …<br>    4. 投资回收率 return on investment ROI<br>        (收益-成本)/成本<br>    5. 投资回收期 payback analysis<br>        收回项目投资总资金所需要的时间</p>
<p>加权平均项目评价<br>    标准划分权重；<br>    每个项目对于各个标准进行评分；<br>    加权平均计算</p>
<p>平衡记分卡 implementing a balanced scorecard<br>    increase stock value<br>    Lv1 -&gt;Lv2 -&gt;Lv3 -&gt;Lv4<br>    financial -&gt;customer -&gt;internal -?learning&amp;growth<br>指定项目章程</p>
<p>制定项目管理计划<br>    项目简介<br>    组织方式说明<br>    要做的工作<br>    进度以及预算<br>    参考其他项目计划文件<br>    项目上使用的方法和技术</p>
<p>Project Document</p>
<p>指导和管理项目工作</p>
<p>规划和执行</p>
<p>组织文化和强大的领导能力</p>
<p>利用产品，业务和应用领域的知识<br>    大型项目项目经理必须了解业务相关领域的知识</p>
<p>项目执行工具和技术<br>    专家判断<br>    会议<br>    项目信息管理系统</p>
<p>监管和控制项目工作<br>     baseline ：记录在案的起点，测量或观察，一边用于将来的比较<br>    变更请求<br>    工作绩效报告<br>    change request date：只要发生了变化，需要一个文件来记录改变了什么</p>
<p>结束项目或者阶段<br>    项目产出：<br>        …</p>
<h2 id="项目范围管理"><a href="#项目范围管理" class="headerlink" title="项目范围管理"></a>项目范围管理</h2><p>重点：工作分解结构</p>
<h3 id="什么是项目范围管理"><a href="#什么是项目范围管理" class="headerlink" title="什么是项目范围管理"></a>什么是项目范围管理</h3><pre><code>与项目成功相关的许多因素：
    用户参与
    明确业务目标
    优化的范围
范围：创建项目的产品和用于创建产品的过程之所涉及的所有工作。
deliverable 可交付成果

项目范围管理是确定和控制项目中应包含哪些过程。

六大过程：

    计划项目管理：
        决定项目的范围和需求
    采集需求
    定义范围
    创建WBS：将可交付成果细分为更小，更易管理的组件
    确认范围：正式接受项目可交付成果
    控制范围：在项目整个生命周期中控制对项目的变更


项目团队用专家判断，数据分析和会议来开发宪哥重要的输出：
    范围管理计划
        编制详细的项目说明书
        创建WBS
        维护和批准WBS
        获得已完成项目可交付成果的验收
        控制对项目范围的更改请求
    需求管理计划
        概念： 产品，服务或结果中满足业务所必须的条件或能力
        需求工程是软件工程的一个分支，包含和需求获取，需求分析，需求规格说明，需求验证和需求管理

        收集初级资料有四种方法：
            一对一采访
            focus group
                决定焦点小组的话题和目标
                确定参与者
                准备指南和问题清单
                选择地点
                。。。。。。
            运用团队创造力和决策技巧
                头脑风暴
                德尔菲技术
                。。。
            问卷和调查

            观察，涉及到改进过程的更适合。

            原型和文档分析，有助于澄清项目的边界

            基准话分析法，标杆分析法（和业内最大竞争对手比较）

            需求跟踪矩阵：列出了需求、每个需求的各种属性，以及需求的状态，
            以确保所有的需求都得到了满足
    确认范围
        包括：
            产品范围描述
            产品用户验证标准
            所有可交付成果的详细信息

    WBS 工作分解结构：项目中设计的面向交付的工作分组，定义了项目的整个氛围，是一个基础文档，它为计划和管理项目进度表，成本，资源和变更提供了基础

        分解是创建工作分解的主要技术
            工作包是分解结构的最低技术
                例如：PROJECT-TasK-SubTask-Work Package（工作包，最低的层次）
    NOT EVERY WBS is good

    WBS例子：某公寓建设项目工作分解图</code></pre><img src="/2020/03/26/%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B%E7%AE%A1%E7%90%86/WPS.png" class title="[WBS]">

<img src="/2020/03/26/%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B%E7%AE%A1%E7%90%86/WPS%E6%A1%86%E6%9E%B6.png" class title="[WBS框架]">




<pre><code>    两种WBS 

    开发WBS的方法
        使用指南
        回顾法
        。。。

    WBS scrum 图



    WBS Dictionary
        WBS项目只由一人负责    
        工作单元只能出现再WBS的一个地方


validating验证范围
        验证分为并且最小化分为更改
        包括：对完成项目的可交付成果的正式接受
            通常是由用户检查签字实现的

控制范围
    包括：
        项目范围的变更
    范围控制目标：
        1影响项目变更的因素
        2确保变更按照作为综合变更控制的一部分的程序进行处理
        3当变更发生时管理他们
    差异是指计划和实际表现之间的差异
    减少不完整和变更需求的建议</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/111zx/111zx.github.io/2020/03/26/%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B%E7%AE%A1%E7%90%86/" data-id="ck88at6vi000b14ubbm8z51tk" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-javaWeb项目出现问题整合" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/25/javaWeb%E9%A1%B9%E7%9B%AE%E5%87%BA%E7%8E%B0%E9%97%AE%E9%A2%98%E6%95%B4%E5%90%88/" class="article-date">
  <time datetime="2020-03-25T00:22:36.000Z" itemprop="datePublished">2020-03-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/25/javaWeb%E9%A1%B9%E7%9B%AE%E5%87%BA%E7%8E%B0%E9%97%AE%E9%A2%98%E6%95%B4%E5%90%88/">javaWeb项目出现问题整合</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="中文搜索出现乱码问题"><a href="#中文搜索出现乱码问题" class="headerlink" title="中文搜索出现乱码问题"></a>中文搜索出现乱码问题</h2><p>问题描述：在用户查询操作时，如果时输入英文关键字，查询成功；但是如果输入中文，会在文本框返回一个乱码，并且查询失败。</p>
<p>点击搜索之后显示如下：</p>
<img src="/2020/03/25/javaWeb%E9%A1%B9%E7%9B%AE%E5%87%BA%E7%8E%B0%E9%97%AE%E9%A2%98%E6%95%B4%E5%90%88/%E6%90%9C%E7%B4%A2%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81.png" class title="[中文搜索乱码]">

<p>问题分析：<br> UTF-8为国际编码，GBK为中文编码，Web tomcat7之前的默认编码方式为ISO-8859-1,而tomcat8之后的默认编码为utf-8（本次使用的运行环境时tomcat7，出现了问题）.</p>
<p>问题解决方案：</p>
<p>修改tomacat的编码方式，添加一条UTF-8的编码方式具体操作如下：<br>tomact根目录—&gt;conf—&gt;server.xml 找到：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Connector protocol=<span class="string">"HTTP/1.1"</span></span><br><span class="line">               connectionTimeout=<span class="string">"20000"</span></span><br><span class="line">               redirectPort=<span class="string">"8443"</span> /&gt;</span><br></pre></td></tr></table></figure>
<p>修改为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Connector URIEncoding=<span class="string">"UTF-8"</span> port=<span class="string">"8080"</span> protocol=<span class="string">"HTTP/1.1"</span></span><br><span class="line">               connectionTimeout=<span class="string">"20000"</span></span><br><span class="line">               redirectPort=<span class="string">"8443"</span> /&gt;</span><br></pre></td></tr></table></figure>

<p>修改后可正常进行中文关键字搜索</p>
<p>注意：修改之后需要重新配置一遍tomact，会影响到整个项目的其他部分，一定要做好备份</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/111zx/111zx.github.io/2020/03/25/javaWeb%E9%A1%B9%E7%9B%AE%E5%87%BA%E7%8E%B0%E9%97%AE%E9%A2%98%E6%95%B4%E5%90%88/" data-id="ck88at6vc000614ub2ulw9k0g" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Web案例学习" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/24/Web%E6%A1%88%E4%BE%8B%E5%AD%A6%E4%B9%A0/" class="article-date">
  <time datetime="2020-03-24T05:57:07.000Z" itemprop="datePublished">2020-03-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/24/Web%E6%A1%88%E4%BE%8B%E5%AD%A6%E4%B9%A0/">Web案例学习</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>创建一个数据库 LmonkeyShop</p>
<h2 id="第一步-从用户模块开始"><a href="#第一步-从用户模块开始" class="headerlink" title="第一步 从用户模块开始"></a>第一步 从用户模块开始</h2><pre><code>1. 用户表设计
    用户表lmonkey_user
        ...
    做一个用户的实体（IMONKEY_USER）



1. 用户的增删改查</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/111zx/111zx.github.io/2020/03/24/Web%E6%A1%88%E4%BE%8B%E5%AD%A6%E4%B9%A0/" data-id="ck88at6v9000314ubgl0r7diy" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-系统分析与设计" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/24/%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/" class="article-date">
  <time datetime="2020-03-24T03:02:32.000Z" itemprop="datePublished">2020-03-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/24/%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/">系统分析与设计</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="第三章-信息系统构建模块"><a href="#第三章-信息系统构建模块" class="headerlink" title="第三章 信息系统构建模块"></a>第三章 信息系统构建模块</h2><h4 id="前提："><a href="#前提：" class="headerlink" title="前提："></a>前提：</h4><p>利益相关人：</p>
<ul>
<li>用户和业主是业务人员</li>
<li>设计人员，构建人员是技术人员。</li>
</ul>
<hr>
<h4 id="五种不同的信息系统"><a href="#五种不同的信息系统" class="headerlink" title="五种不同的信息系统"></a>五种不同的信息系统</h4><ul>
<li>交易处理系统：侧重于业务过程</li>
<li>管理信息系统：侧重于存储和展示数据</li>
<li>决策信息系统（DSS）：帮助用户提供原始数据和素材，提供选择的方案（杀毒软件会推荐你删除不安全的文件）。其中会使用到数据仓库。<ul>
<li>数据仓库：在系统构建过程中，有不同的没有联系的数据库（工资信息和学生信息），在需要不同数据库的数据时，可以全部采集到数据仓库里，面对不同的需求，建造不同的视图。ETL技术可以将数据存储在一起</li>
</ul>
</li>
<li>专家系统：直接帮助做出决策</li>
<li>办公自动化系统（OA）：主要是不同位置的人员会有交流，强调信息流。<br>现实的系统会结合各种信息系统来构建</li>
</ul>
<hr>
<h4 id="描述系统的框架"><a href="#描述系统的框架" class="headerlink" title="描述系统的框架"></a>描述系统的框架</h4><h5 id="Zachman-Framework"><a href="#Zachman-Framework" class="headerlink" title="Zachman Framework"></a>Zachman Framework</h5><p>有处理过程，核心数据，对外交互三个核心内容。</p>
<ol>
<li>数据：分为存储（分为临时和持久的）和流动的数据。</li>
<li>加工：一系列的活动组织成特定的流程完成特定的任务。（例如取款活动的步骤）</li>
<li>对外交互：和人的交互：界面；和机器交互：接口。</li>
</ol>
<hr>
<h5 id="从数据，过程，接口和物理位置分析干系人的工作"><a href="#从数据，过程，接口和物理位置分析干系人的工作" class="headerlink" title="从数据，过程，接口和物理位置分析干系人的工作"></a>从数据，过程，接口和物理位置分析干系人的工作</h5><p>对于数据而言：</p>
<ul>
<li>业主：只需要知道信息系统能干什么，关注业务领域知识</li>
<li>用户：最了解数据需求，数据的属性，联系，属性和规则（逻辑数据模型）</li>
<li>设计人员：数据库模式（物理技术模型）<br><em>模型驱动开发（MDA）：分为PSM（平台相关模型，物理模型）PIM（平台无关模型，逻辑模型）</em></li>
<li>构建人员：完成SQL语句</li>
</ul>
<p>对于过程而言：</p>
<ul>
<li>业主：关注去处理什么事情</li>
<li>用户：怎么样处理事情，关注处理的细节</li>
<li>设计人员：在技术上怎么样实现用户的处理细节，输出技术说明规格书</li>
<li>构建人员：根据技术规格书代码实现处理细节（或者原型开发）</li>
</ul>
<p>对于接口而言：</p>
<ul>
<li>业主：谁去用，在什么时候去用，关注人用什么样的方式去交互（语音或者文字）</li>
<li>用户：具体怎么样用<br>设计人员：UI设计</li>
<li>构建人员：把设计人员的界面用代码实现</li>
</ul>
<p>对于物理位置分布：</p>
<ul>
<li>业主：系统部署在什么地方</li>
<li>用户：不同位置的通信（远程传输）如何实现，批处理（发快递），实时处理（）收快递</li>
<li>设计人员：交互需求，多长时间交互一次</li>
<li>构建人员：购买硬件设备并且部署和连接网络系统满足需求。</li>
</ul>
<hr>
<h5 id="各个干系人负责工作总结："><a href="#各个干系人负责工作总结：" class="headerlink" title="各个干系人负责工作总结："></a>各个干系人负责工作总结：</h5><ul>
<li>业主：业务知识，业务功能，物理位置分布状态</li>
<li>用户：数据需求，交互需求，处理需求</li>
<li>设计人员：数据库设计，设计说明书，UI设计</li>
<li>构建人员：数据库代码，程序实现代码，界面</li>
</ul>
<hr>
<h2 id="第三章-信息系统开发过程"><a href="#第三章-信息系统开发过程" class="headerlink" title="第三章 信息系统开发过程"></a>第三章 信息系统开发过程</h2><h4 id="信息系统开发过程要素"><a href="#信息系统开发过程要素" class="headerlink" title="信息系统开发过程要素"></a>信息系统开发过程要素</h4><ul>
<li>流程 ，方法论，方法，工具</li>
</ul>
<h5 id="系统开发过程概述"><a href="#系统开发过程概述" class="headerlink" title="系统开发过程概述"></a>系统开发过程概述</h5><p>不同的角色利用特定的工具完成系统开发中的一些活动，在完成活动可以采用特定的方法和最佳实践（套路，模式）</p>
<hr>
<h4 id="CMM成熟度模型"><a href="#CMM成熟度模型" class="headerlink" title="CMM成熟度模型"></a>CMM成熟度模型</h4><ul>
<li><p>初始级：小作坊式生产，没有固定套路和方法</p>
</li>
<li><p>可重复级：有特定的一些方法支撑</p>
</li>
<li><p>已定义级：严格定义规则，有严格的方法论</p>
</li>
<li><p>已管理级：对将来产出的目标有一个度量，在开发前能计算出质量</p>
</li>
<li><p>优化级：在开发过程中可以根据项目难度自动进行优化</p>
<p>初始级-&gt;优化级：风险越来越小，竞争力越来越强</p>
</li>
</ul>
<hr>
<h4 id="系统生存周期"><a href="#系统生存周期" class="headerlink" title="系统生存周期"></a>系统生存周期</h4><p>两个阶段：系统开发和系统维护。可细分为开发，维护，升级，报废。</p>
<hr>
<h4 id="系统开发方法论"><a href="#系统开发方法论" class="headerlink" title="系统开发方法论"></a>系统开发方法论</h4><p>已经定义好的具有活动，方法，最佳实践，可交付成果和自动化工具的精确和正式的系统开发方法</p>
<hr>
<h4 id="系统开发的原则"><a href="#系统开发的原则" class="headerlink" title="系统开发的原则"></a>系统开发的原则</h4><ul>
<li>以人为本：让用户业主尽量参与，可以减少风险，保证问题理解正确</li>
<li>有理有据：要有标准解决问题的步骤，提高开发效率</li>
<li>分步实施：每个阶段之间会有重叠关系，问题分析，需求分析会重叠，并发</li>
<li>建立标准：文档，质量，工具，信息开发技术</li>
<li>最优决策：成本效益分析：平衡权益和风险风险管理</li>
<li>悬崖勒马：不恰当时停下来，每一步进行评估，不合格即不恰当</li>
<li>分而治之：简化问题，每一步设定标准</li>
<li>高瞻远瞩：系统能量不断增加，只有在一开始设计好才能让代价付出最小</li>
</ul>
<p><em>系统熵：修改系统付出的代价，越小越好。</em></p>
<hr>
<h4 id="系统开发方法论-1"><a href="#系统开发方法论-1" class="headerlink" title="系统开发方法论"></a>系统开发方法论</h4><h5 id="促使开发软件的原因"><a href="#促使开发软件的原因" class="headerlink" title="促使开发软件的原因"></a>促使开发软件的原因</h5><p>业务中遇到问题；有机会改正业务效率；规章制度发生变化</p>
<h5 id="PIECES问题解决框架"><a href="#PIECES问题解决框架" class="headerlink" title="PIECES问题解决框架"></a>PIECES问题解决框架</h5><ul>
<li>性能</li>
<li>信息</li>
<li>经济性</li>
<li>可控制程度或安全</li>
<li>效率</li>
<li>服务质量</li>
</ul>
<h5 id="FAST（Framework-for-the-Application-of-Systems-Techniques）"><a href="#FAST（Framework-for-the-Application-of-Systems-Techniques）" class="headerlink" title="FAST（Framework for the Application of Systems Techniques）"></a>FAST（Framework for the Application of Systems Techniques）</h5><p><strong>不是指快速开发一个系统或者只使用原型方法</strong></p>
<h6 id="规定了开发过程的7个阶段"><a href="#规定了开发过程的7个阶段" class="headerlink" title="规定了开发过程的7个阶段"></a>规定了开发过程的7个阶段</h6><ul>
<li>初始调查研究：核心要确定项目的范围</li>
<li>问题分析：要解决的问题是什么</li>
<li>需求分析：要解决问题需要达到什么目标，数据，加工，接口</li>
<li>决策分析：选方案，技术可行性，操作可行性，经济可行性，<br>设计：业务需求转换为软件需求，系统体系结构（包括各个业务的功能实现）</li>
<li>构件：开发出来各个模块并测试（采购的话要学习用户手册）</li>
<li>实现：在真实的环境中部署软件，在进行用户可接触测试</li>
<li>运营和维护：维护，修改bug</li>
</ul>
<h5 id="跨生命周期活动（重叠或者跨整个生命周期进行）"><a href="#跨生命周期活动（重叠或者跨整个生命周期进行）" class="headerlink" title="跨生命周期活动（重叠或者跨整个生命周期进行）"></a>跨生命周期活动（重叠或者跨整个生命周期进行）</h5><p>事实调查：是否能在实际环境中进行<br>文档和汇报：要有交付成果<br>可行性分析<br>过程管理</p>
<hr>
<h4 id="知识库"><a href="#知识库" class="headerlink" title="知识库"></a>知识库</h4><p>需要共享的资料，工具，说明书。</p>
<hr>
<h2 id="第四章-项目管理"><a href="#第四章-项目管理" class="headerlink" title="第四章 项目管理"></a>第四章 项目管理</h2><h3 id="什么是项目管理？"><a href="#什么是项目管理？" class="headerlink" title="什么是项目管理？"></a>什么是项目管理？</h3><p>项目：为了完成特定的目标将一系列相互关联的活动组织起来</p>
<p>​    活动特点：每个活动的特点是唯一的；具有复杂性</p>
<p>​    活动受限：预算，时间，特定要求</p>
<p>项目管理：人力，预算，控制，范围，计划，指挥</p>
<h3 id="项目管理和过程管理的区别"><a href="#项目管理和过程管理的区别" class="headerlink" title="项目管理和过程管理的区别"></a>项目管理和过程管理的区别</h3><ul>
<li>项目管理：目标是项目中用到的资源</li>
<li>过程管理：目标是开发的系统</li>
</ul>
<h3 id="项目管理的因素"><a href="#项目管理的因素" class="headerlink" title="项目管理的因素"></a>项目管理的因素</h3><ul>
<li>客户接受：需求满足</li>
<li>成本合理</li>
<li>及时交付</li>
<li>平稳过渡：要对用户的适应性加以考虑，不要变化太大</li>
</ul>
<h3 id="项目失败的原因"><a href="#项目失败的原因" class="headerlink" title="项目失败的原因"></a>项目失败的原因</h3><ul>
<li>改变了项目的需求</li>
<li>需求没有满足</li>
<li>预算，时间和人员出了问题，在开发商偷工减料</li>
<li>对项目的期望随着时间改变，最后导致超出预算和时间</li>
<li>预算和时间表没有慎重分析</li>
<li>没有采用科学方法估计项目指标</li>
<li>开始出现的问题没有及时解决，到后期解决代价变大</li>
<li>不一定人越多越好</li>
<li>责任分配不明显</li>
</ul>
<h3 id="好的管理人员需要的资质"><a href="#好的管理人员需要的资质" class="headerlink" title="好的管理人员需要的资质"></a>好的管理人员需要的资质</h3><ul>
<li>业务认知和理解能力<ul>
<li>例如：开发一个业务系统，卖给多家需要此业务的卖家，需要充分考虑业务前景</li>
</ul>
</li>
<li>始终与业主和用户合作</li>
<li>对质量能够做出承诺</li>
<li>主动性</li>
<li>获取信息的能力</li>
<li>分析能力</li>
<li>理性思维</li>
<li>对人际关心</li>
<li>对结构的预期能力</li>
<li>鼓励和团结团队人员</li>
<li>抗压能力</li>
<li>诚信</li>
<li>自信不自负</li>
<li>有效的交流</li>
<li>对项目进展的控制能力</li>
<li>有原则的灵活性</li>
</ul>
<h3 id="项目管理方法"><a href="#项目管理方法" class="headerlink" title="项目管理方法"></a>项目管理方法</h3><ul>
<li>确定项目的边界</li>
<li>认定需要完成的任务</li>
<li>评估所需的资源</li>
<li>任务进度安排</li>
<li>确保人员理解角色和职责</li>
<li>只会项目组成员的活动</li>
<li>控制项目开发过程</li>
<li>总结经验和教训</li>
</ul>
<h3 id="管理项目的技术"><a href="#管理项目的技术" class="headerlink" title="管理项目的技术"></a>管理项目的技术</h3><h4 id="1-PERT-chart"><a href="#1-PERT-chart" class="headerlink" title="1. PERT chart"></a>1. PERT chart</h4><ul>
<li>PERT图是一种图形化的网络模型，它描述了项目的任务以及这些任务之间的关系。PERT是为了在计划项目任务之前明确项目任务之间的<strong>相互依赖</strong>而开发的。</li>
</ul>
<h4 id="2-Gantt-chart"><a href="#2-Gantt-chart" class="headerlink" title="2. Gantt chart"></a>2. Gantt chart</h4><ul>
<li><p>甘特图是一个简单的水平条形图，描述了历程上的项目任务。每个条表示一个命名的项目任务。左侧列垂直列出了这些任务。</p>
<p>横轴是历程时间轴。甘特图提供了清晰地显示<strong>重叠任务</strong>的优势</p>
</li>
</ul>
<h3 id="项目管理生命周期"><a href="#项目管理生命周期" class="headerlink" title="项目管理生命周期"></a>项目管理生命周期</h3><h4 id="1-协商范围"><a href="#1-协商范围" class="headerlink" title="1. 协商范围"></a>1. 协商范围</h4><ul>
<li><p>范围定义了项目的边界——业务的哪些部分需要研究、分析、设计、构造、实现和最终改进?</p>
</li>
<li><p>五个基本问题的答案会影响项目范围的谈判:</p>
<ul>
<li><p>产品——你想要什么?</p>
</li>
<li><p>质量多好你想要吗?</p>
</li>
<li><p>时间——当你想要它吗?</p>
</li>
<li><p>成本——你愿意支付多少钱?</p>
</li>
<li><p>资源——你愿意或者能够带来什么资源表吗?</p>
</li>
</ul>
</li>
</ul>
<h4 id="2-确定任务"><a href="#2-确定任务" class="headerlink" title="2. 确定任务"></a>2. 确定任务</h4><ul>
<li>工作分解结构(WBS)是将项目分解为阶段、活动和任务的层次结构</li>
<li>里程碑事件,表示完成或完成的主要可交付成果(可向下一阶段或活动交付的结果)一个项目。</li>
</ul>
<h4 id="3-估计任务持续时间"><a href="#3-估计任务持续时间" class="headerlink" title="3. 估计任务持续时间"></a>3. 估计任务持续时间</h4><ul>
<li><p>乐观的持续期：估计完成任务所需的最少时间。我们称之为乐观持续时间(OD)</p>
</li>
<li><p>悲观的持续期：估计执行任务所需的最大时间量。我们将其称为悲观持续时间(PD)</p>
</li>
<li><p>期望的持续期：估计执行任务所需的预期持续时间(ED)</p>
</li>
<li><p>计算最可能的持续时间(D)(最有希望的持续期)如下:</p>
<p>D =(1×OD) +(4×ED) +(1×PD) / 6</p>
</li>
</ul>
<h4 id="4-指定任务之间的依赖关系"><a href="#4-指定任务之间的依赖关系" class="headerlink" title="4. 指定任务之间的依赖关系"></a>4. 指定任务之间的依赖关系</h4><ul>
<li><p>FS——完成一个任务的触发另一个任务的开始。</p>
</li>
<li><p>SS——开始一个任务触发另一个任务的开始。</p>
</li>
<li><p>FF——两个任务必须在同一时间完成。</p>
</li>
<li><p>SF——开始一个任务——另一个任务的完成。</p>
</li>
<li><p>调度策略</p>
<ul>
<li>正向调度：从开始时间计算项目最早完成时间</li>
<li>反向调度：从截止时间算最晚开始时间</li>
</ul>
</li>
</ul>
<h4 id="5-资源分配"><a href="#5-资源分配" class="headerlink" title="5. 资源分配"></a>5. 资源分配</h4><ul>
<li>资源种类<ul>
<li>人力资源</li>
<li>服务</li>
<li>设备</li>
<li>原材料</li>
<li>资金</li>
</ul>
</li>
<li>资源使用超出时的调平策略<ul>
<li>任务延迟</li>
<li>任务分解（并行改串行）</li>
</ul>
</li>
<li>关键路径<ul>
<li>关键路径一般不要延迟，会延误工期</li>
</ul>
</li>
<li>松弛时间</li>
</ul>
<h4 id="6-团队管理"><a href="#6-团队管理" class="headerlink" title="6. 团队管理"></a>6. 团队管理</h4><ul>
<li><p>监督资源</p>
<ul>
<li>最后期限</li>
<li>一分钟经理</li>
</ul>
</li>
<li><p>项目领导的10个提示</p>
<ul>
<li><p>言行一致的</p>
</li>
<li><p>提供支持</p>
</li>
<li><p>别下你无法遵守的承诺</p>
</li>
<li><p>在公共场合表扬,私下批评</p>
</li>
<li><p>培养员工士气</p>
</li>
<li><p>——设定一个现实的最后期限</p>
</li>
<li><p>设定可感知的目标</p>
</li>
<li><p>多引导员工</p>
</li>
<li><p>不要仅仅依赖(状态报告)</p>
</li>
<li><p>鼓励良好的团队精神</p>
</li>
</ul>
</li>
</ul>
<h4 id="7-监管和控制过程"><a href="#7-监管和控制过程" class="headerlink" title="7. *监管和控制过程"></a>7. *监管和控制过程</h4><ul>
<li><p>进展报告</p>
</li>
<li><p>变更管理</p>
</li>
<li><p>预期管理</p>
<ul>
<li><p>预期管理矩阵</p>
<table>
<thead>
<tr>
<th>优先级    衡量指标</th>
<th>Max or Min</th>
<th>Constrain</th>
<th>Accept</th>
</tr>
</thead>
<tbody><tr>
<td>cost</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>schedule</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>scope or quality</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p>进度调整-<strong>关键路径分析</strong></p>
<ul>
<li>选择最长的一条路作为关键路径</li>
<li>算出非关键任务的延迟时间</li>
</ul>
</li>
</ul>
<h4 id="8-评估项目结果和经验"><a href="#8-评估项目结果和经验" class="headerlink" title="8. 评估项目结果和经验"></a>8. 评估项目结果和经验</h4><hr>
<h2 id="第五章-系统分析阶段"><a href="#第五章-系统分析阶段" class="headerlink" title="第五章 系统分析阶段"></a>第五章 系统分析阶段</h2><p>业务领域由功能划分成不同的的业务模块，再划分成软件模块，最后继承成软件系统</p>
<p>每一阶段的主要工作，业务成果，参与者</p>
<p>一阶段：初始的调查研究<br>    目标：找问题<br>    输出：列出问题<br>    参与：业主</p>
<p>二阶段：问题分析（由症状分析病因）<br>    目标：现有系统的分析（有可能是业务系统，也有可能是技术系统）<br>    输出：确定需要达到什么样的目标<br>    需要业主和用户的参与</p>
<p>三阶段：需求分析<br>    逻辑系统模型-业务<br>        what<br>    物理系统模型-技术<br>        how<br>    目标：确定系统需求<br>    输出：业务需求陈述<br>        功能性需求和非功能性需求<br>    参与：用户，系统分析员</p>
<p>四阶段：决策分析<br>    目标：怎么去选择一个最好的方案（可行性分析）<br>        技术可行性（效率与是非会用），操作可行性（是否可以满足所有需求），经济可行性（成本效益），进度可行性（是否在规定事件可做完）<br>        权重计算表<br>    输出：方案建议书<br>    参与：分析与系统设计师<br>目标：做一个信息系统</p>
<p>系统分析方法：<br>    1. 模型驱动的分析方法<br>    2. 加速分析方法 </p>
<p>模型驱动：强调给系统建模<br>    结构化分析：注重业务处理过程，重点强调交互过程<br>        采用DFD（数据流图）描述结构化分析的业务逻辑<br>    信息工程：以数据为核心<br>        采用ERDs(实体联系图)<br>    面向对象分析：以对象为中心<br>        采用UML图（和类图的区别）<br>快速分析：<br>    发现原型方法：<br>        给出一个提供用户修改的原型框架（更多的是一种向用户展示的作用）</p>
<p>敏捷开发方法：<br>    在实际开发方法没有固定的体系，在不同的阶段根据需要用不同的方法</p>
<h2 id="需求获取"><a href="#需求获取" class="headerlink" title="需求获取"></a>需求获取</h2><pre><code>需求发现：针对目标系统的发现
问题分析：分析发现问题分析的原因（因果分析方法）
系统需求：
    功能性需求（取款 转账）
        能干什么（v.+n.）
    非功能性需求（网上银行自动办公举例）
        P性能 
            吞吐率
            响应时间（客户端发起请求到得到服务器的请求回应）
        I信息 
            内容 时效性 精确性 格式
        E经济
            减少开支或增加收入 
        C控制
            安全性
        E效率
            以最低的成本输出较好的成果
        S服务
            用户给出的反馈



    不明确的需求
    错误的需求的结果：
        开销大
        用户不满意
        开发者声誉变坏

    正确需求的特点
        一致的
        完整的
        可行的
        所需的
        准确的
        可追踪的
        可验证的    

    需求发现的过程：
        发现问题和分析
        需求发现
            fact-finding 七种方法
        需求验证 validation
            有可能出现各种错误
        需求管理
            如果有问题，则更改

    SOP 标准操作规程

    抽样调查（数量太多，不能普查）
    simple size = 0.25（x/x）*2

    观察
        1. 观察六要素
        2. 征求领导人同意
        3. 提前预约，不要突然袭击
        4. 保持低调
        5. 及时记录和观察
        6. 别讨人嫌
        7. 抓重点
        8. 不要先入为主做假设

    调查问卷：
        根据目的设计不同的调查问卷
            multiple-choice questions：从    多个选项中选一个，不是选多个
            rating question

            ranking question

    面谈：
        有结构面谈
            HR面试，有问题清单
        无结构面谈
            技术面谈自我发挥

    Ishikawa diagram雨果图

    JRP
        准时
        强调关键
        解决冲突
        需要休息
        团队形成一致意见
        形式：
            brainstorming，头脑风暴。
        优势：
            用户和管理员都能参与，可以更好地实现需求分析

    Fact-Finding 
    Use case
        如何使用和使用的场景

    问题发现得越早，越容易解决
    需求时需要去发现的，是需要采用社和的手段去实现的
    系统分析员要掌握与人交流的技能和工具</code></pre><h2 id="需求实体"><a href="#需求实体" class="headerlink" title="需求实体"></a>需求实体</h2><pre><code>实体的名字 数据分为流动的和静态的
动词 功能 架构和行为
逻辑模型是为了消除系统分析人员和架构人员对于技术的偏见

业务分析通过分析的到PIM（平台无关模型，是逻辑模型）再设计得到PSM（平台相关模型）最后实现得到系统模型

由PIM可以确定出多个PSM（一种逻辑多种平台实现）技术方案

数据建模：核心是了解数据架构。

现代系统的空间相比时间更加廉价，利用非关系型数据库牺牲空间节省时间。

ERD Entity Relationship Diagram 

数据建模：通过ER图描述，实体属性和联系等元素
数据库设计：实体：表；属性：字段；联系：外键

关键字：
组合关键字
候选关键字
主关键字
备用关键字
子集准则（按民族划分）

联系：
基数：针对一个实体的一个实例，和他有关系的实例可以有多少个。1...N  0...N
度：在一个联系中有多少个实体参与进来

泛化
超类型实体：
子类型实体：与超类型实体的主键是一样的，依赖以超类型实体而存在

关系型数据库的数据建模：建立实体之间的联系

    上下文数据模型

    构造数据模型的步骤
        1.构造上下文模型（只有实体和联系没有属性）
        2.基于关键字的数据模型
        3.添加非关键字，构成全属性数据模型
        4.进行规范化，减少数据冗余，数据需要灵活性

    1NF：消除多值属性
    2NF：消除部分依赖
    3NF：消除传递依赖

    反规范化：
        数据分区，分表以加快查询的效率</code></pre><h2 id="可行性"><a href="#可行性" class="headerlink" title="可行性"></a>可行性</h2><pre><code>操作，技术，时间，文化，合法，经济可行性。
操作可行性：
    问题是否值得去研究
时间可行性:deadline
经济可行性：

成本效益分析方法
    固定成本：软件的租借费用，按比例分摊的工资
    可变成本：计算机消费（促销时期和平时不一样）
有形收益：降低成本，增加收入（可以用金钱衡量）
无形收益：团队，经验，文化。

可行性分析：偿还分析，投资回报率，净现值
    货币时间价值：货币会随着时间贬值
偿还分析：在自然增长的收益赶上自然增长的持续付出的成本之前的一段时间，为偿还期
净现值：PV = 1 / （1 + i）^n
    n年以后的价值
投资回报率
    全生存期收益率：（全生存周期的收入-成本）/成本
Candidate Systems Matrix
Feasibility Analysis Matrix

The System Proposal
    主要元素
        主要关注的元素
    次要元素
        支撑主要元素的部分

    报告的风格    
        事实风格
            按照逻辑关系分析（按照分析给结论）
        管理风格
            先给出不同方案的介绍和最佳方案的结果（直接给结论）
        消除废话
        明确主题</code></pre><h2 id="系统设计过程"><a href="#系统设计过程" class="headerlink" title="系统设计过程"></a>系统设计过程</h2><pre><code>应用架构设计：和系统的应用环境结合在一起
    、</code></pre><p>##数据库设计</p>
<p>###存储方式<br>1.文件存储<br>2.关系型数据库<br>3.非关系型数据库</p>
<p>备份（2-3份）要有纸质备份</p>
<p>要有回退功能</p>
<p>####数据库架构</p>
<p>DBMS：设计一个数据库引擎</p>
<p>数据库设计目标：<br>1.目标：<br>    提出最有效的增删改查功能<br>    安全的，可信赖的<br>    拓展性良好<br>2.由逻辑数据模型转换到物理数据模型：<br>    要确定每个属性的字段类型<br>        定长字符串，面长字符串等<br>    每一个矩形表示一张表，有标准的命名方式<br>数据库设计过程：<br>1.复习逻辑设计模型<br>2.每个实体建一个表<br>3.每个属性创建一个字段<br>4.主键和候选键创建索引<br>5.构造子集判据构造索引<br>6.设计外键<br>7.设计每个字段的约束<br>8.父表和子表<br>9.检查数据库的完整性<br>    关键字完整性<br>    定义域完整性<br>    参照完整性*</p>
<p>数据库分析：<br>集中式存储<br>水平分布按列<br>垂直分布按行<br>复制分布</p>
<p>核心：确定以什么样的方式来存储</p>
<h2 id="第七章-数据建模和分析"><a href="#第七章-数据建模和分析" class="headerlink" title="第七章 数据建模和分析"></a>第七章 数据建模和分析</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul>
<li>逻辑建模（ER图和关系模式）</li>
<li>数据建模（关系数据库设计）</li>
</ul>
<h3 id="系统模型介绍"><a href="#系统模型介绍" class="headerlink" title="系统模型介绍"></a>系统模型介绍</h3><h4 id="逻辑模型"><a href="#逻辑模型" class="headerlink" title="逻辑模型"></a>逻辑模型</h4><ul>
<li>定义：逻辑模型显示系统是什么或做什么。它们是独立于实现的;也就是说，它们描述了独立于任何技术实现的系统。因此，逻辑模型说明了系统的本质</li>
</ul>
<h5 id="使用逻辑模型的原因"><a href="#使用逻辑模型的原因" class="headerlink" title="使用逻辑模型的原因"></a>使用逻辑模型的原因</h5><ul>
<li>可以让系统脱离现实的技术实现细节，专注系统的业务需求，减少需求确实的风险</li>
<li>由于脱离了技术可以和客户轻松交流</li>
</ul>
<h4 id="物理模型"><a href="#物理模型" class="headerlink" title="物理模型"></a>物理模型</h4><ul>
<li>定义：物理模型不仅显示系统是什么或做什么，而且还显示系统在物理上和技术上是如何实现的。</li>
<li>它们依赖于实现，因为它们反映了技术选择和这些技术选择的局限性</li>
</ul>
<h4 id="数据建模"><a href="#数据建模" class="headerlink" title="数据建模"></a>数据建模</h4><ul>
<li>数据建模(数据建模)是一种技术来组织和记录系统的数据。</li>
<li>实际模型通常称为实体关系图(ERD)，因为它根据数据所描述的实体和关系来描述数据。</li>
<li>实体<ul>
<li>强实体：圆角矩形</li>
<li>弱实体：必须要以来一个其他的实体，主键和以来的实体一样。圆角矩形+一个框</li>
<li>关联实体：帮助我们解决非确定性关系（实体和实体之间的多对多联系）。菱形</li>
</ul>
</li>
</ul>
<h3 id="数据建模的系统概念"><a href="#数据建模的系统概念" class="headerlink" title="数据建模的系统概念"></a>数据建模的系统概念</h3><h4 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h4><h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><ul>
<li>一个实体(实体)是一类人,地方,对象,事件,或我们需要捕获和存储数据的概念。</li>
<li>圆角矩形表示</li>
</ul>
<h5 id="实体的实例"><a href="#实体的实例" class="headerlink" title="实体的实例"></a>实体的实例</h5><ul>
<li>对应数据库的表的一行记录</li>
</ul>
<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><h5 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h5><ul>
<li>用来描述实体的特征</li>
</ul>
<h5 id="复合属性"><a href="#复合属性" class="headerlink" title="复合属性"></a>复合属性</h5><ul>
<li>多个源自属性组合起来表示一种属性</li>
</ul>
<h5 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h5><ul>
<li>数据类型：什么类型的数据可以存储在属性里</li>
<li>定义域：属性值是否合理和游戏哎</li>
<li>缺省值：用户没有指定时用一个默认值</li>
</ul>
<h5 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h5><ul>
<li>关键字</li>
<li>组合关键字</li>
<li>候选关键字</li>
<li>主关键字</li>
<li>备用关键字</li>
<li>子集准则</li>
</ul>
<h4 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h4><h5 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h5><ul>
<li>一个或者多个实体之间的关联</li>
<li>联系之间是有方向的</li>
</ul>
<h5 id="基数"><a href="#基数" class="headerlink" title="基数"></a>基数</h5><ul>
<li>一个实体的实例能够最少和最多对应另外一个实体的个数</li>
<li>离得近的联系基数时别人一个对应自己多少个</li>
</ul>
<h4 id="递归联系"><a href="#递归联系" class="headerlink" title="递归联系"></a>递归联系</h4><ul>
<li>递归关系(递归联系)(度= 1)是一种关系,相同实体不同实例之间存在的联系。</li>
</ul>
<h5 id="关联实体"><a href="#关联实体" class="headerlink" title="关联实体"></a>关联实体</h5><ul>
<li>主键是由联系起来的所有属性的主键构成。</li>
<li>由几个实体联系起来，度(degree)就是几。</li>
</ul>
<h4 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h4><ul>
<li>依赖于别人的主键</li>
</ul>
<h5 id="非限定性联系"><a href="#非限定性联系" class="headerlink" title="非限定性联系"></a>非限定性联系</h5><ul>
<li>属性之间没有任何关系</li>
</ul>
<h5 id="限定性联系"><a href="#限定性联系" class="headerlink" title="限定性联系"></a>限定性联系</h5><ul>
<li>属性之间有关系</li>
</ul>
<h4 id="非特定性联系"><a href="#非特定性联系" class="headerlink" title="非特定性联系"></a>非特定性联系</h4><ul>
<li><p>多对多联系</p>
</li>
<li><p>一个实体的实例不能唯一确定另外一个实体的实例</p>
</li>
<li><p>引入关联实体解决不确定性</p>
</li>
</ul>
<h4 id="泛化"><a href="#泛化" class="headerlink" title="泛化"></a>泛化</h4><ul>
<li>泛化：多个实体具有相同的特征，可以构造出一个超类型实体，对比面向对象</li>
<li>超类型实体：对比面向对象父类</li>
<li>子类型实体：对比面向对象子类</li>
</ul>
<h3 id="建立逻辑数据模型的过程"><a href="#建立逻辑数据模型的过程" class="headerlink" title="建立逻辑数据模型的过程"></a>建立逻辑数据模型的过程</h3><ul>
<li><strong>上下文数据模型</strong>：只包括实体和联系，没有属性。</li>
</ul>
<h4 id="数据建模过程"><a href="#数据建模过程" class="headerlink" title="数据建模过程"></a>数据建模过程</h4><ol>
<li>构造上下文数据模型</li>
<li>构造基于关键字的数据模型（为每一个实体确定候选关键字）</li>
<li>为每一个实体识别非关键字属性</li>
<li>规范化减少冗余（大多数是三范式）</li>
</ol>
<h3 id="怎么样构建数据模型"><a href="#怎么样构建数据模型" class="headerlink" title="怎么样构建数据模型"></a>怎么样构建数据模型</h3><h4 id="识别实体"><a href="#识别实体" class="headerlink" title="识别实体"></a>识别实体</h4><ul>
<li>从用例中文本的描述确定那些是实体，那些是联系。</li>
<li>在与系统所有者和用户的访谈或JRP会议中，注意他们讨论中的关键词。</li>
<li>从表格，文件或者报告中得到</li>
<li>从已有的数据库中时别实体</li>
</ul>
<h3 id="分析数据模型"><a href="#分析数据模型" class="headerlink" title="分析数据模型"></a>分析数据模型</h3><ol>
<li>列出实体和相关描述</li>
<li>上下文数据模型（实体和联系）</li>
<li>确定主关键字和候选关键字，关联属性等。</li>
<li>泛化<ul>
<li>父类和子类</li>
</ul>
</li>
<li>加入非标志性属性</li>
</ol>
<h3 id="优化数据模型"><a href="#优化数据模型" class="headerlink" title="优化数据模型"></a>优化数据模型</h3><h4 id="好的数据模型"><a href="#好的数据模型" class="headerlink" title="好的数据模型"></a>好的数据模型</h4><ol>
<li>简单</li>
<li>少冗余</li>
<li>延展性和灵活性高</li>
</ol>
<h4 id="规范化"><a href="#规范化" class="headerlink" title="规范化"></a>规范化</h4><ul>
<li>牺牲时间换空间</li>
</ul>
<h5 id="1-NF"><a href="#1-NF" class="headerlink" title="1 NF"></a>1 NF</h5><ul>
<li>消除多值依赖</li>
<li>例如：<ul>
<li>{身份证号，姓名，联系方式}</li>
<li>属性”联系方式里面包含了电话和电子邮箱”，发生了多值依赖，分解成两个属性即可</li>
<li>{身份证号，姓名,电话,电子邮箱}</li>
</ul>
</li>
</ul>
<h5 id="2-NF"><a href="#2-NF" class="headerlink" title="2 NF"></a>2 NF</h5><ul>
<li>1 NF +消除部分依赖</li>
<li>例如：<ul>
<li>{(a,b),c,d,e}</li>
<li>其中(a,b)是主键，但是b可以唯一确定d，就发生了部份依赖，可以分表解决</li>
<li>{(a,b),c,e}  {b,d}</li>
</ul>
</li>
</ul>
<h5 id="3-NF"><a href="#3-NF" class="headerlink" title="3 NF"></a>3 NF</h5><ul>
<li>2 NF +消除传递依赖<ul>
<li>例如：<ul>
<li>{(a,b),c,d,e}</li>
<li>其中(a,b)是主键，但是c可以唯一确定d，就发生了传递依赖，可以分表解决</li>
<li>{(a,b),c,e}  {c,d}</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="反规范化"><a href="#反规范化" class="headerlink" title="反规范化"></a>反规范化</h4><ul>
<li>牺牲空间换时间</li>
</ul>
<h2 id="第十一章-输入设计原型化"><a href="#第十一章-输入设计原型化" class="headerlink" title="第十一章 输入设计原型化"></a>第十一章 输入设计原型化</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><ul>
<li>正确的输入，正确的输出</li>
</ul>
<h3 id="输入设计包含两方面"><a href="#输入设计包含两方面" class="headerlink" title="输入设计包含两方面"></a>输入设计包含两方面</h3><ul>
<li><p>数据的捕获，输入和处理</p>
<ul>
<li><p>数据捕获是对新数据的识别和获取</p>
<p>(源头)。源文档是用来记录商业交易形式描述这些交易的数据</p>
</li>
<li><p>数据输入是将源数据或文档(以上)转换成计算机可读格式的过程</p>
</li>
<li><p>数据处理是在数据从机器可读的形式输入之后对其进行的所有处理。</p>
<ol>
<li>批处理：存在缓存区，满足一定要求后一起处理</li>
<li>在线处理：输入信息立即处理</li>
<li>远程处理：通过互联网终端进行远程处理</li>
</ol>
</li>
</ul>
</li>
<li><p>捕获并输入数据使用的方法和技术</p>
<ul>
<li>键盘</li>
<li>鼠标</li>
<li>触摸屏</li>
<li>销售点终端</li>
<li>声音和讲话</li>
<li>自动数据采集</li>
</ul>
</li>
<li><p>自动识别条形码</p>
</li>
</ul>
<h3 id="输入设计的指导"><a href="#输入设计的指导" class="headerlink" title="输入设计的指导"></a>输入设计的指导</h3><ul>
<li><p>只捕获可变数据。</p>
</li>
<li><p>不要捕获可以在计算机中计算出来的数据。</p>
</li>
<li><p>为适当的属性使用业务编码。</p>
</li>
</ul>
<h3 id="原文档的设计规则"><a href="#原文档的设计规则" class="headerlink" title="原文档的设计规则"></a>原文档的设计规则</h3><ul>
<li>包括填写表格的说明。</li>
<li>尽量减少手写的数量。</li>
<li>要输入的数据(键控)应该进行排序，这样它就可以像一本书一样阅读，也就是说，<strong>从上到下，从左到右</strong>。</li>
<li>尽可能使用常规（和人们日常思维习惯相同）的设计<ul>
<li>更利于用户的操作，符合人的习惯</li>
</ul>
</li>
</ul>
<h3 id="输入的内部控制"><a href="#输入的内部控制" class="headerlink" title="输入的内部控制"></a>输入的内部控制</h3><ul>
<li>应该监视每个输入，以及输入的总数(以最小化丢失事务的风险)<ul>
<li>对批处理<ul>
<li>使用批控制记录单</li>
<li>使用一个对一个核对后处理细节报告（目前在哪，下一步到哪）</li>
</ul>
</li>
<li>在线系统<ul>
<li>记录每一笔交易的发生（找出哪一步出错）</li>
<li>为每笔交易分配一个确认号码(在网上交易系统中很常见)</li>
</ul>
</li>
</ul>
</li>
<li>验证所有数据<ul>
<li>存在检查,确定所有必需字段的输入实际上已经进入了。</li>
<li>数据类型检查,确保正确的类型的数据输入。身份证不能输入字母</li>
<li>域检查,确定每个字段属于合法的输入数据集或为该字段定义的值的范围。身份证的月份</li>
<li>关联检查,确定是否一个已知的两个字段之间的关系是有效的。身份证和姓名有关联</li>
<li>自检数字,确定主键数据输入错误。(对主关键字进行基于校验位的检查)</li>
<li>输入格式检查，比较数据与已知的格式使用</li>
</ul>
</li>
</ul>
<h3 id="输入设计的GUI控件"><a href="#输入设计的GUI控件" class="headerlink" title="输入设计的GUI控件"></a>输入设计的GUI控件</h3><h4 id="常见的GUI空间"><a href="#常见的GUI空间" class="headerlink" title="常见的GUI空间"></a>常见的GUI空间</h4><ul>
<li>文本框——当输入数据值的范围不受限制，分析人员无法向用户提供有意义的值列表，用户可以从中进行选择时。</li>
<li>单选按钮,当输入数据有限组预定义的互斥(互斥)值。</li>
<li>复选框——当用户需要输入一个数据字段，该字段的值集由一个简单的yes或no值组成</li>
<li>列表框-作为单选按钮，但当更多的值需要选择，因为滚动条正在使用。</li>
<li>下拉列表-作为列表框，除了隐藏列表</li>
<li>组合框-组合一个文本框和一个列表框。</li>
<li>按钮-允许用户提交所有要处理的数据，或取消事务，或获得帮助。</li>
</ul>
<h4 id="高级的GUI空间"><a href="#高级的GUI空间" class="headerlink" title="高级的GUI空间"></a>高级的GUI空间</h4><ul>
<li>下拉日历</li>
<li>滑块(滑块)编辑控件，选择值的非数字方式。</li>
<li>蒙面编辑控件-采取格式检查。</li>
<li>省略号(省略号)控制——被用于一个字段,由几个部分组成。</li>
</ul>
<h3 id="怎么样进行输入设计"><a href="#怎么样进行输入设计" class="headerlink" title="怎么样进行输入设计"></a>怎么样进行输入设计</h3><h4 id="输入设计过程"><a href="#输入设计过程" class="headerlink" title="输入设计过程"></a>输入设计过程</h4><ul>
<li><p>识别系统输入并检查逻辑需求。</p>
</li>
<li><p>选择适当的输入组件/控制。</p>
</li>
<li><p>设计、验证和测试输入使用的组合:</p>
<ul>
<li>布局工具(例如,草图,间距图表,或CASE工具。</li>
<li>原型工具(如电子表格、PC DBMS, 4GL)</li>
</ul>
</li>
<li><p>根据需要,设计任何源文件。</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/111zx/111zx.github.io/2020/03/24/%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/" data-id="ck88at6vg000914ub3xnealwp" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-构件与中间件技术" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/22/%E6%9E%84%E4%BB%B6%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%8A%80%E6%9C%AF/" class="article-date">
  <time datetime="2020-03-22T11:25:53.000Z" itemprop="datePublished">2020-03-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/22/%E6%9E%84%E4%BB%B6%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%8A%80%E6%9C%AF/">构件与中间件技术</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="第二章-CORBA基本原理"><a href="#第二章-CORBA基本原理" class="headerlink" title="第二章 CORBA基本原理"></a>第二章 CORBA基本原理</h2><pre><code>对象管理体系结构
CORBA体系结构
对象的客户操作性
CORBA规范和产品

对象管理组织OMG
    OMG主要规范
        UML(Unified Model Language)：是面向对象分析与设计阶段的表示技术规范
        CORBA：（Common Object Request Broker Architecture）

对象管理体系结构OMA：
Object Management Architecture是CORBA所给予的概念框架，他描述了一个较高层次的分布式计算环境
    核心内容是对象模型和参考模型
        对象模型：定义了外部可见特征的，独立于具体实现的语义
        参考模型：标识和刻画了组成OMA的组件，接口和协议

组成：

    对象请求代理(ORB): 连接对象服务（功能），靠接口来实现功能（应用程序接口，领域接口，公共设施）。
        是OMA参考模型的核心
        提供了分布式对象之间透明的发送和接受响应的基本机制


    对象服务（需要完成的功能）：
        对象服务是一种通用的服务
        对象服务的本质是将覆盖对象整个生存期的对象管理任务标准化：
            例如，对象的创建，对象的访问控制，并发和安全性等
            可导致不同应用程序的一致性，提高开发的效率
            COSS：包括对象命名，事件，等的规范

    公共设施：包括分布式文档设施，打印社是，数据库设施，电子邮件设施等
        同样具有自己的规范

    领域接口：
        与应用领域有关的接口
        例如，金融，医疗，电子商务等
        不同领域有不同的规范
        标准划主要是指针对接口的标准化

    应用程序的接口：
        应用程序对象是终端用户执行的任务
        不是OMG标准划的内容，是构成整个OMA模型的最上层</code></pre><h3 id="CORBA体系结构"><a href="#CORBA体系结构" class="headerlink" title="CORBA体系结构"></a>CORBA体系结构</h3><pre><code>对象模型
    对象模型描述了对象外部特征的标准语义
    对象，类型，操作属性等语义和Java等OO语言十分相近
    但同时具有组件/构件的特征
    分布式对象
客户程序与对象实现之间的界面是对象的接口定义
    接口
        客户程序所看到的对象接口完全独立于
            对象所处的位置
            实现对象的程序设计语言
            对象接口中未反映的其他特性
    这种独立性是独立于ORB来保证
对象接口采用接口定义语言IDL定义

OMG请求可携带的信息：
    操作
    提供服务的目标对象引用
    实际参数
    一个可选的上下文
    请求表

对象的创建和撤销
    从客户的角度看，没有特别的机之用于创建和撤销对象

ORB结构
    客户程序与动态调用接口，IDL Stub，ORB接口交互
    对象实现与ORB接口，静态IDLSkeleton，动态框架，对象适配器交互

ORB接口：
    客户程序只能通过对象的接口定义掌握对象的逻辑结构，客户程序不会知道对象具体的实现方式，也不必知道哪个对象适配器以及需要哪个ORB访问该对象实现
    对象实现可以用多种方式实现
        独立的服务程序，程序库每个方法用一个程序实现
        通过附加的程序适配器，ORB事实上可以支持所有风格的对象实现

Stub/Skeleton机制
    采用Stub/Skeleton机制支持客户端和服务端的交互
    stub桩的调用方式：静态调用
        静态调用借助于客户程序桩完成
        桩与框架再编译时创建并且在运行时不再改变，所以这些接口成为SII（Static Invocation Interface）
        IDL桩负责客户程序的实现语言与ORB内核之间的映射
        客户程序需要在编译之前知道操作的名字，方式等
    IDL skeleton：静态请求分派方式
        静态方式通过由IDL生成的框架完成
        ORB通过IDL框架查找合适的实现代码，传送参数，并将控制传送给对象实现
        对象实现执行请求时可以通过对象适配器OA获取ORB的某些服务，请求完成后控制与结果返回客户程序

    动态调用接口（DII）
        客户程序使用DII时不许生成一个请求，其中包括对象引用，操作以及参数表
        使用DII的应用程序访问对象实现提供的服务时，不必包含由IDL编译器生成的桩，只需在运行时间访问ANY对象
        代价：程序员必须用DII接口指定操作和每个操作的类型和值，并由我们自己解决类型检查
        延迟同步调用：
            用户程序提交请求后不必等候答复，还必须轮询，可以利用CORBA的异步消息服务来实现纯异步
        DII较SII更适合的场合：
            编写CORBA服务的浏览器
            应用程序浏览器
            转换协议的桥接
            访问大量不同的接口
            应用程序的监控
            同意对象测试程序等

    动态框架接口（DSI）
        动态方式使用DSI
        不必包含IDL产生的框架
        需要手工编程必须检查类型的安全性
        DIS优于静态的场合：
            类似DII

    对象适配器
        对象实现与ORB内核之间的通信由对象适配器完成（客户程序不需要与ORB内核交互）
            对象适配器负责与对象有关的一系列操作，包括
                对象引用的生成与解释，方法调用，交互的安全性，对象实现的激活与冻结等
            为满足特定的系统，不同的系统又不同的适配器

CORBA的可操作性
    ORB对于可操作性的支持
        ORB可以支持同一厂家ORB上的客户端与服务端方便的交互
        不同的ORB产品之间的互操作性
        影响互操作性的因素    
            实现方面的差异
            安全性
    域：支持开发人员根据自己实现因素或者管理原因将对象划分为不同的集合
        不同域的对象之间需要桥接机制才可以彼此交互
    域之间的桥接
        直接桥接
            需交互的元素直接转换为两个域的内部表示
            效率高通用性不好
        简介桥接
            需交互元素在域的内部表现形式和各个域认可的另一种表现形式之间互相转换
    不同平台域语言之间的互操作性
        IDL标准和IDL到程序语言的映射
    不同厂商的ORB产品之间的互操作性
        靠FIOP和IIOP的协议实现</code></pre><h2 id="第三章-CORBA应用程序的开发"><a href="#第三章-CORBA应用程序的开发" class="headerlink" title="第三章 CORBA应用程序的开发"></a>第三章 CORBA应用程序的开发</h2><h3 id="CORBA平台架构"><a href="#CORBA平台架构" class="headerlink" title="CORBA平台架构"></a>CORBA平台架构</h3><pre><code>建议使用OO语言实现CORBA
    IDL是OO风格的

CORBA运行平台
网络传输
消息传递
    同步方式
        ORB默认的通信方式    
    异步方式（延迟同步方式）
    单向通信
        监控
    不同场合使用：
        所申请的服务只需要很短时间就可以完成（同步）
        所申请的服务需要较长的时间才可以完成（异步）
        客户端无需获取请求已完成的确认信息（单向）
资源优化

CORBA应用程序开发过程
    面向对象分析与设计
    用IDL编写对象接口
    编译IDL文件生成装与框架
    编写客户端/服务程序代码
    编译客户端/服务程序
    部署应用程序
    运行应用程序

银行账户管理案例：
    定义接口对象：</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 银行帐户管理系统的对象接口定义</span><br><span class="line">module Bank &#123;</span><br><span class="line">    // 帐户</span><br><span class="line">    interface Account &#123;</span><br><span class="line">        // 存款</span><br><span class="line">        void deposit(<span class="keyword">in</span> <span class="built_in">float</span> amount);</span><br><span class="line">        // 取款</span><br><span class="line">        boolean withdraw(<span class="keyword">in</span> <span class="built_in">float</span> amount);</span><br><span class="line">        // 查询余额</span><br><span class="line">        <span class="built_in">float</span> getBalance();</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    // 帐户管理员</span><br><span class="line">    interface AccountManager &#123;</span><br><span class="line">        // 查询指定名字的帐户，查无则新开帐户</span><br><span class="line">        Account open(<span class="keyword">in</span> string name);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<pre><code>    定义结构定义对象为了生成stub与skeleton
        账户对象Account：

            AccountOperations.java ：
            Account.java
            _AccountStub.java ：客户端存根（stub），是Account再客户端的桩代码，它实现的Account接口
                程序员编写的客户程序代码一般不调用这个类中的方法
                VisiBroker for java生成了另外的辅助类AccountHelper
                    该类提供了一个narrow方法，用于返回一个Account接口的指针
                    实际上该方法实例化了一个_AccountStub对象，所以客户端通过返回的接口指针实际调用了桩对象的代码
                    由桩对象完成具体的和服务端的通信
            AccountPOA.java ：服务端框架（skeletion），是Account对象的服务器框架代码，功能：
                解开in类型的参数，并将参数传递给对象实现
                打包返回值与所有out类型的参数
                    打包：java的数据类型转化为CORBA的ⅡOP流格式
                    解包：从ⅡOP流格式转换为依赖于JAVA的数据结构
                编写对象实现的最简单途径是继承这些POA类
                    即把他们作为对象的基类
    生成的纽带机制类：
        AccountPOAtIE.java用于采用纽带机制实现服务端的Account对象
            AccountPOATie是Account接口的委托方的实现
            应为java语言的单重继承限制，所以引入了纽带机制
            每一个AccountTie对象必须关联一个真正的实现类
            真正的实现类必须实现AccountOperations接口
    生成的辅助工具类：
        AccountHelper.java声明AccountHelper类
            该类为Account接口定义了许多实用功能和支持功能的静态方法
            绑定对象与类型转换操作
            从输入/输出流读写对象
    生成的对象传递支撑类：
        AccountHolder.java声明的AccountHeolder类为传递对象提供支持
            IDL由三种传递参数的方式：in，out，inout
            in类型的参数以及返回结构与java类型参数传递与返回结构完全相同
            out和inout两种类型的参数允许参数具有返回结果的能力，无法直接映射到java语言的参数传递机制
            这是AccountHolder类为参数传递out和inout参数提供了一个托架
账户对象实现：</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class AccountImpl</span><br><span class="line">	extends Bank.AccountPOA</span><br><span class="line">&#123;</span><br><span class="line">	protected <span class="built_in">float</span> balance;//定义余额属性</span><br><span class="line">	</span><br><span class="line">	public AccountImpl(<span class="built_in">float</span> bal)</span><br><span class="line">	//构造方法，按照传递的余额（bal）创建新的账户</span><br><span class="line">	&#123;</span><br><span class="line">		balance = bal;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public void deposit(<span class="built_in">float</span> amount)</span><br><span class="line">	//存款 </span><br><span class="line">	&#123;</span><br><span class="line">		balance += amount;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public boolean withdraw(<span class="built_in">float</span> amount)</span><br><span class="line">	//取款，如果不够返回<span class="literal">false</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(balance &lt; amount)</span><br><span class="line">			<span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			balance -= amount;</span><br><span class="line">			<span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public <span class="built_in">float</span> getBalance()</span><br><span class="line">	//查询余额</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">return</span> balance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>账户管理员对象实现：</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">import org.omg.PortableServer.*;</span><br><span class="line"></span><br><span class="line">public class AccountManagerImpl</span><br><span class="line">	extends Bank.AccountManagerPOA</span><br><span class="line">&#123;</span><br><span class="line">	protected Hashtable accountList;//该账户管理员所负责的账户清单</span><br><span class="line">	public AccountManagerImpl()</span><br><span class="line">	//构造方法，创建一个管理员对象</span><br><span class="line">	&#123;</span><br><span class="line">		accountList = new Hashtable();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public synchronized Bank.Account open(String name)</span><br><span class="line">	//给用户开户</span><br><span class="line">	&#123;</span><br><span class="line">		Bank.Account account = (Bank.Account)accountList.get(name);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(account == null)</span><br><span class="line">		//如果该name对应的账户不存在，则新开一个账户，初始余额为0</span><br><span class="line">			&#123;			</span><br><span class="line">			<span class="built_in">float</span> balance = 0;</span><br><span class="line">			AccountImpl accountServant = new AccountImpl(balance);</span><br><span class="line">			try&#123;</span><br><span class="line">				//用缺省的POA激活对象，这里缺省的POA就是根POA</span><br><span class="line">				org.omg.CORBA.Object obj = </span><br><span class="line">					_default_POA().servant_to_reference(accountServant);</span><br><span class="line">				//将对象引用窄化为Account类型</span><br><span class="line">				account = Bank.AccountHelper.narrow(obj);</span><br><span class="line">			&#125;catch(Exception exc)&#123;</span><br><span class="line">				exc.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			accountList.put(name, account);</span><br><span class="line">			System.out.println(<span class="string">"新开账户："</span> + name);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">return</span> account;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>编写服务程序：
    初始化ORB
    创建一个对象适配器
    创建提供服务的伺服对象
    激活私服对象
    激活POA管理器
    等待客户程序发来请求
服务程序：</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">import org.omg.PortableServer.*;</span><br><span class="line"></span><br><span class="line">public class Server</span><br><span class="line">&#123;</span><br><span class="line">	public static void main(String[] args)</span><br><span class="line">	&#123;</span><br><span class="line">		try&#123;</span><br><span class="line">			//初始化ORB</span><br><span class="line">			org.omg.CORBA.ORB orb = org.omg.CORBA.ORB.init(args, null);</span><br><span class="line">			//获取根POA的引用</span><br><span class="line">			POA rootPOA = POAHelper.narrow(</span><br><span class="line">				orb.resolve_initial_references(<span class="string">"RootPOA"</span>));</span><br><span class="line">			//创建持久POA的策略</span><br><span class="line">			org.omg.CORBA.Policy[] policies = &#123;</span><br><span class="line">				rootPOA.create_lifespan_policy(LifespanPolicyValue.PERSISTENT),</span><br><span class="line">				//rootPOA.create_id_assignment_policy(IdAssignmentPolicyValue.USER_ID)</span><br><span class="line">			&#125;;</span><br><span class="line">			//用新定义的策略创建myPOA</span><br><span class="line">			POA myPOA = rootPOA.create_POA(<span class="string">"BankPOA"</span>, rootPOA.the_POAManager(), policies);</span><br><span class="line">			//创建伺服对象</span><br><span class="line">			AccountManagerImpl managerServant = new AccountManagerImpl();</span><br><span class="line">			//在myPOA上用标识<span class="string">"BankManager"</span>激活伺服对象</span><br><span class="line">			myPOA.activate_object_with_id(<span class="string">"BankManager"</span>.getBytes(), managerServant);</span><br><span class="line">			//激活POA管理器</span><br><span class="line">			rootPOA.the_POAManager().activate();</span><br><span class="line">			//等待处理客户程序的请求</span><br><span class="line">			System.out.println(<span class="string">"账户管理员BankManager已就绪...\n"</span>);</span><br><span class="line">			orb.run();</span><br><span class="line">		&#125;catch(Exception exc)&#123;</span><br><span class="line">			exc.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>客户程序：</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class Client</span><br><span class="line">&#123;</span><br><span class="line">	public static void main(String[] args)</span><br><span class="line">	&#123;</span><br><span class="line">		//初始化ORB</span><br><span class="line">		org.omg.CORBA.ORB orb = org.omg.CORBA.ORB.init(args, null);</span><br><span class="line">		//利用POA全称与对象标识<span class="string">"BankManager"</span>查找账户管理员</span><br><span class="line">		Bank.AccountManager manager = Bank.AccountManagerHelper.bind(</span><br><span class="line">			orb, <span class="string">"/BankPOA"</span>, <span class="string">"BankManager"</span>.getBytes());//,<span class="string">"192.168.118.3"</span>, new com.inprise.vbroker.CORBA.BindOptions());</span><br><span class="line">		String name = args.length &gt; 0? args[0]:<span class="string">"SHLSong"</span>;</span><br><span class="line">		Bank.Account account = manager.open(name);</span><br><span class="line">		</span><br><span class="line">		System.out.println(name + <span class="string">"的账户余额为"</span> + account.getBalance() + <span class="string">"元"</span>);</span><br><span class="line">		account.deposit(400);</span><br><span class="line">		System.out.println(<span class="string">"存款400元后，余额为"</span> + account.getBalance() + <span class="string">"元"</span>);</span><br><span class="line">		<span class="keyword">if</span>(account.withdraw(500))&#123;</span><br><span class="line">			System.out.println(<span class="string">"取款500元后，余额为"</span> + account.getBalance() + <span class="string">"元"</span>);</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			System.out.println(<span class="string">"余额不足500元，取款失败，余额保持不变"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>编译应用程序
    利用VisiBroker for java提供的编译器vbjc完成这一工作：</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vbjc Server.java</span><br><span class="line">vbjc Client.java</span><br></pre></td></tr></table></figure>
<pre><code>    vbjc十几张封装了JDK提供的Java编译器
    Holder类和POATie需要指定额外的参数才会下生成
按一定的顺序启动应用程序
    1. 启动智能代理
        运行CORBA应用程序之前，网络之中必须至少有一台主机上启动了智能代理osagent
        这是VisiBroker特有的分布式位置服务守护进程，网络中多个智能代理可写作查找合适的对象实现</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">osagent</span><br></pre></td></tr></table></figure>
<pre><code>2. 启动服务程序</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start vbj Server</span><br></pre></td></tr></table></figure>
<pre><code>3. 启动客户程序</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vbj Client</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/111zx/111zx.github.io/2020/03/22/%E6%9E%84%E4%BB%B6%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%8A%80%E6%9C%AF/" data-id="ck88at6vd000714ubh0pkb3z4" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Web工程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/21/Web%E5%B7%A5%E7%A8%8B/" class="article-date">
  <time datetime="2020-03-21T06:42:35.000Z" itemprop="datePublished">2020-03-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/21/Web%E5%B7%A5%E7%A8%8B/">Web工程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="软件架构"><a href="#软件架构" class="headerlink" title="软件架构"></a>软件架构</h2><p>软件架构能够体现出动态的特性</p>
<p>Web架构：</p>
<p>设计模式：<br>各个组件之间如何联系以及怎么设计<br>三个不同的抽象层次：<br>    架构模式：<br>        系统的结构解决方案；<br>        子系统的架构没职责和相互作用<br>    设计模式：<br>        特定情况下。。。<br>    编程模式：<br>        …<br>MVC （model-view-controller）<br>框架：一组组件的综合，对相关的应用提供可重用的框架结构<br>    可以进行实例化<br>    特定领域的基本蓝图<br>    通用的功能已经类实现的可复用软件系统</p>
<p>Struts：</p>
<p>框架的优点：<br>    简单重用框架的架构和功能<br>缺点：<br>    需要专业知识<br>    不同的框架之间没有联系<br>    商业产品太过依赖架构<br>层次特性：<br>    分而治之：<br>数据特性：<br>    结构化还是非结构化<br>分布特性：<br>    分布对象中间件<br>    虚拟共享内存<br>    面向消息中间件<br>    P2P<br>    面向服务的中间件<br>Web应用架构特性<br>    Web基础架构<br>    WPA<br>    不同的系统是使得更难评估和维护各种质量需求<br>    技术架构的异构性和不成熟<br>    国际化<br>通用的包含的组件<br>    那些事Web端，那些事服务端<br>    客户端（浏览器和外部应用）<br>    防火墙<br>    Web服务器</p>
<p>层次架构:<br>    Web应用的两层架构<br>         客户端只有客户<br>        服务端：数据库，业务逻辑等等<br>    Web应用的三层架构<br>        展示层：封装用户和其他系统的交互<br>        逻辑层：业务逻辑<br>        数据层：相关数据<br>    Ruby on Rauls应用架构<br>     ASP.NET应用架构:三层架构<br>     Web应用的N曾架构<br>         业务层的扩展，其他和三层差不多的</p>
<pre><code>后端：三层五共享架构
...
JAVA EE应用架构
    客户层
    Web层
    业务层
    数据层
JSP-Model-2：html代码镶嵌上JAVA代码
jsp不需要编译过后再运行，在应用服务器可以直接运行
JSP运行模式：先回转成JAVA代码，而HTML会翻译成字符串（后来的开发工具已经解决）
JSP-Model 实现 in Struts
    Web-Server包括 Serverlet -Container
Websphere
SPA:四层
    view
    应用服务
    存储
    。。。
单体架构
    打包成一个包，部署和测试会更容易
多层应用的优点：
    重用：
        扩展性好
        代码好维护
缺点：
    切割复杂
    故障点</code></pre><p> 层次架构的设计：<br>     …<br> 集成架构：<br>     展示层面<br>     应用逻辑层面<br>     服务层<br> 门户（Poetal）：针对具体用户或者社区的应用平台<br>                 水平门户：新浪，腾讯<br>                 垂直门户：W3C,语义Web社区等<br> EAI（企业应用集成）：<br>     强调内容层面和应用逻辑层面集成的架构<br>     集成遗留系统<br>     采用中间件<br>     继承不同数据源，不同平台的异构应用<br> SOA（面向服务的架构）：<br>     提供一种集成框架<br>     关键是服务<br>         Web服务是实现SOA的方式之一<br>         应用程序的业务功能称为服务<br> 面向数据的架构<br>     数据结构分类<br>         数据库的结构化数据<br>         文档类<br>         多媒体数据和媒体服务器<br>     Web应用结合使用<br>     以数据库为中心的架构<br>     Web文档管理架构<br>     流媒体数据的架构：<br>         直播是 实时流协议<br>     使用广播的流架构</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><pre><code>好的架构可以提高Web应用的开发效率，可重用性，易于维护和扩展
    架构模式
    层次架构
    面向数据的架构
    集成架构</code></pre><p>淘宝基于Node的前后端分离<br>    Node服务：</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/111zx/111zx.github.io/2020/03/21/Web%E5%B7%A5%E7%A8%8B/" data-id="ck88at6v7000214ub0h7mg3kf" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/06/10/%E6%B3%9B%E5%9E%8B/">泛型</a>
          </li>
        
          <li>
            <a href="/2020/06/09/%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E8%AF%BE%E7%A8%8B%E6%8A%A5%E5%91%8A/">软件体系结构课程报告</a>
          </li>
        
          <li>
            <a href="/2020/06/01/%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%92%8C%E6%B3%A8%E8%A7%A3/">枚举类和注解</a>
          </li>
        
          <li>
            <a href="/2020/05/26/%E5%B8%B8%E7%94%A8%E7%B1%BB/">常用类</a>
          </li>
        
          <li>
            <a href="/2020/05/24/linux/">linux</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 zx<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>