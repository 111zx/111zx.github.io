<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="https://github.com/111zx/111zx.github.io/page/3/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="zx">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://github.com/111zx/111zx.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-JVM" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/20/JVM/" class="article-date">
  <time datetime="2020-05-19T23:41:47.000Z" itemprop="datePublished">2020-05-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/20/JVM/">JVM</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<h1 id="JVM与JAVA体系结构"><a href="#JVM与JAVA体系结构" class="headerlink" title="JVM与JAVA体系结构"></a>JVM与JAVA体系结构</h1><h2 id="JAVA历史"><a href="#JAVA历史" class="headerlink" title="JAVA历史"></a>JAVA历史</h2><ul>
<li>2004 jdk1.5</li>
<li>2011，jdk7正式启用了新的垃圾回收器G1</li>
<li>2017，jdk9发布，GC代替CMS</li>
<li>2018,   jdk11发布，ZGC</li>
</ul>
<h2 id="虚拟机和JVM介绍"><a href="#虚拟机和JVM介绍" class="headerlink" title="虚拟机和JVM介绍"></a>虚拟机和JVM介绍</h2><ul>
<li>是对物理计算机的仿真，但实际还是一个软件</li>
<li>JVM执行的指令是JAVA字节码指令</li>
<li>字节码不光是Java字节码，只要符合规则，都可以运行</li>
</ul>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li><p>一次编译，到处运行</p>
</li>
<li><p>自动内存管理</p>
</li>
<li><p>自动垃圾回收</p>
</li>
</ul>
<h2 id="JVM的位置"><a href="#JVM的位置" class="headerlink" title="JVM的位置"></a>JVM的位置</h2><ul>
<li>用户—&gt;字节码—&gt;JVM—&gt;操作系统—&gt;硬件</li>
<li>.java —&gt;.class（字节码） —&gt;解释运行（JVM）</li>
</ul>
<h2 id="JVM的整体结构"><a href="#JVM的整体结构" class="headerlink" title="JVM的整体结构"></a>JVM的整体结构</h2><p><img src="/111zx/111zx.github.io/2020/05/20/JVM/C:%5CUsers%5C14914%5CDesktop%5C%E5%9B%BE%E7%89%87%E4%B8%AD%E8%BD%AC%E7%AB%99%5CJVM%5CJVM%E7%BB%93%E6%9E%84.png" alt></p>
<ul>
<li>垃圾回收器在执行引擎中</li>
<li>JIT编译器（编译器后端）</li>
<li>执行引擎：字节码翻译成机器语言</li>
</ul>
<h2 id="Java代码执行流程"><a href="#Java代码执行流程" class="headerlink" title="Java代码执行流程"></a>Java代码执行流程</h2><ol>
<li>java程序经过编译器前端编译器生成字节码文件</li>
<li>.class经过Java虚拟机（由执行引擎将字节码翻译成机器语言）</li>
<li>热点字节码指令被JIT编译器编译成机器语言存在缓存区里</li>
</ol>
<h2 id="JVM的架构模型"><a href="#JVM的架构模型" class="headerlink" title="JVM的架构模型"></a>JVM的架构模型</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Java编译器输入的指令流基本上是一种<strong>基于栈</strong>的指令集架构，另外一种是<strong>基于寄存器</strong>的指令集架构</p>
<h3 id="基于栈特点"><a href="#基于栈特点" class="headerlink" title="基于栈特点"></a>基于栈特点</h3><ol>
<li>简单，资源受限</li>
<li>避开了寄存器的分配难题</li>
<li>指令流中的指令大部分是零地址指令，其过程依赖于操作栈</li>
<li>不需要硬件支持，可移植性好</li>
</ol>
<h3 id="基于寄存器架构的特点"><a href="#基于寄存器架构的特点" class="headerlink" title="基于寄存器架构的特点"></a>基于寄存器架构的特点</h3><ol>
<li>典型的是x86的二进制指令集</li>
<li>指令集架构完全依赖于硬件，可移植性查</li>
<li>性能优秀更高效</li>
<li>花费更少的指令去完成一项操作</li>
<li>大部分情况下，多以一地址，二地址和三地址指令执行。</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>栈：跨平台性，指令集小，指令多；执行性能比寄存器差</li>
<li>Java的指令都是根据栈来设计的</li>
</ul>
<h2 id="JVM的生命周期"><a href="#JVM的生命周期" class="headerlink" title="JVM的生命周期"></a>JVM的生命周期</h2><ol>
<li>启动</li>
<li>运行</li>
<li>结束</li>
</ol>
<h3 id="虚拟机的启动"><a href="#虚拟机的启动" class="headerlink" title="虚拟机的启动"></a>虚拟机的启动</h3><ul>
<li>JVM的启动是通过引导类加载器创建一个初始类来完成，这个类是由虚拟机的具体实现决定的。</li>
<li>自定义的类时通过系统类加载器实现</li>
<li>父类加载早于子类</li>
</ul>
<h3 id="虚拟机的执行"><a href="#虚拟机的执行" class="headerlink" title="虚拟机的执行"></a>虚拟机的执行</h3><ul>
<li>程序开始运行，程序结束停止</li>
</ul>
<h3 id="虚拟机的退出"><a href="#虚拟机的退出" class="headerlink" title="虚拟机的退出"></a>虚拟机的退出</h3><ul>
<li>异常终止</li>
<li>正常执行退出</li>
<li>OS错误JVM退出</li>
<li>某线程调用Runtime类或System类的exit方法，或Runtimely的halt方法，并且Java安全管理企业允许这次exit或halt操作</li>
</ul>
<h3 id="JVM发展历程"><a href="#JVM发展历程" class="headerlink" title="JVM发展历程"></a>JVM发展历程</h3><ol>
<li><p>Classic VM 第一款商用虚拟机，内部只提供了解释器，没有JIT编译器（热点代码及时编译成机器指令），可以外挂JIT，但是不能同时进行</p>
<ol>
<li>每一条代码都编译成本地的机器指令的话，速度很慢</li>
<li>解释器：直接步行；JIT编译器：等公交车，坐上后快；搭配使用：看准时机，选择交通方式</li>
</ol>
</li>
<li><p>Exact VM jdk1.2：准确式内存管理，直到某个位置的数据具体是什么类型</p>
<ol>
<li>具备现代高性能虚拟机的雏形</li>
<li>编译器和解释器混合工作模式，热点探测（热点代码）</li>
</ol>
</li>
<li><p>HotSpot虚拟机 JDK1.3成为默认虚拟机（Oracle）</p>
<ol>
<li>GC机制</li>
<li>方法区</li>
<li>jdk8有元空间</li>
<li>名字体现的是热点代码的探测技术<ul>
<li>解释器和编译器协同工作，响应时间和执行性能取得平衡</li>
</ul>
</li>
</ol>
</li>
<li><p>JRockit（Oracle）</p>
<ol>
<li>专注于服务器端应用<ul>
<li>不太关注响应时间</li>
<li>全部代码靠即时编译器执行</li>
</ul>
</li>
<li>世界上最快的JVM</li>
<li>优势：全面的java运行时解决方案组合<ul>
<li>MissionControl服务套件</li>
</ul>
</li>
</ol>
</li>
<li><p>J9（IBM）</p>
<ol>
<li>号称最快</li>
<li>三大商业虚拟机（JRockit，HotSpot）</li>
</ol>
</li>
<li><p>KVM,CDC,CLDC</p>
<ol>
<li>老年手机的应用</li>
</ol>
</li>
<li><p>Azul VM</p>
<ol>
<li>与特定硬件平台耦合，性能非常高（比三大高）</li>
</ol>
</li>
<li><p>Liquid VM</p>
<ol>
<li>不需要操作系统支持，本身实现了一个操作系统</li>
</ol>
</li>
<li><p>Apache Harmony</p>
<ul>
<li>Sun和Apache的扯皮</li>
</ul>
</li>
<li><p>Microsoft JVM</p>
<ul>
<li>IE浏览器性能好</li>
<li>Sun指控微软</li>
</ul>
</li>
<li><p>Taobao JVM</p>
<ul>
<li>基于OpenJDK定制的AJDK</li>
</ul>
</li>
<li><p>Dalvik VM</p>
<ul>
<li><p>不是JVM，不能执行.class文件，是.dex文件</p>
</li>
<li><p>基于寄存器架构，不是jvm栈架构</p>
</li>
</ul>
</li>
<li><p>Graal VM</p>
<ul>
<li>跨语言全栈虚拟机</li>
<li>中间格式</li>
</ul>
</li>
</ol>
<hr>
<h1 id="第二章-类加载子系统"><a href="#第二章-类加载子系统" class="headerlink" title="第二章 类加载子系统"></a>第二章 类加载子系统</h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2-1. 概述"></a>2-1. 概述</h2><ul>
<li><p>作用：加载Class文件，class文件在文件开头有特定的文件标识</p>
</li>
<li><p>ClassLoader（七大姑八大姨）只负责class的加载(找相亲对象)，至于是否可以运行（自己的本事），则由ExecutionEngine决定。</p>
<ul>
<li><ol>
<li>class文件存放在本地硬盘上，加载类，初始化，main()方法。</li>
</ol>
</li>
</ul>
</li>
<li><p>方法区除了类信息外，还有常量池的信息。</p>
</li>
<li><p>过程</p>
<ul>
<li>加载</li>
<li>链接<ul>
<li>验证</li>
<li>准备</li>
<li>解析</li>
</ul>
</li>
<li>初始化</li>
</ul>
</li>
<li><p>程序计数器每个线程一个</p>
</li>
<li><p>栈：每个线程一份</p>
<ul>
<li>每个结构是一个栈帧</li>
<li>动态链接等</li>
</ul>
</li>
<li><p>本地方法栈：本地方法接口</p>
</li>
<li><p>堆区：创建类对象，是多个线程共享的</p>
</li>
<li><p>方法区：类信息，常量，方法信息（只有hotspot才有）</p>
</li>
<li><p>执行引擎：即时编译器，解释器，GC</p>
</li>
<li><p>如果要写一个建议的JVM，需要关注类加载子系统和执行引擎</p>
</li>
</ul>
<h2 id="2-2-loading阶段"><a href="#2-2-loading阶段" class="headerlink" title="2-2. loading阶段"></a>2-2. loading阶段</h2><h3 id="2-2-1-概述"><a href="#2-2-1-概述" class="headerlink" title="2-2-1. 概述"></a>2-2-1. 概述</h3><ul>
<li>通过一个类的全限定名获取定义此类的二进制字节流</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li>
<li>在内存中生成一个<strong>java.lang.Class对象</strong>，作为方法去的这个类的各种数据的访问入口</li>
<li>加载.class文件的方式<ul>
<li>本地直接加载</li>
<li>网络获取Wen Applet</li>
<li>jar包</li>
<li>运行时计算生成，动态代理技术</li>
<li>由其它文件生成，JSP</li>
</ul>
</li>
</ul>
<h2 id="2-3-linking阶段"><a href="#2-3-linking阶段" class="headerlink" title="2-3. linking阶段"></a>2-3. linking阶段</h2><h3 id="2-3-1-验证阶段"><a href="#2-3-1-验证阶段" class="headerlink" title="2-3-1. 验证阶段"></a>2-3-1. 验证阶段</h3><ul>
<li>目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性</li>
<li>主要包括四种验证<ul>
<li>文件验证</li>
<li>元数据验证 </li>
<li>字节码验证</li>
<li>符号引用验证</li>
</ul>
</li>
</ul>
<h3 id="2-3-2-准备阶段"><a href="#2-3-2-准备阶段" class="headerlink" title="2-3-2. 准备阶段"></a>2-3-2. 准备阶段</h3><ul>
<li><p>为<strong>(static所修饰的)类变量</strong>分配内存并且设置该<strong>变量</strong>的默认初始值，即0值</p>
<ul>
<li>int：0</li>
<li>char：’/uoooo’(null)</li>
<li>float：0.0f</li>
<li>double：0.0d</li>
<li>byte：0</li>
<li>short：0</li>
<li>long：0L</li>
<li>boolean：false</li>
<li>引用类型：null</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Helloworld</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">1</span>;<span class="comment">//准备阶段是赋值默认初始值，先是0，之后初始化才会是1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>不包含final修饰的static，因为final在编译的时候就会分配了，准备阶段会显式初始化（直接为其赋值=号后面的值）</li>
<li><strong>不会为实例变量初始化</strong>，类变量会分配在方法区中，而实例变量是会随着对象一起分配到java堆中</li>
</ul>
<h3 id="2-3-3-解析阶段"><a href="#2-3-3-解析阶段" class="headerlink" title="2-3-3. 解析阶段"></a>2-3-3. 解析阶段</h3><ul>
<li>符号引用转换为直接引用</li>
</ul>
</li>
</ul>
<h2 id="2-4-Initialization阶段"><a href="#2-4-Initialization阶段" class="headerlink" title="2-4. Initialization阶段"></a>2-4. Initialization阶段</h2><ul>
<li><p>初始化阶段就是执行类构造器方法<clinit>的过程</clinit></p>
</li>
<li><p>此方法不需要定义，是javac编译器自动收集所有类中所有<strong>类变量(static所修饰的)</strong>的复制动作和<strong>静态代码块</strong>中的语句合并而来</p>
</li>
<li><p>构造器方法中指令在源文件中出现的<strong>顺序执行</strong></p>
</li>
<li><p>在变量声明之前可以给变量赋值，在第一部准备阶段，B已经被初始化为0.<strong>只能赋值不能引用</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">B = <span class="number">2</span>;<span class="comment">//正确</span></span><br><span class="line">system.out.print(B);<span class="comment">//错误</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> B = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p><clinit>()不同于类的构造器。（类的构造器在虚拟机视角下是<init>）</init></clinit></p>
</li>
<li><p>类没有静态代码块就不会有<clinit>()方法</clinit></p>
</li>
<li><p>若该类具有父类，JVM会保证子类的<clinit>()执行前，父类的<clinit>()已经执行完毕</clinit></clinit></p>
<ul>
<li>虚拟机第一个执行的类会是Object</li>
</ul>
</li>
<li><p>虚拟机必须保证一个类的<clinit>()方法在多线程下被同步加锁</clinit></p>
<ul>
<li>每个类只需要被执行一次，若不加同步锁，有可能会执行很多次</li>
</ul>
</li>
</ul>
<h2 id="2-5-类加载器的分类"><a href="#2-5-类加载器的分类" class="headerlink" title="2-5. 类加载器的分类"></a>2-5. 类加载器的分类</h2><h3 id="引导类加载器"><a href="#引导类加载器" class="headerlink" title="引导类加载器"></a>引导类加载器</h3><ul>
<li>Bootstrap Class Loader(C和C++实现的)（第一层）</li>
<li>获取到的加载器是null，就是引导类加载器，核心类就获取不到类加载器</li>
<li>用来加载Java的核心库，用来提供JVM自身需要的类</li>
<li>不继承java.lang.ClassLoader</li>
<li>加载扩展类和应用程序类加载器，并指定为他们的类加载器</li>
<li>出于安全考虑，Bootstrap启动类加载器只加载包名为java，javax，sun等开头的类</li>
</ul>
<h3 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h3><ul>
<li><p>为什么要自定义类加载器</p>
<ul>
<li>隔离加载类：类的路径和名字一样时会出现冲突</li>
<li>修改类加载的方式：需要的时候进行自主修改</li>
<li>扩展加载源</li>
<li>防止源码泄露：JAVA语言容易被篡改，加密和解密</li>
</ul>
</li>
<li><p>继承ClassLoader类可以实现自己 的类加载器</p>
</li>
<li><p>继承URLClassLoader（ClassLoader子类）可以简易的实现自定义类</p>
</li>
<li><p>对于用户自定义类来说，默认使用系统类加载器进行加载</p>
</li>
</ul>
<h4 id="ClassLoader"><a href="#ClassLoader" class="headerlink" title="ClassLoader"></a>ClassLoader</h4><ul>
<li>是一个抽象类，除了引导类加载器，其他的类都继承ClassLoader实现</li>
</ul>
<h3 id="扩展类加载器-Extension-Class-Loader"><a href="#扩展类加载器-Extension-Class-Loader" class="headerlink" title="扩展类加载器  Extension Class  Loader"></a>扩展类加载器  Extension Class  Loader</h3><ul>
<li>Java语言编写，由sun.miscLauncher$ExtClassLoader实现</li>
<li>派生于ClassLoader类</li>
<li>父类加载器为启动类加载器</li>
<li>从java.ext.dirs系统属性所指定的目录中加载库类，或从JDK的安装目录的jre/lib/ext子目录下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载</li>
</ul>
<h3 id="应用程序类加载器-AppClassLoader"><a href="#应用程序类加载器-AppClassLoader" class="headerlink" title="应用程序类加载器 AppClassLoader"></a>应用程序类加载器 AppClassLoader</h3><ul>
<li>JAVA语言编写</li>
<li>派生于ClassLoader类</li>
<li>父类加载器为启动类加载器</li>
<li>负责加载环境变量classpath或系统属性java.class.path指定路径下的类库</li>
<li>该类加载时程序中默认的类加载器，一般来说，Java应用的类都是由它来完成加载</li>
</ul>
<h3 id="获取类加载器的代码"><a href="#获取类加载器的代码" class="headerlink" title="获取类加载器的代码"></a>获取类加载器的代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader sysClassloader = ClassLoader.getSystemClassLoader();<span class="comment">//获取系统类加载器</span></span><br><span class="line">ClassLoader classloader = String<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>()</span>;<span class="comment">//获取自定义类加载器</span></span><br><span class="line">ClassLoader classloader = Class.forName(<span class="string">"java.lang.String"</span>).getClass.ClassLoader();</span><br><span class="line">ClassLoader classloader = Thread.currentThread().getContextClassLoader();</span><br><span class="line">ClassLoader classloader = ClassLoader.getSystemClassLoader().getParent();</span><br><span class="line">sout(classloader);<span class="comment">//输出</span></span><br></pre></td></tr></table></figure>

<h2 id="2-6-双亲委派机制"><a href="#2-6-双亲委派机制" class="headerlink" title="2-6 双亲委派机制"></a>2-6 双亲委派机制</h2><ul>
<li>JVM对class文件是<strong>按需加载</strong>的方式</li>
<li>如果自定义一个java.lang.String,程序也不会运行String，会用系统自带的String。<ul>
<li><strong>自定义的String</strong>是引导类完成加载的</li>
<li>由自定义到系统加载器到扩展类加载器再到引导类加载器，引导类加载器发现自己搞得定，就用java.lang.String</li>
</ul>
</li>
</ul>
<h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><ul>
<li>如果一个类加载器收到了类加载请求，他并不会自己去加载，而是吧这个请求委托给父类的加载器去执行</li>
<li>如果父类加载器还有父类加载器，则在向上一步委托</li>
<li>如果父类加载器可以完成加载，则返回成功；如果不能完成加载，自家在其才会尝试自己去加载</li>
</ul>
<p><img src="/111zx/111zx.github.io/2020/05/20/JVM/C:%5CUsers%5C14914%5CDesktop%5C%E5%9B%BE%E7%89%87%E4%B8%AD%E8%BD%AC%E7%AB%99%5CJVM%5C%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6.png" alt="双亲委派机制"></p>
<h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ul>
<li><p>避免类的重复加载</p>
</li>
<li><p>保护程序安全，防止核心API被随意串改</p>
<ul>
<li>例如自定义一个String，不会被加载</li>
<li>自己定义一个再java.lang包下类，也会出现错误，权限不够。</li>
</ul>
</li>
<li><p>实例：</p>
</li>
</ul>
<p><img src="/111zx/111zx.github.io/2020/05/20/JVM/C:%5CUsers%5C14914%5CDesktop%5C%E5%9B%BE%E7%89%87%E4%B8%AD%E8%BD%AC%E7%AB%99%5CJVM%5C%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6%E4%BE%8B%E5%AD%90.png" alt></p>
<ul>
<li>rt.jar核心API由进到类加载器加载。（加载接口）</li>
<li>接口的实现类由系统类加载器（线程上下文类加载器）进行加载。</li>
</ul>
<h4 id="沙箱安全机制"><a href="#沙箱安全机制" class="headerlink" title="沙箱安全机制"></a>沙箱安全机制</h4><ul>
<li>对核心API代码的机制，就是沙箱机制<ul>
<li>在java.lang包下编辑代码，或者自定义核心类的代码，都会出现异常。</li>
</ul>
</li>
</ul>
<h4 id="JVM内两个class对象是否相同的条件"><a href="#JVM内两个class对象是否相同的条件" class="headerlink" title="JVM内两个class对象是否相同的条件"></a>JVM内两个class对象是否相同的条件</h4><ul>
<li>类的完整名相同</li>
<li>类的加载器相同</li>
</ul>
<h4 id="对类加载器的引用"><a href="#对类加载器的引用" class="headerlink" title="对类加载器的引用"></a>对类加载器的引用</h4><ul>
<li><strong>JVM必须知道一个类是由启动类加载器还是由用户类加载器加载的。如果一个类型是由用户类加载器加载的，那么JVM会将这个类加载器的一个引用作为类型信息保存在方法区中</strong></li>
<li>当解析一个类到另一个类的引用时，JVM需要保证这两个类型的类加载器是一样的</li>
</ul>
<h4 id="类的使用"><a href="#类的使用" class="headerlink" title="类的使用"></a>类的使用</h4><ul>
<li>区别：主动使用执行了类的加载的Initialization阶段，而被动加载不会。</li>
</ul>
<h5 id="主动使用"><a href="#主动使用" class="headerlink" title="主动使用"></a>主动使用</h5><ul>
<li>创建类的实例</li>
<li>访问接口或类中的静态变量</li>
<li>调用静态方法</li>
<li>反射</li>
<li>初始化一个类的子类</li>
<li>JVM启动时被标明为启动类的类</li>
<li>jdk7开始提供的动态语言支持</li>
</ul>
<h5 id="被动使用"><a href="#被动使用" class="headerlink" title="被动使用"></a>被动使用</h5><ul>
<li>其余的都是被动</li>
</ul>
<h1 id="第三章-运行时数据区"><a href="#第三章-运行时数据区" class="headerlink" title="第三章 运行时数据区"></a>第三章 运行时数据区</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><ul>
<li>不同的虚拟机内存不同</li>
</ul>
<p><img src="/111zx/111zx.github.io/2020/05/20/JVM/C:%5CUsers%5C14914%5CDesktop%5C%E5%9B%BE%E7%89%87%E4%B8%AD%E8%BD%AC%E7%AB%99%5CJVM%5CJVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA.png" alt></p>
<ul>
<li>线程结束，一个程序生命周期结束</li>
<li>方法区和堆区表示进程的资源</li>
<li>线程独有的：程序计数器，本地栈，虚拟机栈</li>
<li>一个Runtime的实例有一份运行时数据区</li>
</ul>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><ul>
<li>守护线程</li>
<li>每个JVM线程对应一个本地线程</li>
<li>如果程序中只剩下守护线程，就可以结束生命周期了</li>
<li>JVM系统线程<ul>
<li>虚拟机线程</li>
<li>GC线程</li>
<li>编译线程</li>
<li>信号调度线程</li>
<li>周期任务线程</li>
</ul>
</li>
</ul>
<h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><h3 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h3><ul>
<li><p>Program Counter Register(程序钩子)</p>
<ul>
<li>是对物理PC寄存器的一种抽象模拟</li>
</ul>
</li>
<li><p>作用:PC寄存器用开存储下一条指令的地址，也即将要执行的指令代码。有执行引擎读取下一条指令。</p>
</li>
<li><p>每个线程独有一份</p>
</li>
<li><p>是一块很小的内存空间，几乎可以忽略不记，运行速度快</p>
</li>
<li><p>任何时间每个线程都只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前方法的JVM指令；或者，如果时本地方法（C语言实现的，无法显示），则是未指定值。</p>
</li>
<li><p>字节码解释器工作时就是通过改变这个计数器的值来选取下一跳需要执行的指令</p>
</li>
<li><p>唯一一块JVM规范中没有任何OutOtMemoryError（OOM）情况的区域</p>
</li>
<li><p>栈不考虑垃圾回收，有OOM</p>
</li>
<li><p>堆区有垃圾回收，有OOM</p>
</li>
<li><p>寄存器没有垃圾回收，没有OOM</p>
</li>
</ul>
<h3 id="2-PC寄存器流程"><a href="#2-PC寄存器流程" class="headerlink" title="2. PC寄存器流程"></a>2. PC寄存器流程</h3><p><img src="/111zx/111zx.github.io/2020/05/20/JVM/C:%5CUsers%5C14914%5CDesktop%5C%E5%9B%BE%E7%89%87%E4%B8%AD%E8%BD%AC%E7%AB%99%5CJVM%5CPC%E5%AF%84%E5%AD%98%E5%99%A8%E6%B5%81%E7%A8%8B.png" alt></p>
<h4 id="常见面试问题"><a href="#常见面试问题" class="headerlink" title="常见面试问题"></a>常见面试问题</h4><ol>
<li><p>使用PC寄存器存储字节码指令地址有什么作用？</p>
<p>CPU不停地切换线程，在来回切换地时候需要PC寄存器来保存执行到了哪里，下一条指令从哪里开始。</p>
</li>
<li><p>PC寄存器为什么被设置为线程私有的？</p>
<p>每个线程执行到的位置都是不同的，PC寄存器记录的是线程下一条指令的位置，设置成一个PC寄存器，会出现混乱。</p>
</li>
</ol>
<h2 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><ul>
<li>出现背景：由于跨平台的设计，Java指令都是根据栈来设计的。不同平台CPU架构不同，所以不能设计基于寄存器的。</li>
<li>优点：跨平台，指令集小，编译器容易实现</li>
<li>缺点：性能下降，实现同样功能的指令复杂多样</li>
<li>为什么人们提到jvm内存结构只有堆和栈<ul>
<li>首先是错误的，不全面的</li>
<li>说明栈和堆比较重要</li>
<li>栈解决程序的运行问题，即程序如何运行，或者说如何处理数据</li>
<li>堆解决的是数据存储的问题，即数据怎么放，放在哪</li>
</ul>
</li>
<li>通常堆空间是运行时空间比较大的一部分</li>
<li>每一个线程都会有一个虚拟机栈，内部保存的是一个个的栈帧<ul>
<li>每个栈帧对应一个java方法</li>
</ul>
</li>
<li>是线程私有的</li>
<li>生命周期随线程的消失而消失，生成而产生</li>
</ul>
<h4 id="2-作用"><a href="#2-作用" class="headerlink" title="2. 作用"></a>2. 作用</h4><ul>
<li>主管程序的运行，保存方法的局部变量（8种基本数据类型，对象的引用地址），部分结果，并参与方法的调用和返回<ul>
<li>局部变量 vs 成员变量</li>
<li>基本数据变量 vs 引用数据变量</li>
</ul>
</li>
</ul>
<h4 id="3-栈的优点"><a href="#3-栈的优点" class="headerlink" title="3. 栈的优点"></a>3. 栈的优点</h4><ul>
<li>仅次于PC寄存器的速度</li>
<li>只有进栈和出战两个操作</li>
<li>不存在垃圾回收问题，但是有内存溢出</li>
</ul>
<h3 id="虚拟机栈的内容"><a href="#虚拟机栈的内容" class="headerlink" title="虚拟机栈的内容"></a>虚拟机栈的内容</h3><h4 id="1-栈内存什么？"><a href="#1-栈内存什么？" class="headerlink" title="1. 栈内存什么？"></a>1. 栈内存什么？</h4><ul>
<li>每个线程都有自己的栈，栈中的数据以栈帧的格式存在。</li>
<li>每个线程上执行的每个方法都各自对应一个栈帧。</li>
<li>栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。</li>
</ul>
<h4 id="2-栈运行原理"><a href="#2-栈运行原理" class="headerlink" title="2. 栈运行原理"></a>2. 栈运行原理</h4><ul>
<li><p>JVM对栈的操作只有两个，压栈和出栈。</p>
</li>
<li><p>在一条活动线程中，只会有一个活动的栈帧。</p>
<ul>
<li>当前栈帧：当前执行方法的栈帧是有效的。</li>
<li>当前方法：和当前栈桢对应的方法。</li>
<li>当前类：定义当前方法的类。</li>
</ul>
</li>
<li><p>执行引擎运行的所有字节码指令只对当前栈帧有用。</p>
</li>
<li><p>不同线程中所包含的栈帧是不允许存在相互引用的，即不可能在一个栈帧中引用另外一个线程中的栈帧。</p>
</li>
<li><p>如果当前犯法调用了其他方法，在方法返回之际，当前栈帧会传回此方法的执行结果给钱一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前线程。</p>
</li>
<li><p>Java方法有两种返回函数的方式，一种是正常的函数返回，使用return指令；另一种是抛出异常。不管是用那种方式，都会导致栈帧被弹出。</p>
<ul>
<li>如果方法中出现异常，抛出异常给上一个方法，并结束。</li>
<li>每个方法结束是以return；不加只是省略而已，并不是不存在。</li>
</ul>
</li>
</ul>
<h4 id="3-栈帧的内部结构"><a href="#3-栈帧的内部结构" class="headerlink" title="3. 栈帧的内部结构"></a>3. 栈帧的内部结构</h4><ul>
<li>局部变量表</li>
<li>操作数栈（表达式栈）</li>
<li>动态链接（指向运行时常量池的方法引用）</li>
<li>方法返回地址（正常退出或异常退出）</li>
<li>一些附加信息</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/111zx/111zx.github.io/2020/05/20/JVM/" data-id="ckbbzdvti000kt8ub32pq3ajf" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-线程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/18/%E7%BA%BF%E7%A8%8B/" class="article-date">
  <time datetime="2020-05-18T08:10:51.000Z" itemprop="datePublished">2020-05-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/18/%E7%BA%BF%E7%A8%8B/">线程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><p>[TOC]</p>
<h2 id="程序，进程和线程"><a href="#程序，进程和线程" class="headerlink" title="程序，进程和线程"></a>程序，进程和线程</h2><ul>
<li><p>程序：完成特定任务，某种语言编写的一组指令的集合。是一个静态的代码</p>
</li>
<li><p>进程：程序的一次运行状态。是一个动态的过程。有它自身的产生，存在和消亡的过程</p>
</li>
<li><p>线程：进程可以划分为线程，是一个程序内部的一条执行路径。可以并行。</p>
<ul>
<li>线程拥有独立的运行<strong>栈</strong>（虚拟机栈）和<strong>程序计数器。</strong></li>
<li>方法区和堆是进程的，线程可以共享。</li>
<li>多线程运行共享同一个进程的内存单元，所以会带来<strong>安全隐患</strong>。</li>
</ul>
</li>
<li><p>单核CPU和多核CPU的区别</p>
<ul>
<li>单核：假的多线程，时间片轮流处理</li>
<li>多核：多核处理，真多线程</li>
<li>一个java.exe。至少由三个线程组成：main()主线程，gc垃圾回收线程，异常处理线程。</li>
</ul>
</li>
<li><p>并发与并行</p>
<ul>
<li>并行：多个CPU同时执行多个任务</li>
<li>并发：时间片轮流处理</li>
</ul>
</li>
<li><p>多线程的优点(以单核DPU为例)</p>
<ul>
<li>提高应用程序的响应。对图形界面更有意义，可增强用户体验。</li>
<li>提高CPU利用率</li>
<li>改善程序结构：把复杂的进程分成多个线程独立运行，立于理解</li>
</ul>
</li>
</ul>
<h2 id="线程的创建"><a href="#线程的创建" class="headerlink" title="线程的创建"></a>线程的创建</h2><h3 id="方式1-Thread"><a href="#方式1-Thread" class="headerlink" title="方式1 Thread"></a>方式1 Thread</h3><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ol>
<li>创建一个继承于Thread类的子类</li>
<li>重写Thread类的run() –&gt; 将此线程执行的操作声明在run()中</li>
<li>创建Thread类的子类的对象</li>
<li>通过此对象调用start()</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MyThread t1 = <span class="keyword">new</span> MyThread();<span class="comment">//还是主线程</span></span><br><span class="line">ti.start();<span class="comment">//创建了一个线程并调用run()方法</span></span><br><span class="line">t1.run();<span class="comment">//错误写法，不会启动当前线程，只是调用了run()方法</span></span><br><span class="line">Thread.currenThread().getName()<span class="comment">//获取线程的名字</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>start()作用</p>
<ul>
<li>启动当前线程</li>
<li>调用当前线程的run()方法</li>
</ul>
</li>
<li><p><strong>直接使用run(),不会启动当前线程，只是调用了run()方法</strong></p>
</li>
<li><p>只用一次以后不用的情况下可以用匿名子类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread()&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;.start()</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="Thread方法使用"><a href="#Thread方法使用" class="headerlink" title="Thread方法使用"></a>Thread方法使用</h4><h5 id="start"><a href="#start" class="headerlink" title="start()"></a>start()</h5><ul>
<li>启动当前线程</li>
<li>调用当前线程的run()方法</li>
</ul>
<h5 id="run"><a href="#run" class="headerlink" title="run()"></a>run()</h5><ul>
<li>通常需要去重写Thread中的类方法，完成需要执行的操作</li>
</ul>
<h5 id="setName"><a href="#setName" class="headerlink" title="setName()"></a>setName()</h5><ul>
<li>设置当前线程的name</li>
</ul>
<h5 id="currentThread"><a href="#currentThread" class="headerlink" title="currentThread()"></a>currentThread()</h5><ul>
<li>静态方法，返回当前代码执行的线程</li>
</ul>
<h5 id="getName"><a href="#getName" class="headerlink" title="getName()"></a>getName()</h5><ul>
<li>获取当前线程的name</li>
</ul>
<h5 id="yield"><a href="#yield" class="headerlink" title="yield()"></a>yield()</h5><ul>
<li><p>释放cpu使用权，<strong>不一定</strong>是放了之后就能轮到其他线程，有可能再一次抢到cpu使用权</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果被20整除，那么就放弃cpu使用权</span></span><br><span class="line"><span class="keyword">if</span>(i % <span class="number">20</span> == <span class="number">0</span>)&#123;</span><br><span class="line">    yield();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h5><ul>
<li><p>线程a中调用线程b的join()方法，线程a就会进入阻塞状态，等线程b彻底执行完，a才开始进行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//两个线程，再a中调用b的join，a阻塞</span></span><br><span class="line"><span class="keyword">if</span>( i == <span class="number">20</span> )&#123;</span><br><span class="line">    b.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="stop"><a href="#stop" class="headerlink" title="stop()"></a>stop()</h5><ul>
<li>强制结束线程的生命周期,已经过时。</li>
</ul>
<h5 id="sleep"><a href="#sleep" class="headerlink" title="sleep()"></a>sleep()</h5><ul>
<li><p>阻塞n秒，结束后等到分配到cpu才开始执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sleep(<span class="number">1000</span>)<span class="comment">//阻塞1s</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="isAlive"><a href="#isAlive" class="headerlink" title="isAlive()"></a>isAlive()</h5><ul>
<li>判断线程是否存活</li>
<li>run()执行完线程才结束</li>
</ul>
<h3 id="线程的调度"><a href="#线程的调度" class="headerlink" title="线程的调度"></a>线程的调度</h3><ul>
<li><p>抢占式</p>
</li>
<li><p>时间片</p>
</li>
</ul>
<h4 id="调度方法"><a href="#调度方法" class="headerlink" title="调度方法"></a>调度方法</h4><ul>
<li>同优先级使用时间片测率</li>
<li>高优先级采用抢占式</li>
</ul>
<h4 id="线程优先级设置"><a href="#线程优先级设置" class="headerlink" title="线程优先级设置"></a>线程优先级设置</h4><ul>
<li><p>Thread类中的常量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MAX_PRIORITY <span class="number">10</span></span><br><span class="line">MIN_PRIORITY <span class="number">1</span></span><br><span class="line">NORM_PRIORITY <span class="number">5</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>获取线程优先级</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getPriority()</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置线程优先级</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setPriority()</span><br></pre></td></tr></table></figure>
</li>
<li><p>优先级高抢到cpu的概率比低优先级高，但是不是一定会抢到cpu使用权，也有可能倍低优先级抢到。</p>
</li>
</ul>
<h3 id="方式2-Runnable"><a href="#方式2-Runnable" class="headerlink" title="方式2 Runnable"></a>方式2 Runnable</h3><h4 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h4><ol>
<li>创建一个实现了Runnable接口的类</li>
<li>实现类区实现Runnable中的抽象方法</li>
<li>创建实现类的对象</li>
<li>讲此对象作为参数传递到Thread类的构造器中，创建Thread类的对象</li>
<li>通过Thread类的对象调用start()</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MThread mR = <span class="keyword">new</span> MThread();<span class="comment">//只用实例化一次</span></span><br><span class="line">Thread th = <span class="keyword">new</span> Thread(mR);</span><br><span class="line">th.start();</span><br><span class="line">Thread th2 = <span class="keyword">new</span> Thread(mR);</span><br><span class="line">th2.start();</span><br></pre></td></tr></table></figure>

<ul>
<li>start()<ul>
<li>调用的是Thread类里面的run()<ul>
<li>如果是用Runnable实例化的Thread类，那么源码中的target不为空，就直接调用target.run()</li>
<li>target是Thread类里面的属性，所以说是调用的Thread的run方法</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="两种方式的比较"><a href="#两种方式的比较" class="headerlink" title="两种方式的比较"></a>两种方式的比较</h4><ul>
<li>Thread需要继承，而java只能由单继承，有限制</li>
<li>Runnable实现接口，限制少</li>
<li><strong>共享数据比较适合Runnable</strong></li>
<li>优先使用Runnable</li>
</ul>
<h2 id="抢票代码"><a href="#抢票代码" class="headerlink" title="抢票代码"></a>抢票代码</h2><h3 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h3><ul>
<li>需要使用static，实例化了三次Thread，内存中有三个tickets</li>
</ul>
<h3 id="Runnable"><a href="#Runnable" class="headerlink" title="Runnable"></a>Runnable</h3><ul>
<li>不需要使用static，只实例化了一次Runnable</li>
</ul>
<h2 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h2><ul>
<li>创建：new</li>
<li><strong>就绪</strong>：start(),等待CPU分配，并不是直接运行</li>
<li>运行：获得CPU，执行一会后失去CPU执行权yield()，又回到就绪态，并<strong>不是阻塞</strong></li>
<li><strong>阻塞</strong>：<ul>
<li>CPU被临时终止，进入阻塞状态sleep();join()</li>
<li>阻塞到就绪：<ul>
<li>sleep时间到</li>
<li>join结束</li>
<li>获取同步锁</li>
<li>notify() notifyAll()</li>
<li>resume()结束挂起状态</li>
</ul>
</li>
<li>阻塞不会到死亡</li>
<li>阻塞一般会回到就绪，才回到运行</li>
<li>等待同步锁</li>
<li>过时的方法suspend()：线程挂起，可能会导致死锁，背淘汰</li>
</ul>
</li>
<li>死亡：<ul>
<li>完成工作run()结束</li>
<li>被强行终止stop()</li>
<li>出现异常并且不处理</li>
</ul>
</li>
</ul>
<h2 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h2><h3 id="问题的提出"><a href="#问题的提出" class="headerlink" title="问题的提出"></a>问题的提出</h3><ul>
<li>在判断并且获取<strong>临界区</strong>的过程和实际操作<strong>完</strong>写回数据库中是有一段<strong>时间差</strong>的，在这个时间差，很难导致数据同步，很不稳定。</li>
</ul>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li>在临界区时，相当于单线程，所以效率低。但是满足了需求。</li>
</ul>
<h3 id="问题的解决"><a href="#问题的解决" class="headerlink" title="问题的解决"></a>问题的解决</h3><ul>
<li><p>思想：加锁</p>
</li>
<li><p>在JAVA中，通过同步机制解决</p>
<ul>
<li><p>同步代码块</p>
<ul>
<li>临界区内代码最好是<strong>最小的同步代码块</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">synchronized</span>(同步监视器)&#123;</span><br><span class="line">     <span class="comment">//临界区</span></span><br><span class="line"> &#125;</span><br><span class="line">同步监视器（锁）：任何一个类的对象都可以充当锁</span><br></pre></td></tr></table></figure>
</li>
<li><p>同步监视器（锁）：任何一个类的对象都可以充当锁。</p>
<ul>
<li><strong>要求多个线程共用同一把锁</strong></li>
<li>this表示的是当前对象，可以作为同步监视器</li>
<li>当前类.class可以表示一个对象，<strong>类也是对象</strong>。</li>
</ul>
</li>
<li><p>在继承Thread解决同步问题需要static保证使用同一资源和同一把锁</p>
</li>
<li><p>同步方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">        show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> sychronized <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;<span class="comment">//默认同步监视器是this，继承Thread类的不适用，只能设置成静态的，同步监视器变成了当前类.class</span></span><br><span class="line">	<span class="comment">//临界区</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>非静态的同步方法，同步监视器是：this</p>
</li>
<li><p>静态的同步方法，同步监视器是：当前类.class</p>
</li>
</ul>
</li>
</ul>
<h3 id="懒汉式安全模式"><a href="#懒汉式安全模式" class="headerlink" title="懒汉式安全模式"></a>懒汉式安全模式</h3><ul>
<li><p>使用同步机制，将单例模式中的懒汉式改为同步安全的。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下两种的区别</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bank <span class="title">getInstance</span><span class="params">()</span></span>&#123;<span class="comment">//效率低，全部都要等，进去之后才知道是不是空</span></span><br><span class="line">    sychronized(<span class="keyword">this</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">        instance = <span class="keyword">new</span> Bank();</span><br><span class="line">    &#125;</span><br><span class="line">            <span class="keyword">return</span> instance;<span class="comment">//位置在同步代码块里面</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bank <span class="title">getInstance</span><span class="params">()</span></span>&#123;<span class="comment">//效率高，进去之前知道是不是空</span></span><br><span class="line">    <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">    sychronized(<span class="keyword">this</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">        instance = <span class="keyword">new</span> Bank();</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">                    <span class="keyword">return</span> instance;<span class="comment">//位置在同步代码块外面，如果没有进同步代码块之前就知道不是null，直接return</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="四个必要条件"><a href="#四个必要条件" class="headerlink" title="四个必要条件"></a>四个必要条件</h3><ul>
<li>互斥</li>
<li>互相不剥夺</li>
<li>循环等待</li>
<li>请求与保持</li>
</ul>
<h2 id="LOCK锁解决线程安全问题"><a href="#LOCK锁解决线程安全问题" class="headerlink" title="LOCK锁解决线程安全问题"></a>LOCK锁解决线程安全问题</h2><ul>
<li><p>5.0新增</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ReentrantLock lock = <span class="keyword">new</span> ReentranLock();<span class="comment">//参数为true,就是先进先出，轮着打印；如果时flase，就是谁抢到CPU谁来</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在同步代码前,等同于同步检测器被设置为禁止进入</span></span><br><span class="line">lock.lock();</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行完释放，一般用try finally</span></span><br><span class="line">lock.unlock();</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="lock和sychronized的区别"><a href="#lock和sychronized的区别" class="headerlink" title="lock和sychronized的区别"></a>lock和sychronized的区别</h2><ol>
<li>lock需要自己释放，sychronized同步代码执行完自动释放</li>
</ol>
<h2 id="同步方法选择"><a href="#同步方法选择" class="headerlink" title="同步方法选择"></a>同步方法选择</h2><ol>
<li><p>Lock</p>
</li>
<li><p>同步代码块</p>
</li>
<li><p>同步方法  </p>
</li>
</ol>
<h2 id="线程的通信"><a href="#线程的通信" class="headerlink" title="线程的通信"></a>线程的通信</h2><h3 id="1-交替打印"><a href="#1-交替打印" class="headerlink" title="1. 交替打印"></a>1. 交替打印</h3><ul>
<li>wait()方法：使得调用的方法进入阻塞状态，<strong>会释放锁</strong><ul>
<li>sleep()<strong>不会释放锁</strong></li>
</ul>
</li>
<li>notify():唤醒一个阻塞线程（优先级最高的一个线程）</li>
<li>notifyAll():唤醒所有阻塞线程</li>
<li>这3种方法只能在同步代码块或者同步方法中，在lock中不能使用。</li>
<li>这三种方法的使用对象是同步监视器，在java.lang.Object类中。</li>
</ul>
<h2 id="sleep-和wait"><a href="#sleep-和wait" class="headerlink" title="sleep()和wait()"></a>sleep()和wait()</h2><ul>
<li>相同点<ol>
<li>都可以让线程进入阻塞状态</li>
</ol>
</li>
<li>不同点<ol>
<li>Thread类中的sleep，Object类中的wait()</li>
<li>Sleep可以在任何需要的情况下调用，wait()只能在同步方法块和同步代码块中</li>
<li>如果两个方法都是用在同步代码块或者同步方法中，sleep()不释放同步监视器，wait()释放同步监视器</li>
</ol>
</li>
</ul>
<h2 id="生产者消费者问题"><a href="#生产者消费者问题" class="headerlink" title="生产者消费者问题"></a>生产者消费者问题</h2><ol>
<li>多个线程：生产，消费</li>
<li>共享数据：产品</li>
<li>进程通信：生产者在生产了产品之后消费者才能买，而消费者将满仓库的产品买了之后生产者才能继续生产</li>
<li>线程安全问题：有可能在生产和消费的同时数据没同步，出现了数据丢失的现象</li>
</ol>
<h2 id="Callable接口"><a href="#Callable接口" class="headerlink" title="Callable接口"></a>Callable接口</h2><h3 id="相比Runnable的优点"><a href="#相比Runnable的优点" class="headerlink" title="相比Runnable的优点"></a>相比Runnable的优点</h3><ol>
<li>相比run(),可以得到返回值</li>
<li>方法可以抛出异常</li>
<li>支持泛型的返回值</li>
<li>需要借助一个类Future Task接口</li>
</ol>
<h3 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h3><ul>
<li><p>创建一个实现Callable的实现类</p>
</li>
<li><p>对比run(),实现call()：可以返回有值，可以抛出异常</p>
</li>
<li><p>FutrueTask实现的的Futrue接口,将实现Callable类的对象传递到FutrueTask的构造器中，创建FutrueTask的对象</p>
</li>
<li><p>将实现FutrueTask类的对象传递到Thread构造器中，创建Thread对象，并调用start()方法。</p>
</li>
<li><p>获取call方法中的返回值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">futuretask.get()</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li>加载网页页面的时候每个图片一个线程，加载后结束生命周期。</li>
</ul>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul>
<li>提前创建好很多线程，放入线程池，使用时直接获取，结束后放回池中，可以避免销毁创建造成的开销。</li>
</ul>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>提高相应速度</li>
<li>降低资源消耗</li>
<li>便于线程管理<ul>
<li>corePoolSize：核心池的大小</li>
<li>maxximumPoolSize：最大线程数</li>
<li>keepAliveTime：线程没有任务最长可以保持多长时间</li>
</ul>
</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h4 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService service = Executors.newFixedThreadPool(<span class="number">10</span>);<span class="comment">//创建10个大小线程池</span></span><br><span class="line">service.execute();<span class="comment">//适用于Runnable</span></span><br><span class="line">service.submit();<span class="comment">//适用于Callable</span></span><br><span class="line">service.shutdown();<span class="comment">//结束线程池</span></span><br></pre></td></tr></table></figure>

<h4 id="管理线程池"><a href="#管理线程池" class="headerlink" title="管理线程池"></a>管理线程池</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">service.getClass();<span class="comment">//获取service的实现的类</span></span><br><span class="line">ThreadPoolExecutor service = Executors.newFixedThreadPool(<span class="number">10</span>);<span class="comment">//ExecutorService是一个接口，ThreadPoolExecutor才是实现类，所以要管理的话需要ThreadPoolExecutor</span></span><br><span class="line">service.setkeepAliveTime();</span><br><span class="line">service.maxximumPoolSize();</span><br><span class="line">service.corePoolSize();</span><br></pre></td></tr></table></figure>

<h1 id="JUC"><a href="#JUC" class="headerlink" title="JUC"></a>JUC</h1><h2 id="1-Java内存模型"><a href="#1-Java内存模型" class="headerlink" title="1. Java内存模型"></a>1. Java内存模型</h2><h3 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1-1. 概述"></a>1-1. 概述</h3><ul>
<li>每一个线程都有一个自己的工作内存，里面存的是从主内存取来的共享变量副本</li>
</ul>
<h3 id="1-2-JMM数据原子操作"><a href="#1-2-JMM数据原子操作" class="headerlink" title="1-2. JMM数据原子操作"></a>1-2. JMM数据原子操作</h3><ul>
<li>read():从主存中读取数据</li>
<li>load():将主存读取到的数据写入工作内存</li>
<li>use():从工作内存读取数据来计算</li>
<li>assign():将计算好得知重新复制到工作内存里</li>
<li>store():将工作内存数据写入主存</li>
<li>write():将store过去的变量值赋值给主内存中的变量</li>
<li>lock()：将主内存变量加锁，表示为线程独占状态</li>
<li>unlock()：将主内存变量解锁，解锁后其他线程可以锁定该变量</li>
</ul>
<h3 id="1-3-总线枷锁（性能低，被淘汰）"><a href="#1-3-总线枷锁（性能低，被淘汰）" class="headerlink" title="1-3. 总线枷锁（性能低，被淘汰）"></a>1-3. 总线枷锁（性能低，被淘汰）</h3><ul>
<li>实现了数据同步，但是并行改变为串行，性能变低</li>
</ul>
<h3 id="1-4-MESI缓存一致性协议"><a href="#1-4-MESI缓存一致性协议" class="headerlink" title="1-4. MESI缓存一致性协议"></a>1-4. MESI缓存一致性协议</h3><ul>
<li>CPU的总线监听机制，如果发现总线上的变量变动后，会将自己线程内的相应变量失效掉</li>
<li>当数据失效后，CPU只能从主内存中read，load变量。</li>
</ul>
<h2 id="2-volatitle-内存可见性实现原理"><a href="#2-volatitle-内存可见性实现原理" class="headerlink" title="2. volatitle 内存可见性实现原理"></a>2. volatitle 内存可见性实现原理</h2><ul>
<li><p>volatitle是C语言实现的</p>
</li>
<li><p>通过一个lock前缀指令（和lock原子操作不同，会触发cpu发生lock原子操作），会锁定这块内存区域的缓存并写回内存</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock add dword ptr [rsp(寄存器)]</span><br></pre></td></tr></table></figure>
</li>
<li><p>lock前缀指令：</p>
<ul>
<li>会开启CPU监听机制</li>
<li>会将处理器缓存行的数据<strong>立即</strong>写回到主内存，以保证线程的共享数据的一致性</li>
<li>这个协会内存的操作会引起其他线程共享变量副本数据的无效</li>
</ul>
</li>
</ul>
<h2 id="并发编程的三大特性"><a href="#并发编程的三大特性" class="headerlink" title="并发编程的三大特性"></a>并发编程的三大特性</h2><ul>
<li>可见性</li>
<li>原子性<ul>
<li>volatile不能保证变量的原子性，需要使用sychronized同步机制<ul>
<li>在写写操作时会出现错误</li>
</ul>
</li>
</ul>
</li>
<li>有序性</li>
</ul>
<h2 id="原子变量与CAS算法"><a href="#原子变量与CAS算法" class="headerlink" title="原子变量与CAS算法"></a>原子变量与CAS算法</h2><ul>
<li>volatile保证内存可见性，可以通过原子变量解决，CAS算法(比sychronized效率高)能保证数据的原子性。</li>
<li>AtomicInterger关键字声明int变量</li>
<li>CAS包含了三个操作数<ul>
<li>内存值V</li>
<li>预估值A</li>
<li>更新值B</li>
<li>当且仅当V == A时，V == B,否则，不操作，但不放弃CPU操作，再去尝试。</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/111zx/111zx.github.io/2020/05/18/%E7%BA%BF%E7%A8%8B/" data-id="ckbbzdvsy000ht8ubh067h5j7" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-软件体系结构" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/14/%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/" class="article-date">
  <time datetime="2020-05-14T02:04:22.000Z" itemprop="datePublished">2020-05-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/14/%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/">软件体系结构</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="第一章-软件体系结构风格"><a href="#第一章-软件体系结构风格" class="headerlink" title="第一章 软件体系结构风格"></a>第一章 软件体系结构风格</h1><ul>
<li><p>软件体系结构风格图谱</p>
<p><img src="/111zx/111zx.github.io/2020/05/14/%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/C:%5CUsers%5C14914%5CDesktop%5C%E5%9B%BE%E7%89%87%E4%B8%AD%E8%BD%AC%E7%AB%99%5C%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0%5C%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E9%A3%8E%E6%A0%BC.png" alt></p>
</li>
</ul>
<h2 id="1-数据流体系结构"><a href="#1-数据流体系结构" class="headerlink" title="1. 数据流体系结构"></a>1. 数据流体系结构</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul>
<li>系统模块之间传递的数据：数据流</li>
<li>无数据时不工作，数据到达时即被激活</li>
</ul>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li>数据的可用性决定着处理计算单元是否进行</li>
<li>系统结构由数据在各处理之间的有序移动决定</li>
<li>在纯数据流系统中，处理之间除了数据交换外没有任何其他的交互</li>
</ul>
<h3 id="基本构件"><a href="#基本构件" class="headerlink" title="基本构件"></a>基本构件</h3><ul>
<li>数据处理单元<ul>
<li>输入端口：读取数据，在计算单元内计算，传给输出端口</li>
<li>输出端口：输出数据</li>
</ul>
</li>
<li>连接件：数据流<ul>
<li>连接两个数据处理单元，通常是<strong>异步，有缓冲</strong></li>
<li>由reader和writer</li>
<li>把一个数据单元的输出接口和下一个的输入端口连接</li>
</ul>
</li>
<li>-数据流动模式<ul>
<li>自由流动（非常容易造成死锁，一般不是刻意用数据流体系结构风格完成的）</li>
<li><strong>近似线性流动</strong>（这种流动是正确的数据流风格选择）</li>
<li>在限定内循环数据流</li>
</ul>
</li>
</ul>
<h3 id="批处理风格"><a href="#批处理风格" class="headerlink" title="批处理风格"></a>批处理风格</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><ul>
<li>每个步骤完成计算之后，把所有<strong>完整</strong>的数据拷贝到一个载体上，传给下一个步骤，循环。</li>
<li>每一步必须全部完成才可以进行下一步</li>
<li>每一步是独立的应用程序</li>
<li>数据必须完整传输</li>
</ul>
<h4 id="基本构件-1"><a href="#基本构件-1" class="headerlink" title="基本构件"></a>基本构件</h4><ul>
<li>独立的应用程序</li>
</ul>
<h4 id="连接件"><a href="#连接件" class="headerlink" title="连接件"></a>连接件</h4><ul>
<li>某种类型的媒介</li>
</ul>
<h4 id="拓扑关系"><a href="#拓扑关系" class="headerlink" title="拓扑关系"></a>拓扑关系</h4><ul>
<li>连接件所定义的数据流图，表达拓扑关系</li>
</ul>
<h4 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h4><ul>
<li>基于Eclipse的代码重复检测工具<img src="/111zx/111zx.github.io/2020/05/14/%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/C:%5CUsers%5C14914%5CDesktop%5C%E5%9B%BE%E7%89%87%E4%B8%AD%E8%BD%AC%E7%AB%99%5C%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0%5C%E6%89%B9%E5%A4%84%E7%90%86.png" alt="基于Eclipse的代码重复检测工具"><ul>
<li>代码分析：两个源代码</li>
<li>程序转换：抽象语法树</li>
<li>相似代码检测：P—String文件</li>
<li>相似代码显示：结果文件</li>
<li>度量分析</li>
</ul>
</li>
</ul>
<h3 id="管道-过滤器风格"><a href="#管道-过滤器风格" class="headerlink" title="管道-过滤器风格"></a>管道-过滤器风格</h3><h4 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h4><ul>
<li>不需要把整体的数据传输。例如：自来水处理，边处理边传输</li>
<li>数据原点产生数据后在不同的过滤器过滤之后传给下一个步骤</li>
</ul>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><ul>
<li>数据源源不断产生，系统需要对这些数据进行若干个步骤的处理（分析，计算，转换等）</li>
</ul>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><ol>
<li>把系统分解为几个处理步骤，每个处理步骤之间由数据流链接，一个步骤的输出是另一个步骤的输入</li>
<li>每个步骤是一个<strong>过滤器</strong></li>
<li>步骤之间数据的传输是<strong>管道</strong></li>
</ol>
<h4 id="基本构件-2"><a href="#基本构件-2" class="headerlink" title="基本构件"></a>基本构件</h4><ul>
<li>过滤器<ul>
<li>目标：将接收到的数据流转换成目标数据流</li>
<li>5种转变类型<ul>
<li>计算和增加信息</li>
<li>浓缩和删减信息</li>
<li>改变数据的表现方式</li>
<li>分解数据流</li>
<li>合并数据流</li>
</ul>
</li>
<li>过滤器是<strong>独立的构件</strong><ul>
<li>上下文无关</li>
<li>不保留任何数据的状态</li>
<li>对其他过滤器无任何了解</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="连接件-1"><a href="#连接件-1" class="headerlink" title="连接件"></a>连接件</h4><ul>
<li>管道<ul>
<li>目标：运输数据流</li>
<li>单向流</li>
<li>可能有缓冲区</li>
<li>管道之间的数据格式不固定（有没有可能带来什么问题？）</li>
</ul>
</li>
</ul>
<h4 id="拓扑关系-1"><a href="#拓扑关系-1" class="headerlink" title="拓扑关系"></a>拓扑关系</h4><ul>
<li>管道和基本构件形成的数据流图</li>
</ul>
<h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ul>
<li>递增的读取和消费数据流，数据有便处理，处理完数据即传输，不需要等待</li>
<li>隐蔽性，高内聚，低耦合</li>
<li>支持软件复用</li>
<li>系统的维护和增强系统性能简单</li>
<li>支持并行</li>
<li>允许对吞吐量，死锁等属性的分析</li>
<li>缺点<ul>
<li>不适合处理交互的应用</li>
<li>系统性能不高，并增加了编写过滤器的复杂性<ul>
<li>绝大部分时间消耗在了格式转换上</li>
<li>不适用大量共享数据的应用设置</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="批处理和管道-过滤器对比"><a href="#批处理和管道-过滤器对比" class="headerlink" title="批处理和管道-过滤器对比"></a>批处理和管道-过滤器对比</h3><h4 id="共同点"><a href="#共同点" class="headerlink" title="共同点"></a>共同点</h4><ul>
<li>都是分解任务为固定计算单元</li>
<li>每个计算单元之间的交互都<strong>只有数据的传输</strong></li>
</ul>
<h4 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h4><p><img src="/111zx/111zx.github.io/2020/05/14/%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/C:%5CUsers%5C14914%5CDesktop%5C%E5%9B%BE%E7%89%87%E4%B8%AD%E8%BD%AC%E7%AB%99%5C%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0%5C%E6%89%B9%E5%A4%84%E7%90%86vs%E7%AE%A1%E9%81%93%E8%BF%87%E6%BB%A4%E5%99%A8.png" alt="批处理和管道-过滤器对比"></p>
<h2 id="2-调用返回体系结构风格"><a href="#2-调用返回体系结构风格" class="headerlink" title="2. 调用返回体系结构风格"></a>2. 调用返回体系结构风格</h2><h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h3><ul>
<li>主程序/子程序风格<ul>
<li>单线程控制，划分为若干处理步骤</li>
<li>功能模块：把步骤聚集再模块中</li>
</ul>
</li>
<li>抽象数据类型<ul>
<li>数据和操作绑定在一起，隐藏实现和其他秘密</li>
</ul>
</li>
<li>面向对象<ul>
<li>对象活动与不同的线程和进程</li>
<li>方法（动态绑定），多态（子类），重用（继承）</li>
</ul>
</li>
</ul>
<h4 id="适合的场景"><a href="#适合的场景" class="headerlink" title="适合的场景"></a>适合的场景</h4><ul>
<li>有层次化，可以分解的应用系统</li>
</ul>
<h4 id="上下文"><a href="#上下文" class="headerlink" title="上下文"></a>上下文</h4><ul>
<li>主流编程语言都支撑风格</li>
</ul>
<h4 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h4><ul>
<li><p>组件内部的数据和功能都是可见的</p>
</li>
<li><p>过程调用</p>
</li>
<li><p>单线程</p>
</li>
</ul>
<h3 id="模块分解"><a href="#模块分解" class="headerlink" title="模块分解"></a>模块分解</h3><ul>
<li>功能实现在模块内部，外部不知道内部的变化</li>
</ul>
<h3 id="封装-信息隐藏"><a href="#封装-信息隐藏" class="headerlink" title="封装/信息隐藏"></a>封装/信息隐藏</h3><ul>
<li>自己负责状态的一致性</li>
<li>通过接口访问</li>
<li>模板</li>
<li>以一种可以控制的状态允许修改</li>
</ul>
<h3 id="数据抽象-面向对象"><a href="#数据抽象-面向对象" class="headerlink" title="数据抽象/面向对象"></a>数据抽象/面向对象</h3><ul>
<li>去中心化</li>
</ul>
<h4 id="面向对象体系结构的元素"><a href="#面向对象体系结构的元素" class="headerlink" title="面向对象体系结构的元素"></a>面向对象体系结构的元素</h4><ul>
<li>封装</li>
<li>交互</li>
<li>多态</li>
<li>继承：共享的功能保持唯一的接口</li>
<li>复用和维护：利用封装和聚合提高生产力</li>
</ul>
<h4 id="面向对象的问题"><a href="#面向对象的问题" class="headerlink" title="面向对象的问题"></a>面向对象的问题</h4><ul>
<li>对象海洋需要额外的结构来容纳</li>
<li>单个接口有限且笨拙</li>
</ul>
<h5 id="如何管理大的对象数据集"><a href="#如何管理大的对象数据集" class="headerlink" title="如何管理大的对象数据集"></a>如何管理大的对象数据集</h5><ul>
<li>等级制度</li>
</ul>
<h3 id="层次风格"><a href="#层次风格" class="headerlink" title="层次风格"></a>层次风格</h3><h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><ul>
<li>操作系统<ul>
<li>应用平台，应用，操作系统</li>
</ul>
</li>
<li>计算机网络<ul>
<li>计算机网络7层结构</li>
</ul>
</li>
</ul>
<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><ul>
<li>层次划分明显</li>
</ul>
<h4 id="上下文-1"><a href="#上下文-1" class="headerlink" title="上下文"></a>上下文</h4><ul>
<li>每一类具有相同的结构放在一起</li>
</ul>
<h4 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h4><ul>
<li>单线程</li>
<li>过程调用</li>
</ul>
<h4 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h4><ul>
<li>每层为上一层提供服务，只能看到和自己邻接的层<ul>
<li>必要时可以允许一层的跃层</li>
</ul>
</li>
<li>大的问题分解为若干小问题，逐步解决，隐藏复杂度</li>
<li>修改一层，最多影响2层，而通常之影响上层。接口稳固，则谁都不影响</li>
<li>上层必须知道下层的身份，不能调整层次之间的顺序</li>
<li>层层相调，影响性能</li>
</ul>
<h3 id="C-S架构"><a href="#C-S架构" class="headerlink" title="C/S架构"></a>C/S架构</h3><h4 id="两层C-S（胖客户机）"><a href="#两层C-S（胖客户机）" class="headerlink" title="两层C/S（胖客户机）"></a>两层C/S（胖客户机）</h4><h5 id="组成部分"><a href="#组成部分" class="headerlink" title="组成部分"></a>组成部分</h5><ul>
<li>服务器主要存储数据库</li>
<li>客户端负责业务逻辑</li>
<li>网络</li>
</ul>
<h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ul>
<li>客户端配置要求高，程序复杂</li>
<li>客户端可以直接访问数据库，不安全</li>
<li>用户界面风格不一，不利于推广</li>
<li>软件维护和升级困难，每个客户端都要维护升级</li>
</ul>
<h4 id="三层C-S（瘦客户机）"><a href="#三层C-S（瘦客户机）" class="headerlink" title="三层C/S（瘦客户机）"></a>三层C/S（瘦客户机）</h4><h5 id="组成部分-1"><a href="#组成部分-1" class="headerlink" title="组成部分"></a>组成部分</h5><ul>
<li>服务器主要存储数据库：数据层</li>
<li>客户端负责不再业务逻辑，只是一个展示的作用：展示层</li>
<li>应用服务器负责业务逻辑：功能层</li>
</ul>
<h4 id="B-S"><a href="#B-S" class="headerlink" title="B/S"></a>B/S</h4><ul>
<li>客户端只能从客户端拉数据而不能向服务器推数据。</li>
<li>安全性难控制（SQL注入）</li>
</ul>
<h2 id="3-数据中心体系结构风格"><a href="#3-数据中心体系结构风格" class="headerlink" title="3. 数据中心体系结构风格"></a>3. 数据中心体系结构风格</h2><h3 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h3><ul>
<li>注册表是一种数据中心体系结构风格</li>
<li>在注册表未问世之前，系统所有的硬件和配置信息都被保存在各自的配置文件中，散落在系统的各个角落，有了注册表的思想，就将配置文件集中起来存储，形成了共享仓库。</li>
<li>剪贴板也是一个数据为中心的系统，可以共享数据</li>
</ul>
<h3 id="仓库体系结构风格"><a href="#仓库体系结构风格" class="headerlink" title="仓库体系结构风格"></a>仓库体系结构风格</h3><h4 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h4><ul>
<li>仓库是存储和维护数据的中心场所</li>
<li>基本组件<ul>
<li>中心数据结构</li>
<li>在中心数据结构上操作的独立构建</li>
</ul>
</li>
</ul>
<h4 id="连接件-2"><a href="#连接件-2" class="headerlink" title="连接件"></a>连接件</h4><ul>
<li>仓库和独立构建之间的交互</li>
</ul>
<h4 id="交互机制"><a href="#交互机制" class="headerlink" title="交互机制"></a>交互机制</h4><ol>
<li><strong>数据库方式</strong>：输入流中的事务类型触发需要执行的过程</li>
<li><strong>黑板结构</strong>：中心数据结构的当前状态触发并选择需要执行的过程</li>
</ol>
<h3 id="黑板体系风格"><a href="#黑板体系风格" class="headerlink" title="黑板体系风格"></a>黑板体系风格</h3><h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><ul>
<li>一个大问题被分解为若干个子问题</li>
<li>每个子问题的解决需要不同的问题表达方式和求解模型，分别涉及求解程序。</li>
</ul>
<h4 id="基本构件-3"><a href="#基本构件-3" class="headerlink" title="基本构件"></a>基本构件</h4><ul>
<li>黑板</li>
<li>控制器</li>
<li>知识源</li>
</ul>
<h4 id="知识源"><a href="#知识源" class="headerlink" title="知识源"></a>知识源</h4><ul>
<li>知识源是描述某个独立领域问题的知识及其处理方法的知识库，其分别存放且相互独立的，他们通过黑板进行通讯，合作求出问题的解，通常知识源具有条件动作的形式。当条件满足时，知识源被触发，其动作部分增加或修改黑板上得内容。<ul>
<li>待解决的问题被分为若干个子问题，每个子问题由一个独立的知识源加以理解</li>
<li>知识源包含独立的领域知识</li>
<li>知识源执行计算后会跟新黑板里的数据状态</li>
<li>多个知识源 之间只能通过黑板交换知识</li>
</ul>
</li>
</ul>
<h4 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h4><ul>
<li>时刻监视黑板状态变化</li>
<li>对黑板上信息的当前状态进行判断和评价</li>
<li>当黑板的状态满足了黑板源的执行条件时，该知识源被控制器触发并进行计算，然后将结果更新到黑板上</li>
<li>这种更新又导致其他知识源参与计算并更新黑板，直到找到问题解为止</li>
</ul>
<h4 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h4><ul>
<li>自然语言处理</li>
<li>语音处理</li>
<li>模式识别</li>
<li>图像处理</li>
</ul>
<h2 id="4-虚拟机体系结构风格"><a href="#4-虚拟机体系结构风格" class="headerlink" title="4. 虚拟机体系结构风格"></a>4. 虚拟机体系结构风格</h2><p><strong>continue。。。。。。</strong></p>
<h2 id="5-事件系统体系结构风格"><a href="#5-事件系统体系结构风格" class="headerlink" title="5. 事件系统体系结构风格"></a>5. 事件系统体系结构风格</h2><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><ul>
<li>能够激活对象功能的<strong>动作</strong>，当发生这种动作后将给所涉及对象发送一个消息，<strong>对象</strong>便可执行相应的<strong>功能</strong>。</li>
</ul>
<h3 id="事件系统"><a href="#事件系统" class="headerlink" title="事件系统"></a>事件系统</h3><h4 id="主要特点-隐式调用"><a href="#主要特点-隐式调用" class="headerlink" title="主要特点 - 隐式调用"></a>主要特点 - 隐式调用</h4><ul>
<li>事件的触发者并不知道那些构件会被这些事件影响，<strong>相互保持独立</strong></li>
<li><strong>不能假定构建的处理顺序</strong>，甚至不知道那些过程被调用</li>
<li>各个构件之间彼此无连接关系，各自独立存在，<strong>通过对事件的发布和注册实现关联</strong></li>
</ul>
<h4 id="基本结构和工作原理"><a href="#基本结构和工作原理" class="headerlink" title="基本结构和工作原理"></a>基本结构和工作原理</h4><ul>
<li>事件源发布时间，事件管理器通知时间给事件处理器处理</li>
<li>特点<ul>
<li>分离的交互：时间发布者并不会意识到事件订阅者的存在</li>
<li>一对多通信：采用发布/订阅消息传递，一个特定时间可以影响多个订阅者</li>
<li>基于事件的触发器：由事件出发过程调用</li>
<li>异步：支持异步操作</li>
</ul>
</li>
</ul>
<h4 id="基本构件-4"><a href="#基本构件-4" class="headerlink" title="基本构件"></a>基本构件</h4><ul>
<li>事件源 ：发布事件</li>
<li>事件处理器：向特定的事件进行注册</li>
<li>事件管理器</li>
</ul>
<h4 id="连接机制"><a href="#连接机制" class="headerlink" title="连接机制"></a>连接机制</h4><ul>
<li>一个事件也可能会触发其他事件，形成事件连</li>
</ul>
<h3 id="应用实例-1"><a href="#应用实例-1" class="headerlink" title="应用实例"></a>应用实例</h3><h4 id="调试器中的断点机制"><a href="#调试器中的断点机制" class="headerlink" title="调试器中的断点机制"></a>调试器中的断点机制</h4><ul>
<li>基本构件<ul>
<li>事件源：调试器</li>
<li>事件处理器：编辑器与变量监视器</li>
<li>事件管理器：集成开发环境</li>
</ul>
</li>
<li>处理过程<ul>
<li>编辑器与变量监视器向调试器注册，接受断点事件</li>
<li>遇到断电，调试器发布事件，从而触发编辑器与变量检测器</li>
<li>编辑器将源代码滚动到断点处</li>
<li>变量检测器则跟新当前变量值并显示出来</li>
</ul>
</li>
</ul>
<h3 id="调度机制"><a href="#调度机制" class="headerlink" title="调度机制"></a>调度机制</h3><h4 id="无独立调度模块的事件系统"><a href="#无独立调度模块的事件系统" class="headerlink" title="无独立调度模块的事件系统"></a>无独立调度模块的事件系统</h4><ul>
<li>观察者/被观察者</li>
<li>每一个模块<strong>都允许</strong>其他模块向自己所能发送的某些消息表明兴趣</li>
<li>当某一模块发出某一事件时，他自动将这些事件发布给那些<strong>曾经向自己注册过此事件的模块</strong></li>
</ul>
<h4 id="有独立调度模块的事件系统"><a href="#有独立调度模块的事件系统" class="headerlink" title="有独立调度模块的事件系统"></a>有独立调度模块的事件系统</h4><ul>
<li>事件派遣模块<ul>
<li>负责接收到来的事件并派遣他们到其他模块</li>
</ul>
</li>
<li>派遣方式<ul>
<li>全广播式<ul>
<li>派遣模块将时间广播到所有的模块，但只有感兴趣的模块才取出事件并触发自身的行为</li>
</ul>
</li>
<li>选择广播式<ul>
<li>派遣模块将时间送到那些已经注册的模块中</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="选择广播式的两种策略：基于事件被执行的方式"><a href="#选择广播式的两种策略：基于事件被执行的方式" class="headerlink" title="选择广播式的两种策略：基于事件被执行的方式"></a>选择广播式的两种策略：基于事件被执行的方式</h5><h6 id="点对点模式：基于消息队列（一对一）"><a href="#点对点模式：基于消息队列（一对一）" class="headerlink" title="点对点模式：基于消息队列（一对一）"></a>点对点模式：基于消息队列（一对一）</h6><ul>
<li>其他应用向消息队列发布事件，队列管理器会在消费者将他注册过的事件取回后删除事件。</li>
</ul>
<h6 id="发布订阅模式（一对多）"><a href="#发布订阅模式（一对多）" class="headerlink" title="发布订阅模式（一对多）"></a>发布订阅模式（一对多）</h6><ul>
<li>其他应用向消息队列发布事件，队列管理器会在消费者将他注册过的事件取回搁浅到事件过期后再将事件删除</li>
</ul>
<h1 id="第二章-质量属性和策略"><a href="#第二章-质量属性和策略" class="headerlink" title="第二章 质量属性和策略"></a>第二章 质量属性和策略</h1><ul>
<li>质量属性场景的6个组成部分<ul>
<li>刺激源 司机</li>
<li>刺激 踩油门</li>
<li>制品 动力系统</li>
<li>环境 超车，爬坡</li>
<li>响应 发动机转速提高</li>
<li>响应衡量指标 时速表</li>
</ul>
</li>
</ul>
<h2 id="1-可用性"><a href="#1-可用性" class="headerlink" title="1. 可用性"></a>1. 可用性</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul>
<li>当用户使用系统时，系统可用的概率</li>
<li>提前确定的停机维护不计入</li>
</ul>
<h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><h4 id="刺激源"><a href="#刺激源" class="headerlink" title="刺激源"></a>刺激源</h4><ul>
<li>故障的迹象（来自内部或外部）</li>
</ul>
<h4 id="刺激"><a href="#刺激" class="headerlink" title="刺激"></a>刺激</h4><ul>
<li>系统出错</li>
<li>系统崩溃</li>
<li>给出结果不准时</li>
<li>给出错误结果</li>
</ul>
<h4 id="制品"><a href="#制品" class="headerlink" title="制品"></a>制品</h4><ul>
<li>网络传输 or 计算 or 存储</li>
</ul>
<h4 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h4><ul>
<li>正常状态 or 亚健康状态</li>
</ul>
<h4 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h4><ul>
<li>记录日志，回传给厂家</li>
<li>通知管理员或其它系统</li>
<li>关闭系统，系统在维修期间不可用</li>
</ul>
<h4 id="响应衡量-指标"><a href="#响应衡量-指标" class="headerlink" title="响应衡量 指标"></a>响应衡量 指标</h4><ul>
<li>故障时间百分比，修复故障所需时间，平均无故障时间</li>
</ul>
<h3 id="提升的策略"><a href="#提升的策略" class="headerlink" title="提升的策略"></a>提升的策略</h3><h4 id="方向1-故障检测"><a href="#方向1-故障检测" class="headerlink" title="方向1 故障检测"></a>方向1 故障检测</h4><ul>
<li>Ping/echo</li>
<li>Heartbeat<ul>
<li>定期发出心跳消息，未收到则说明出现异常</li>
</ul>
</li>
<li>Exceptions<ul>
<li>java异常处理</li>
</ul>
</li>
</ul>
<h4 id="方向2-故障恢复"><a href="#方向2-故障恢复" class="headerlink" title="方向2 故障恢复"></a>方向2 故障恢复</h4><ul>
<li>投票<ul>
<li>多个组件完成同一任务，少数服从多数</li>
</ul>
</li>
<li>主动冗余<ul>
<li>备胎，A出错用B，A和B每时每刻都是保持一致</li>
</ul>
</li>
<li>被动冗余<ul>
<li>A将状态告诉B，A出错，B可以换A</li>
</ul>
</li>
<li>内测<ul>
<li>游戏内测检查BUG</li>
</ul>
</li>
<li>检查点/回滚<ul>
<li>定期保存</li>
</ul>
</li>
</ul>
<h4 id="方向1-故障避免"><a href="#方向1-故障避免" class="headerlink" title="方向1 故障避免"></a>方向1 故障避免</h4><ul>
<li>服务下线<ul>
<li>知道要被攻击，主动下线</li>
</ul>
</li>
<li>事务<ul>
<li>多个操作必须全部完成才结束</li>
</ul>
</li>
<li>进程监控<ul>
<li>任务管理器</li>
</ul>
</li>
</ul>
<h2 id="2-可修改性"><a href="#2-可修改性" class="headerlink" title="2. 可修改性"></a>2. 可修改性</h2><h3 id="关注点"><a href="#关注点" class="headerlink" title="关注点"></a>关注点</h3><ul>
<li>修改的成本</li>
<li>系统的哪些部分被修改</li>
<li>修改发生的时间</li>
<li>修改由谁来进行</li>
</ul>
<h3 id="刺激源-1"><a href="#刺激源-1" class="headerlink" title="刺激源"></a>刺激源</h3><ul>
<li>谁进行的修改（开发者/管理员/用户）</li>
</ul>
<h3 id="刺激-1"><a href="#刺激-1" class="headerlink" title="刺激"></a>刺激</h3><ul>
<li>要进行的具体修改</li>
</ul>
<h3 id="制品-1"><a href="#制品-1" class="headerlink" title="制品"></a>制品</h3><ul>
<li>修改系统的功能 or UI or 交互的其它系统</li>
</ul>
<h3 id="环境-1"><a href="#环境-1" class="headerlink" title="环境"></a>环境</h3><ul>
<li><p>在什么时间进行修改？设计期间 or 开发期间 or 运行期间</p>
</li>
<li><p>修改的时间越迟，越不利</p>
</li>
</ul>
<h3 id="响应-1"><a href="#响应-1" class="headerlink" title="响应"></a>响应</h3><ul>
<li>操作人员要理解如何修改，进行修改操作，测试，部署</li>
</ul>
<h3 id="响应衡量指标"><a href="#响应衡量指标" class="headerlink" title="响应衡量指标"></a>响应衡量指标</h3><ul>
<li>时间，成本</li>
</ul>
<h3 id="提升可修改性的策略"><a href="#提升可修改性的策略" class="headerlink" title="提升可修改性的策略"></a>提升可修改性的策略</h3><ul>
<li>目标：降低修改的时间和成本</li>
</ul>
<h4 id="方向1-限制修改的范围"><a href="#方向1-限制修改的范围" class="headerlink" title="方向1 限制修改的范围"></a>方向1 限制修改的范围</h4><ul>
<li><p>模块高内聚，低耦合</p>
</li>
<li><p>考虑到可能发生的修改</p>
</li>
<li><p>让模块通用</p>
</li>
<li><p>隐藏信息</p>
</li>
<li><p>维持接口不变</p>
</li>
<li><p>限制通信路径</p>
<ul>
<li>Facade模式</li>
</ul>
</li>
<li><p>使用中介</p>
<ul>
<li>数据中介</li>
<li>服务中介：设计模式的bridge，工厂方法模式</li>
</ul>
</li>
</ul>
<h4 id="提升可修改性的策略-1"><a href="#提升可修改性的策略-1" class="headerlink" title="提升可修改性的策略"></a>提升可修改性的策略</h4><ul>
<li>配置文件</li>
<li>发布订阅模式</li>
<li>多态</li>
</ul>
<h2 id="3-性能"><a href="#3-性能" class="headerlink" title="3. 性能"></a>3. 性能</h2><h3 id="关注点-1"><a href="#关注点-1" class="headerlink" title="关注点"></a>关注点</h3><ul>
<li><p>系统响应时间的速度</p>
</li>
<li><p>和时间的数量和到达模式有关</p>
</li>
</ul>
<h3 id="事件的来源"><a href="#事件的来源" class="headerlink" title="事件的来源"></a>事件的来源</h3><ul>
<li>用户的请求，本系统内部，本系统外部</li>
</ul>
<h3 id="六个要素"><a href="#六个要素" class="headerlink" title="六个要素"></a>六个要素</h3><ul>
<li>刺激源：系统内部或外部</li>
<li>刺激：事件到来</li>
<li>制品：系统所提供的服务</li>
<li>环境：系统处于不同的模式（正常/紧急/超载）</li>
<li>响应：系统处理到来的时间，可能会导致状态的变化</li>
<li>响应衡量指标：<ul>
<li>处理事件所花的时间</li>
<li>单位时间内处理时间的数目</li>
<li>出库的错误率/丢失率</li>
</ul>
</li>
</ul>
<h3 id="提升的策略-1"><a href="#提升的策略-1" class="headerlink" title="提升的策略"></a>提升的策略</h3><h4 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h4><ul>
<li>在限定时间内响应事件</li>
<li>获取资源 + 使用资源</li>
</ul>
<h4 id="方向1-资源的需求"><a href="#方向1-资源的需求" class="headerlink" title="方向1 资源的需求"></a>方向1 资源的需求</h4><ul>
<li>数据量不变，提高计算效率<ul>
<li>算法效率</li>
<li>减少处理事件时对资源的占用</li>
</ul>
</li>
<li>减少总数据量<ul>
<li>控制事件到达速率</li>
<li>之抽取一部分请求来处理</li>
</ul>
</li>
<li>限制执行时间<ul>
<li>在规定时间内得到近似解</li>
</ul>
</li>
<li>限制待处理事件队列长度<ul>
<li>直接放弃一部分事件</li>
</ul>
</li>
</ul>
<h4 id="方向2-资源的管理"><a href="#方向2-资源的管理" class="headerlink" title="方向2 资源的管理"></a>方向2 资源的管理</h4><ul>
<li>利用并发机制</li>
<li>增加可用资源</li>
<li>动态优先级</li>
</ul>
<h4 id="方向3-资源的仲裁"><a href="#方向3-资源的仲裁" class="headerlink" title="方向3 资源的仲裁"></a>方向3 资源的仲裁</h4><h2 id="4-安全性"><a href="#4-安全性" class="headerlink" title="4. 安全性"></a>4. 安全性</h2><h3 id="关注点-2"><a href="#关注点-2" class="headerlink" title="关注点"></a>关注点</h3><ul>
<li>在保证合法用户使用系统的前提下，抵抗对系统的冲击</li>
</ul>
<h3 id="六大要素"><a href="#六大要素" class="headerlink" title="六大要素"></a>六大要素</h3><ul>
<li>刺激源：攻击可能由人或其它系统发起</li>
<li>刺激：对系统的攻击</li>
<li>制品：系统所提供的服务或者系统中的数据</li>
<li>环境：系统可能处于不同的情况下</li>
<li>响应：合法用户正常使用，拒绝非法用户使用</li>
<li>响应衡量指标：发起攻击的难度；从攻击中回复的难度</li>
</ul>
<h3 id="提升的策略-2"><a href="#提升的策略-2" class="headerlink" title="提升的策略"></a>提升的策略</h3><h4 id="方向1-抵抗攻击"><a href="#方向1-抵抗攻击" class="headerlink" title="方向1 抵抗攻击"></a>方向1 抵抗攻击</h4><ul>
<li>用户验证</li>
<li>用户授权</li>
<li>加密传输：https</li>
<li>维持数据的完整性：MD5码校验</li>
<li>减少暴露信息</li>
<li>限制访问</li>
</ul>
<h4 id="方向2-检测攻击"><a href="#方向2-检测攻击" class="headerlink" title="方向2 检测攻击"></a>方向2 检测攻击</h4><ul>
<li>软件和人结合<ul>
<li>安全专家</li>
<li>360</li>
</ul>
</li>
</ul>
<h2 id="5-可测试性"><a href="#5-可测试性" class="headerlink" title="5. 可测试性"></a>5. 可测试性</h2><h4 id="关注点（软件测试是为了发现错误）"><a href="#关注点（软件测试是为了发现错误）" class="headerlink" title="关注点（软件测试是为了发现错误）"></a>关注点（软件测试是为了发现错误）</h4><ul>
<li>让软件的bug容易被测试出来</li>
<li>验证软件产品与它的需求规格是否匹配</li>
<li>使用最小的成本和工作量来验证软件的质量</li>
</ul>
<h3 id="六要素"><a href="#六要素" class="headerlink" title="六要素"></a>六要素</h3><ul>
<li>刺激源：各种角色都有可能发起（开发者，单元测试人员，集成测试人员，系统管理人员，用户）</li>
<li>刺激：系统开发到了里程碑</li>
<li>制品：一个设计，一段代码，整个系统</li>
<li>环境：系统可能处于设计/开发/部署/正常运行阶段</li>
<li>响应：理想的响应式可以进行测试，并且可以观察到测试结果；当测试结果无法被观察到时，测试难度很大</li>
<li>响应衡量指标：白盒测试中的覆盖率；未来继续发现BUG的概率</li>
</ul>
<h3 id="提升可测试性的策略"><a href="#提升可测试性的策略" class="headerlink" title="提升可测试性的策略"></a>提升可测试性的策略</h3><h4 id="目标-1"><a href="#目标-1" class="headerlink" title="目标"></a>目标</h4><ul>
<li>让测试更加轻松</li>
</ul>
<h4 id="方向1-黑盒测试"><a href="#方向1-黑盒测试" class="headerlink" title="方向1 黑盒测试"></a>方向1 黑盒测试</h4><p><strong>总体思路：提供输入 + 捕获输出</strong></p>
<ul>
<li>记录/回放：自动化/半自动化测试</li>
<li>把接口和实现分离开：不同的排序算法，相同的接口</li>
<li>提供专用的测试路径</li>
</ul>
<h4 id="方向2-白盒测试"><a href="#方向2-白盒测试" class="headerlink" title="方向2 白盒测试"></a>方向2 白盒测试</h4><ul>
<li>内部监控<ul>
<li>IDE提供的断点等调试工具</li>
</ul>
</li>
</ul>
<h2 id="6-易用性"><a href="#6-易用性" class="headerlink" title="6. 易用性"></a>6. 易用性</h2><h1 id="第三章-软件体系结构评估"><a href="#第三章-软件体系结构评估" class="headerlink" title="第三章 软件体系结构评估"></a>第三章 软件体系结构评估</h1><h2 id="软件体系结构评估概述"><a href="#软件体系结构评估概述" class="headerlink" title="软件体系结构评估概述"></a>软件体系结构评估概述</h2><h4 id="1-为什么要进行软件体系结构评估？"><a href="#1-为什么要进行软件体系结构评估？" class="headerlink" title="1. 为什么要进行软件体系结构评估？"></a>1. 为什么要进行软件体系结构评估？</h4><ul>
<li>体系结构可能存在潜在风险，有可能影响到以后的开发成本和需求满足。</li>
</ul>
<h4 id="2-定义"><a href="#2-定义" class="headerlink" title="2. 定义"></a>2. 定义</h4><ul>
<li>架构评估是开发生命周期的活动,一些利益相关者(项目干系人)分析软件架构在一个正式的或非正式的(正式或非正式)过程使用评估技术,如场景(场景)</li>
</ul>
<h4 id="3-好处"><a href="#3-好处" class="headerlink" title="3. 好处"></a>3. 好处</h4><ul>
<li>对现有体系结构问题的早期检测，检测到问题的生命周期越早，修复问题的成本就越低。</li>
</ul>
<h4 id="4-怎么样进行评估？"><a href="#4-怎么样进行评估？" class="headerlink" title="4. 怎么样进行评估？"></a>4. 怎么样进行评估？</h4><ul>
<li>利用各种评估方法</li>
<li>Scenario-based Architecture Analysis Method (SAAM)<ul>
<li>这可能是<strong>第一个文档化的软件架构分析方法</strong>，最初是为了分析架构的<strong>可修改性</strong>而开发的。但是，它对于分析架构的任何<strong>非功能</strong>方面都是有用的。它基于使用利益相关者生成的场景来评估架构</li>
</ul>
</li>
</ul>
<hr>
<h2 id="ATAM"><a href="#ATAM" class="headerlink" title="ATAM"></a>ATAM</h2><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h4><ul>
<li>ATAM是一种帮助涉众提出正确问题以发现潜在问题架构决策的方法</li>
</ul>
<h4 id="2-目标"><a href="#2-目标" class="headerlink" title="2. 目标"></a>2. 目标</h4><ul>
<li>ATAM的目的不是提供精确的分析，其目的是发现架构决策所产生的风险</li>
</ul>
<h4 id="3-参与人员"><a href="#3-参与人员" class="headerlink" title="3. 参与人员"></a>3. 参与人员</h4><ul>
<li>评估小组：<ul>
<li>每个评估团队由一名领导和至少三名其他团队成员组成。</li>
<li>ATAM团队成员必须是有经验的架构师。</li>
<li>ATAM的领导必须有优秀的沟通和引导技巧。</li>
</ul>
</li>
<li>项目决策者<ul>
<li>能够控制程序开发过程和<strong>授权变更</strong>的人员</li>
<li>通常包含项目经理,为开发买单的用户,和体系结构开发人员</li>
</ul>
</li>
<li>架构涉众<ul>
<li>涉众是与要开发的系统相关的一切人和事</li>
<li><strong>涉众不等于用户</strong></li>
</ul>
</li>
</ul>
<h4 id="4-具体步骤"><a href="#4-具体步骤" class="headerlink" title="4. 具体步骤"></a>4. 具体步骤</h4><h5 id="0-阶段（在技术评估之前，是准备工作）"><a href="#0-阶段（在技术评估之前，是准备工作）" class="headerlink" title="0 阶段（在技术评估之前，是准备工作）"></a>0 阶段（在技术评估之前，是准备工作）</h5><ul>
<li>主要工作：客户和评估团队协商评估的方法和系统信息，确定评估方法，最后部署评估工作</li>
</ul>
<h5 id="1-阶段"><a href="#1-阶段" class="headerlink" title="1 阶段"></a>1 阶段</h5><ul>
<li><p>概述：是以体系结构为中心对架构的详细信息进行自顶向下分析</p>
</li>
<li><p>参与人员：主要是技术相关人员</p>
</li>
<li><p>具体步骤</p>
<ol>
<li>评估小组介绍ATAM方法</li>
<li>客户描述需求（功能性和非功能性需求）</li>
<li>设计人员介绍架构的设计</li>
<li>确定架构的评估方法</li>
<li>通过构建一个效用树来识别、优化最重要的质量属性</li>
<li>评估团队从质量属性的角度探索架构方法，以识别和记录风险和non-risks,敏感点和权衡点<ul>
<li>敏感点：一个或多个组件(和/或组件关系)的属性，对于实现特定质量属性响应至关重要</li>
<li>权衡点：影响多个质量属性的属性，并且是多个属性的敏感点</li>
<li>风险：是一个潜在的有问题的架构决</li>
<li>non-risks：是良好的架构决策，在分析之后被认为是安全的。</li>
</ul>
</li>
</ol>
</li>
<li><p>效用树</p>
<ul>
<li>定义：自顶向下对质量属性进行分析的工具，用来刻画需求</li>
<li>叶子节点：场景描述</li>
<li>根节点的子节点：质量属性</li>
<li>中间节点（倒数第二层）：优先级</li>
</ul>
</li>
<li><p>产出：</p>
<p>➢架构方法</p>
<p>➢效用树</p>
<p>➢场景</p>
<p>➢风险和非风险</p>
<p>➢敏感性和权衡</p>
</li>
</ul>
<h5 id="2-阶段"><a href="#2-阶段" class="headerlink" title="2 阶段"></a>2 阶段</h5><ul>
<li><p>参与人员：各种干系人</p>
</li>
<li><p>具体步骤</p>
<ol>
<li>干系人头脑风暴产生场景描述</li>
<li>利用产生的场景对1阶段产生的成果再一次进行分析</li>
<li>概括所有步骤并完成输出</li>
</ol>
</li>
<li><p>产出：</p>
<p>➢架构方法</p>
<p>➢效用树</p>
<p>➢场景</p>
<p>➢风险和非风险</p>
<p>➢敏感性和权衡</p>
<p>➢风险主题</p>
</li>
</ul>
<h5 id="3-阶段"><a href="#3-阶段" class="headerlink" title="3 阶段"></a>3 阶段</h5><ul>
<li><p>参与人员：技术人员</p>
</li>
<li><p>概述：主要包括为客户制作最终报告，并对评估的质量和ATAM材料进行反思</p>
</li>
<li><p>最终产出：</p>
<p>➢执行概要</p>
<p>➢ATAM的描述</p>
<p>➢需求和架构的描述</p>
<p>➢列出阶段1和阶段2的场景和效用树</p>
<p>➢阶段1和阶段2分析:架构方法,决策,风险,敏感性,权衡,non-risks</p>
<p>➢风险主题</p>
<p>➢下一步</p>
</li>
</ul>
<h1 id="第四章-应用案例——软件体系结构风格"><a href="#第四章-应用案例——软件体系结构风格" class="headerlink" title="第四章 应用案例——软件体系结构风格"></a>第四章 应用案例——软件体系结构风格</h1><h2 id="课前问题"><a href="#课前问题" class="headerlink" title="课前问题"></a>课前问题</h2><ul>
<li>在结束体系结构评估之后，软件体系结构的设计过程已经基本结束</li>
</ul>
<h2 id="KWIC案例"><a href="#KWIC案例" class="headerlink" title="KWIC案例"></a>KWIC案例</h2><h3 id="需求获取"><a href="#需求获取" class="headerlink" title="需求获取"></a>需求获取</h3><ul>
<li>功能性：输入 -&gt; 循环位移 -&gt; 排序输出</li>
<li>非功能性：可修改，系统复用性</li>
</ul>
<h3 id="1-主程序-子程序风格"><a href="#1-主程序-子程序风格" class="headerlink" title="1. 主程序 - 子程序风格"></a>1. 主程序 - 子程序风格</h3><h4 id="主要思想"><a href="#主要思想" class="headerlink" title="主要思想"></a>主要思想</h4><ul>
<li>对系统进行功能分解，是最自然的想法,也是“面向过程的编程” 的主要思路</li>
<li>分为四个基本功能：输入、移位、排序、输出</li>
<li>主程序按次序调用这四个模块</li>
<li>通过共享的数据存储和无约束的读-写协议在模块之间进行数据交换</li>
</ul>
<h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><ul>
<li>优点<ul>
<li>模块之间的数据共享</li>
<li>不同的计算功能被隔离在不同的模块中</li>
</ul>
</li>
<li>缺点<ul>
<li>对数据存储格式的变化将会影响几乎所有的模块</li>
<li>对处理流程的改变与系统功能的增强也很难适应，依赖于控制模块内部的调用次序</li>
<li>这种分解也难以支持有效的复用</li>
</ul>
</li>
</ul>
<h3 id="2-面向对象风格"><a href="#2-面向对象风格" class="headerlink" title="2. 面向对象风格"></a>2. 面向对象风格</h3><h4 id="主要思想-1"><a href="#主要思想-1" class="headerlink" title="主要思想"></a>主要思想</h4><ul>
<li>数据不再被构件直接共享，而是被封装在了Object中</li>
<li>每个对象提供了一个接口，允许其他对象通过该接口调用对该对象内封装的数据的操作</li>
<li>主要对象<ul>
<li>Input object：负责从输入文件中读取数据并将其存储在LineStorage对象</li>
<li>LineStorage object：存储和处理字符、单词、行</li>
<li>CircularShifter object：负责对LineStorage对象中存储的数据进行循环移位</li>
<li>Alphabetizer object： 负责对循环移位后得到的数据进行排序</li>
<li>Output object：负责打印输出排序后的数据)</li>
<li>Master control object ：负责控制其他各对象中方法的调用次序</li>
</ul>
</li>
</ul>
<h4 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h4><ul>
<li>优点<ul>
<li>某一构件的算法与数据结构的修改不会影响其他构件</li>
<li>构件之间依赖性降低，提高了复用度</li>
</ul>
</li>
<li>缺点<ul>
<li>不是特别适合功能的扩展</li>
<li>为了增加新功能，要么修改已有的模块，要么就加入新的模块</li>
</ul>
</li>
</ul>
<h3 id="3-管道过滤器风格"><a href="#3-管道过滤器风格" class="headerlink" title="3. 管道过滤器风格"></a>3. 管道过滤器风格</h3><h4 id="主要思想-2"><a href="#主要思想-2" class="headerlink" title="主要思想"></a>主要思想</h4><ul>
<li>四个过滤器：输入、移位、排序、输出<ul>
<li>“输入”过滤器：从数据源读取输入文件，解析格式，将行写入输出管道</li>
<li>“循环移位”过滤器</li>
<li>“排序”过滤器</li>
<li>“输出”过滤器</li>
</ul>
</li>
<li>每个过滤器处理数据，然后将结果送至下一个过滤器</li>
<li>控制机制是分布式的：只要有数据传入，过滤器即开始工作</li>
<li>过滤器之间的数据共享被严格限制在管道传输</li>
</ul>
<h4 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h4><ul>
<li>优点<ul>
<li>过程流非常直观</li>
<li>支持复用</li>
<li>容易修改</li>
<li>过滤器的功能相互隔离</li>
<li>新功能容易加入</li>
</ul>
</li>
<li>缺点<ul>
<li>无法支持交互式系统，局限性较大</li>
<li>空间复杂性高</li>
</ul>
</li>
</ul>
<h2 id="图书借阅系统"><a href="#图书借阅系统" class="headerlink" title="图书借阅系统"></a>图书借阅系统</h2><h3 id="C-S三层结构"><a href="#C-S三层结构" class="headerlink" title="C/S三层结构"></a>C/S三层结构</h3><h3 id="OO-事件系统"><a href="#OO-事件系统" class="headerlink" title="OO + 事件系统"></a>OO + 事件系统</h3><h3 id="基于规则系统风格"><a href="#基于规则系统风格" class="headerlink" title="基于规则系统风格"></a>基于规则系统风格</h3><ul>
<li>优点：有利于修改，复用性强</li>
</ul>
<h3 id="产品线"><a href="#产品线" class="headerlink" title="产品线"></a>产品线</h3><ul>
<li><p>软件产品线：是一组软件系统，共享一组通用的特征集合，通过使用</p>
<p>一组预先开发的/通用的<strong>核心资产</strong>来满足不同产品的研发需求</p>
</li>
<li><p>复用性强</p>
</li>
</ul>
<h3 id="思考题-音像借阅系统"><a href="#思考题-音像借阅系统" class="headerlink" title="思考题 音像借阅系统"></a>思考题 音像借阅系统</h3><ul>
<li><p>「需求描述」有多个音像店，通过网络连接，搜索引擎需要能够搜索所有音像店的产品信 息;系统支持多个店之间的互借;顾客需交纳年费才能成为会员，当会员资格即将 过期时，系统向其发出缴费通知;如果会员资格过期，不允许再次借阅;音像产品 按类别进行组织，但发行日期在三个月内时，将被看作“新片”;系统每天进行检 索，将“新片”里不再是“新片”的video归到特定的类别里;借阅video的收费 策略为:按天借阅:3元/天，但新片5元/天;按周借阅:12元/周;打包借阅:25月/3片/周;当video被归还时才开始计费，如果超期归还，按照收费标准进行 额外的计费;在同一时间，一个顾客手头借阅的video最多为7片。</p>
</li>
<li><p>“基于规则的系统”风格</p>
<ul>
<li><p>权限管理服务</p>
<ul>
<li><p>IF 用户类别 = 会员 AND 操作 = 借阅 AND CD = 新</p>
<p>THEN </p>
<p>​    每次借阅的最大数目 = 7</p>
<p>​    会员到期后是否提醒 = Y</p>
<p>​    会员到期后是否可以借阅 = N</p>
<p>​    超期罚款标准 = 当video被归还时才开始计费，如果超期归    还，按照收费标准进行 额外的计费</p>
<p>​    CD 是非是新 = Y</p>
<p>​    借阅图书收费标准 = 按天借阅:5元/天;按周    借阅:12元/周;打包借阅:25月/3片/周</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code>- IF 用户类别 = 会员 AND 操作 = 借阅 AND CD = 旧

  THEN 

  ​    每次借阅的最大数目 = 7

  ​    会员到期后是否提醒 = Y

  ​    会员到期后是否可以借阅 = N

  ​    超期罚款标准 = 当video被归还时才开始计费，如果超期归    还，按照收费标准进行 额外的计费

  ​    CD 是非是新 = N

  ​    借阅图书收费标准 = 按天借阅:3元/天;按周    借阅:12元/周;    打包借阅:25月/3片/周</code></pre><ul>
<li><p>CD管理服务</p>
<ul>
<li><p>IF CD类别 = “新CD”</p>
<p>THEN </p>
<p>​    变更标准：三个月内时，将被看作“新CD”，超过三个月，变更为“旧CD”</p>
</li>
</ul>
</li>
<li><p>用户管理服务</p>
<ul>
<li><p>IF 用户类别 = 普通用户 </p>
<p>THEN </p>
<p>​    需要交费才可以成为会员 = Y</p>
<p>​    费用标准 = 年费 n ￥</p>
<p>​    会员有效期 = 一年</p>
</li>
<li><p>IF 用户类别 = 会员</p>
<p>THEN</p>
<p>​    需要交费才可以成为会员 = N</p>
</li>
</ul>
</li>
</ul>
<pre><code>​    </code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/111zx/111zx.github.io/2020/05/14/%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/" data-id="ck88at6vi000a14ub5510hll0" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-tips" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/12/tips/" class="article-date">
  <time datetime="2020-05-12T15:17:31.000Z" itemprop="datePublished">2020-05-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/12/tips/">tips</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-时间复杂度为O-NlogN-的数组排序"><a href="#1-时间复杂度为O-NlogN-的数组排序" class="headerlink" title="1. 时间复杂度为O(NlogN)的数组排序"></a>1. 时间复杂度为O(NlogN)的数组排序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(nums);<span class="comment">//nums是一个一维数组</span></span><br></pre></td></tr></table></figure>

<h2 id="2-代替n-2的位运算"><a href="#2-代替n-2的位运算" class="headerlink" title="2. 代替n/2的位运算"></a>2. 代替n/2的位运算</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n &gt;&gt; <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<h2 id="3-找出数组中最大的元素"><a href="#3-找出数组中最大的元素" class="headerlink" title="3. 找出数组中最大的元素"></a>3. 找出数组中最大的元素</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">方法一</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">return</span> Arrays.stream(nums).max().getAsInt();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">方法二</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">List&lt;Integer&gt; list1 = Arrays.stream(nums).boxed().collect(Collectors.toList());</span><br><span class="line"><span class="keyword">return</span> Collections.max(list1);</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/111zx/111zx.github.io/2020/05/12/tips/" data-id="ckbbzdvsm000at8ubfv7d5vhc" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-leetcode" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/12/leetcode/" class="article-date">
  <time datetime="2020-05-12T02:24:08.000Z" itemprop="datePublished">2020-05-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/12/leetcode/">leetcode</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="53-最大序列和"><a href="#53-最大序列和" class="headerlink" title="53. 最大序列和"></a>53. 最大序列和</h2><h5 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h5><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p>示例:</p>
<p>输入: [-2,1,-3,4,-1,2,1,-5,4],<br>输出: 6<br>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</p>
<p>来源：力扣（LeetCode）</p>
<hr>
<h5 id="1-贪心算法"><a href="#1-贪心算法" class="headerlink" title="1. 贪心算法"></a>1. 贪心算法</h5><h6 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h6><ul>
<li>以 i - 1 下标的元素为结尾的最大序列和为正时，sum = sum + nums[i];以 i - 1 下标的元素为结尾的最大序列和为负时，sum = nums[i]</li>
<li>每次得到序列和后和目前最大序列和比较，根据情况判断是否更新最大序列和的值</li>
</ul>
<h6 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h6><ul>
<li>O(n)</li>
</ul>
<h6 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h6><ul>
<li>O(1)</li>
</ul>
<h6 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   贪心算法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">method1</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">       <span class="keyword">int</span> max = nums[<span class="number">0</span>];</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>,sum = <span class="number">0</span>; i &lt; nums.length; i++)</span><br><span class="line">           <span class="comment">/*</span></span><br><span class="line"><span class="comment">           计算以i下标结尾的最大序列和</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">           max = (sum = sum &lt; <span class="number">0</span> ? nums[i] : sum + 					nums[i]) &gt; max ? sum : max;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">return</span> max;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-动态规划"><a href="#2-动态规划" class="headerlink" title="2. 动态规划"></a>2. 动态规划</h5><h6 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h6><ul>
<li>计算以每个下标为结尾的最大序列和</li>
<li>转移方程：nums[i] = nums[i - 1] &gt; 0 ? nums[i] + nums[ i - 1] : nums[i]</li>
<li>完成计算之后nums数组成为最大序列和数组</li>
</ul>
<h6 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h6><p>O(n)</p>
<h6 id="空间复杂度-1"><a href="#空间复杂度-1" class="headerlink" title="空间复杂度"></a>空间复杂度</h6><p>O(1)</p>
<h6 id="java代码实现"><a href="#java代码实现" class="headerlink" title="java代码实现"></a>java代码实现</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">method2</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; nums.length &gt; <span class="number">1</span> &amp;&amp; i &lt; nums.length; i++) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//构造最大序列和数组（以每个下标为结尾的最大序列和的值）</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i - <span class="number">1</span>] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                nums[i] = nums[i] + nums[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            max = Math.max(max,nums[i]);<span class="comment">//保存最大数据</span></span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="3-分治算法"><a href="#3-分治算法" class="headerlink" title="3.*分治算法"></a>3.*分治算法</h5><h6 id="思路分析-2"><a href="#思路分析-2" class="headerlink" title="思路分析"></a>思路分析</h6><ul>
<li><p>需要维护4个变量：</p>
<ul>
<li>lsum：前序列以做区间为端点的最大子段和</li>
<li>rsum：当前序列以做区间为端点的最大子段和</li>
<li>isum：区间和</li>
<li>msum：当前序列的最大子段和（最后求出[0,nums.length - 1]的值即可）</li>
</ul>
</li>
<li><p>每次合并4个变量的变更依据：</p>
<ul>
<li>新子段的lSum等于左区间的lSum或者左区间的 区间和 加上右区间的lSum</li>
<li>新子段的rSum等于右区间的rSum或者右区间的 区间和 加上左区间的rSum</li>
<li>新子段的区间和等于左右区间的区间和之和</li>
<li><strong>新子段的最大子段和，其子段有可能穿过左右区间，或左区间，或右区间</strong></li>
</ul>
</li>
</ul>
<h6 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h6><p>O(n)</p>
<h6 id="空间复杂度-2"><a href="#空间复杂度-2" class="headerlink" title="空间复杂度"></a>空间复杂度</h6><p>O(logn)</p>
<h6 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 输入校验</span></span><br><span class="line">       <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length &lt;= <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> len = nums.length;<span class="comment">// 获取输入长度</span></span><br><span class="line">       <span class="keyword">return</span> getInfo(nums, <span class="number">0</span>, len - <span class="number">1</span>).mSum;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">wtevTree</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> lSum;<span class="comment">// 以左区间为端点的最大子段和</span></span><br><span class="line">       <span class="keyword">int</span> rSum;<span class="comment">// 以右区间为端点的最大子段和</span></span><br><span class="line">       <span class="keyword">int</span> iSum;<span class="comment">// 区间所有数的和</span></span><br><span class="line">       <span class="keyword">int</span> mSum;<span class="comment">// 该区间的最大子段和</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// 构造函数</span></span><br><span class="line">       wtevTree(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> i, <span class="keyword">int</span> m) &#123;</span><br><span class="line">           lSum = l;</span><br><span class="line">           rSum = r;</span><br><span class="line">           iSum = i;</span><br><span class="line">           mSum = m;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 通过既有的属性，计算上一层的属性,一步步往上返回,获得线段树</span></span><br><span class="line">   <span class="function">wtevTree <span class="title">pushUp</span><span class="params">(wtevTree leftT, wtevTree rightT)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 新子段的lSum等于左区间的lSum或者左区间的 区间和 加上右区间的lSum</span></span><br><span class="line">       <span class="keyword">int</span> l = Math.max(leftT.lSum, leftT.iSum + rightT.lSum);</span><br><span class="line">       <span class="comment">// 新子段的rSum等于右区间的rSum或者右区间的 区间和 加上左区间的rSum</span></span><br><span class="line">       <span class="keyword">int</span> r = Math.max(leftT.rSum + rightT.iSum, rightT.rSum);</span><br><span class="line">       <span class="comment">// 新子段的区间和等于左右区间的区间和之和</span></span><br><span class="line">       <span class="keyword">int</span> i = leftT.iSum + rightT.iSum;</span><br><span class="line">       <span class="comment">// 新子段的最大子段和，其子段有可能穿过左右区间，或左区间，或右区间</span></span><br><span class="line">       <span class="keyword">int</span> m = Math.max(leftT.rSum + rightT.lSum, Math.max(leftT.mSum, rightT.mSum));</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> wtevTree(l, r, i, m);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 递归建立和获得输入区间所有子段的结构</span></span><br><span class="line">   <span class="function">wtevTree <span class="title">getInfo</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 若区间长度为1，其四个子段均为其值</span></span><br><span class="line">       <span class="keyword">if</span> (left == right)</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">new</span> wtevTree(nums[left], nums[left], nums[left], nums[left]);</span><br><span class="line">       <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;<span class="comment">// 获得中间点mid</span></span><br><span class="line">       wtevTree leftT = getInfo(nums, left, mid);</span><br><span class="line">       wtevTree rightT = getInfo(nums, mid + <span class="number">1</span>, right);<span class="comment">//mid+1,左右区间没有交集。</span></span><br><span class="line">       <span class="keyword">return</span> pushUp(leftT, rightT);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h2 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a>15. 三数之和</h2><h6 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h6><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。</p>
<p>注意：答案中不可以包含重复的三元组。</p>
<p> 示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">给定数组 nums &#x3D; [-1, 0, 1, 2, -1, -4]，</span><br><span class="line"></span><br><span class="line">满足要求的三元组集合为：</span><br><span class="line">[</span><br><span class="line">  [-1, 0, 1],</span><br><span class="line">  [-1, -1, 2]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>来源：力扣（LeetCode）</p>
<h6 id="思路分析-3"><a href="#思路分析-3" class="headerlink" title="思路分析"></a>思路分析</h6><ul>
<li>和二数和比较 a + b = 9,三数和变为 a + b = -c.其中重要的一点是需要去重。为了去重可以<strong>先将数组排序</strong>，在遇到nums[i] == nums[i - 1]直接跳过就可以了</li>
<li>最外层循环nums.length - 2次，循环过后不用考虑之前下标的元素，如果再考虑的话会出现重复</li>
</ul>
<h6 id="时间复杂度-3"><a href="#时间复杂度-3" class="headerlink" title="时间复杂度"></a>时间复杂度</h6><p>O(logn) +O(n^2)</p>
<h6 id="空间复杂度-3"><a href="#空间复杂度-3" class="headerlink" title="空间复杂度"></a>空间复杂度</h6><p>O(n)</p>
<h6 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums)&#123;</span><br><span class="line">       Arrays.sort(nums);</span><br><span class="line">       ArrayList&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">2</span>; i++) &#123;</span><br><span class="line">           </span><br><span class="line">           <span class="comment">//去重</span></span><br><span class="line">           <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>])&#123;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">           <span class="keyword">int</span> k = i + <span class="number">1</span>,j = nums.length - <span class="number">1</span>;</span><br><span class="line">           <span class="keyword">while</span>(k &lt; j)&#123;</span><br><span class="line">               <span class="keyword">if</span>(nums[j] + nums[k] == -nums[i])&#123;</span><br><span class="line">                   ArrayList&lt;Integer&gt; set = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                   set.add(nums[i]);</span><br><span class="line">                   set.add(nums[j]);</span><br><span class="line">                   set.add(nums[k]);</span><br><span class="line">                   list.add(set);</span><br><span class="line">                   k++;</span><br><span class="line">                   </span><br><span class="line">                   <span class="comment">//去重</span></span><br><span class="line">                   <span class="keyword">while</span>(k &lt; j &amp;&amp; nums[k -<span class="number">1</span>] == nums[k])&#123;</span><br><span class="line">                       k++;</span><br><span class="line">                   &#125;</span><br><span class="line">                   </span><br><span class="line">                   j--;</span><br><span class="line">                   </span><br><span class="line">                   <span class="comment">//去重</span></span><br><span class="line">                   <span class="keyword">while</span>(k &lt; j &amp;&amp; nums[j] == nums[k - <span class="number">1</span>])&#123;</span><br><span class="line">                       j--;</span><br><span class="line">                   &#125;</span><br><span class="line">                   </span><br><span class="line">               &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[j] + nums[k] &lt; -nums[i])&#123;<span class="comment">//小于nums[i],左端的指针向右移动，寻找更大的组合</span></span><br><span class="line">                   k++;</span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;<span class="comment">//大于nums[i],右端的指针向左移动，寻找更小的组合</span></span><br><span class="line">                   j--;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="最佳股票投资方案"><a href="#最佳股票投资方案" class="headerlink" title="最佳股票投资方案"></a>最佳股票投资方案</h1><h2 id="1-可购买1次"><a href="#1-可购买1次" class="headerlink" title="1.可购买1次"></a>1.可购买1次</h2><h4 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h4><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。</p>
<p>注意：你不能在买入股票前卖出股票。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出，最大利润 &#x3D; 6-1 &#x3D; 5 。</span><br><span class="line">     注意利润不能是 7-1 &#x3D; 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</span><br><span class="line"></span><br><span class="line">来源：力扣（LeetCode）</span><br></pre></td></tr></table></figure>

<h4 id="思路分析-4"><a href="#思路分析-4" class="headerlink" title="思路分析"></a>思路分析</h4><ul>
<li>从第一天的股价开始，需要一个minprice记录最小股价和一个maxprofit记录最大利润</li>
<li>循环n次，最后的maxprofit即是最大利润</li>
</ul>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul>
<li>时间复杂度O(n)</li>
<li>空间复杂度O(1)</li>
</ul>
<h4 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">method</span><span class="params">(<span class="keyword">int</span>[] prices)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> minprice = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> maxprofit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//记录最小股价</span></span><br><span class="line">            <span class="keyword">if</span>(prices[i] &lt; minprice)&#123;</span><br><span class="line">                minprice = prices[i];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//记录最大利润</span></span><br><span class="line">            <span class="keyword">if</span>(prices[i] - minprice &gt;maxprofit)&#123;</span><br><span class="line">                maxprofit = prices[i] - minprice;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxprofit;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="2-可购买任意次"><a href="#2-可购买任意次" class="headerlink" title="2. 可购买任意次"></a>2. 可购买任意次</h2><h4 id="问题描述-3"><a href="#问题描述-3" class="headerlink" title="问题描述"></a>问题描述</h4><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p>
<p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p>示例1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 7</span><br><span class="line">解释: 在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 3 天（股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5-1 &#x3D; 4 。</span><br><span class="line">     随后，在第 4 天（股票价格 &#x3D; 3）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出, 这笔交易所能获得利润 &#x3D; 6-3 &#x3D; 3 。</span><br><span class="line"></span><br><span class="line">来源：力扣（LeetCode）</span><br></pre></td></tr></table></figure>

<h4 id="思路分析-5"><a href="#思路分析-5" class="headerlink" title="思路分析"></a>思路分析</h4><ul>
<li><p>两个状态变量</p>
<ul>
<li>cash：不持有股票的最大利润</li>
<li>hold：持有股票的最大利润</li>
</ul>
</li>
<li><p>状态转移方程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cash = Math.max(cash, hold + prices[i]);</span><br><span class="line">hold = Math.max(hold, cash - prices[i]);</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>两个方程先后顺序可以互换，cash和hold只能有一个发生变化，所以不需要临时变量<br>比如cash变为hold + prices[i] - fee，cash - prices[i] = hold + prices[i] - fee - prices[i] = hold -fee，永远小于 hold</strong></li>
</ul>
</li>
<li><p><strong>为什么不用临时变量</strong></p>
</li>
</ul>
<h4 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul>
<li>时间复杂度O(n)</li>
<li>空间复杂度O(1)</li>
</ul>
<h4 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">method6</span><span class="params">(<span class="keyword">int</span>[] prices)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cash = <span class="number">0</span>, hold = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//cash只能有一个发生变化，所以不需要临时变量</span></span><br><span class="line">            cash = Math.max(cash, hold + prices[i]);</span><br><span class="line">            hold = Math.max(hold, cash - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cash;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="3-可购买任意次（冷冻期）"><a href="#3-可购买任意次（冷冻期）" class="headerlink" title="3. 可购买任意次（冷冻期）"></a>3. 可购买任意次（冷冻期）</h2><h4 id="问题描述-4"><a href="#问题描述-4" class="headerlink" title="问题描述"></a>问题描述</h4><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。</p>
<p>注意：你不能在买入股票前卖出股票。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出，最大利润 &#x3D; 6-1 &#x3D; 5 。</span><br><span class="line">     注意利润不能是 7-1 &#x3D; 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</span><br><span class="line"></span><br><span class="line">来源：力扣（LeetCode）</span><br></pre></td></tr></table></figure>

<h4 id="思路分析-6"><a href="#思路分析-6" class="headerlink" title="思路分析"></a>思路分析</h4><ul>
<li><strong>为什么不用临时变量和用临时变量</strong></li>
<li>添加一个变量<ul>
<li>cool：记录冷冻期的最大利润</li>
</ul>
</li>
<li>和上面第二个问题的区别：在不持有股票的时候<strong>不再是从上一次持有股票的时候</strong>减去今天的股价，而<strong>是从上一个冷冻期</strong>减去今天的股价。</li>
</ul>
<h4 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul>
<li>时间复杂度O(n)</li>
<li>空间复杂度O(1)</li>
</ul>
<h4 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">没用临时变量</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">method3</span><span class="params">(<span class="keyword">int</span>[] prices)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cash = <span class="number">0</span>, hold = -prices[<span class="number">0</span>],cool = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            cash = Math.max(cash, cool + prices[i]);</span><br><span class="line">            cool = Math.max(cash,cool);</span><br><span class="line">            hold = Math.max(hold, cash - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cash;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">用临时变量之后</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cash = <span class="number">0</span>, hold = -prices[<span class="number">0</span>],cool = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cash2 = <span class="number">0</span>, hold2 = -prices[<span class="number">0</span>],cool2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//重点在这三个表达式顺序，有没有依赖关系，在这个问题有，最好加上临时变量，或者按照method3的顺序，再只含有cash 和 hold的没有依赖关系，所以不用临时变量</span></span><br><span class="line">            hold = Math.max(hold2, cool2 - prices[i]);</span><br><span class="line">            cool = Math.max(cash2,cool2);</span><br><span class="line">            cash = Math.max(cash2, hold2 + prices[i]);</span><br><span class="line">            </span><br><span class="line">            hold2 = hold;</span><br><span class="line">            cool2 = cool;</span><br><span class="line">            cash2 = cash;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cash;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="4-可购买任意次（手续费）"><a href="#4-可购买任意次（手续费）" class="headerlink" title="4. 可购买任意次（手续费）"></a>4. 可购买任意次（手续费）</h2><h4 id="问题描述-5"><a href="#问题描述-5" class="headerlink" title="问题描述"></a>问题描述</h4><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p>
<p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p>示例1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 7</span><br><span class="line">解释: 在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 3 天（股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5-1 &#x3D; 4 。</span><br><span class="line">     随后，在第 4 天（股票价格 &#x3D; 3）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出, 这笔交易所能获得利润 &#x3D; 6-3 &#x3D; 3 。</span><br><span class="line"></span><br><span class="line">来源：力扣（LeetCode）</span><br></pre></td></tr></table></figure>

<h4 id="思路分析-7"><a href="#思路分析-7" class="headerlink" title="思路分析"></a>思路分析</h4><ul>
<li>和第二个问题区别：再不持有股票有可能<strong>发生卖股票的活动时</strong>，需要减去fee</li>
</ul>
<h4 id="复杂度分析-3"><a href="#复杂度分析-3" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul>
<li>时间复杂度O(n)</li>
<li>空间复杂度O(1)</li>
</ul>
<h4 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">method6</span><span class="params">(<span class="keyword">int</span>[] prices,<span class="keyword">int</span> fee)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cash = <span class="number">0</span>, hold = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//cash和hold只能有一个发生变化，所以不需要临时变量</span></span><br><span class="line">            <span class="comment">//比如cash变为hold + prices[i] - fee，cash - prices[i] = hold + prices[i] - fee - prices[i] = hold -fee，永远小于 hold</span></span><br><span class="line">            cash = Math.max(cash, hold + prices[i] - fee);</span><br><span class="line">            hold = Math.max(hold, cash - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cash;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="5-可购买2次"><a href="#5-可购买2次" class="headerlink" title="5. 可购买2次"></a>5. 可购买2次</h2><h4 id="问题描述-6"><a href="#问题描述-6" class="headerlink" title="问题描述"></a>问题描述</h4><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。</p>
<p>注意：你不能在买入股票前卖出股票。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出，最大利润 &#x3D; 6-1 &#x3D; 5 。</span><br><span class="line">     注意利润不能是 7-1 &#x3D; 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</span><br><span class="line"></span><br><span class="line">来源：力扣（LeetCode）</span><br></pre></td></tr></table></figure>

<h4 id="思路分析-8"><a href="#思路分析-8" class="headerlink" title="思路分析"></a>思路分析</h4><ol>
<li><p>判断数组的长度和是否为空</p>
</li>
<li><p>确定两个状态数组</p>
<ul>
<li>dp0: 不持有股票时的最大利润</li>
<li>dp1: 持有股票后的最大利润</li>
</ul>
</li>
<li><p>初始化：dp0 全部位0；dp1根据股价变化</p>
</li>
<li><p><strong>状态转移方程</strong></p>
<ul>
<li><p><strong>为什么dp0是j-1，而dp1是j？</strong></p>
<p>因为dp0表示的是不持有股票，如果需要买的话，肯定是上一次卖玩后买所以是j-1次；</p>
<p>而dp1是持有股票，需要卖的话一定是这次不持有股票（买或者不买）的数据，j次。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp0[i][j] &#x3D; Math.max(dp0[i-1][j],dp1[i-1][j-1] + prices[i]);</span><br><span class="line">dp1[i][j] &#x3D; Math.max(dp1[i-1][j],dp0[i-1][j] - prices[i]);</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="复杂度分析-4"><a href="#复杂度分析-4" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(n),可优化，第6个问题即优化后的版本</li>
</ul>
<h4 id="代码实现-7"><a href="#代码实现-7" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">method4</span><span class="params">(<span class="keyword">int</span>[] prices)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(prices.length == <span class="number">0</span> &amp;&amp; prices == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> max = <span class="number">0</span>,k = <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> days = prices.length;</span><br><span class="line">            <span class="keyword">int</span>[][] dp0 = <span class="keyword">new</span> <span class="keyword">int</span>[days][k + <span class="number">1</span>];<span class="comment">//不持有股票时的最大利润</span></span><br><span class="line">            <span class="keyword">int</span>[][] dp1 = <span class="keyword">new</span> <span class="keyword">int</span>[days][k + <span class="number">1</span>]; <span class="comment">//持有股票后的最大利润</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//初始化dp数组:dp0不持有即全部为0，自动初始化即可完成;dp1在第一天持有股票最大利润只能是-prices[0]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            dp1[<span class="number">0</span>][i] = -prices[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//第二天到最后一天最大利润要根据当天股价决定</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; days; i++) &#123;</span><br><span class="line">            dp1[i][<span class="number">0</span>] = Math.max(dp1[i - <span class="number">1</span>][<span class="number">0</span>],-prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; days; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; k + <span class="number">1</span>; j++) &#123;</span><br><span class="line">                dp0[i][j] = Math.max(dp0[i-<span class="number">1</span>][j],dp1[i-<span class="number">1</span>][j-<span class="number">1</span>] + prices[i]);</span><br><span class="line">                dp1[i][j] = Math.max(dp1[i-<span class="number">1</span>][j],dp0[i-<span class="number">1</span>][j] - prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            max = Math.max(dp0[days - <span class="number">1</span>][i],max);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="6-可购买k次"><a href="#6-可购买k次" class="headerlink" title="6. 可购买k次"></a>6. 可购买k次</h2><h4 id="问题描述-7"><a href="#问题描述-7" class="headerlink" title="问题描述"></a>问题描述</h4><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。</p>
<p>注意：你不能在买入股票前卖出股票。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出，最大利润 &#x3D; 6-1 &#x3D; 5 。</span><br><span class="line">     注意利润不能是 7-1 &#x3D; 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</span><br><span class="line"></span><br><span class="line">来源：力扣（LeetCode）</span><br></pre></td></tr></table></figure>

<h4 id="思路分析-9"><a href="#思路分析-9" class="headerlink" title="思路分析"></a>思路分析</h4><ol>
<li><p>判断数组的长度和是否为空</p>
</li>
<li><p>确定两个状态数组</p>
<ol>
<li>dp0: 不持有股票时的最大利润</li>
<li>dp1: 持有股票后的最大利润</li>
</ol>
</li>
<li><p>初始化：dp0 全部位0；dp1根据股价变化</p>
</li>
<li><p>状态转移方程</p>
<ul>
<li><strong>为什么dp0是j-1，而dp1是j？</strong></li>
</ul>
<p>因为dp0表示的是不持有股票，如果需要买的话，肯定是上一次卖玩后买所以是j-1次；</p>
<p>而dp1是持有股票，需要卖的话一定是这次不持有股票（买或者不买）的数据，j次。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp0[j] &#x3D; Math.max(dp0[j],dp1[j-1] + prices[i]);</span><br><span class="line">dp1[j] &#x3D; Math.max(dp1[j],dp0[j] - prices[i]);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>在购买days / 2 次以上时，会出现错误，因为最多days / 2次即可完成所有情况，超过即可看作没有规定购买次数，回到第2个问题，要分类讨论</strong></p>
</li>
</ol>
<h4 id="复杂度分析-5"><a href="#复杂度分析-5" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)</li>
</ul>
<h4 id="代码实现-8"><a href="#代码实现-8" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">method5</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span>[] prices)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.length == <span class="number">0</span> &amp;&amp; prices == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> days = prices.length;</span><br><span class="line">    </span><br><span class="line">    	<span class="comment">//最多购卖 days / 2次，如果超出，按照无限制处理，回到了任意次</span></span><br><span class="line">        <span class="keyword">if</span>(k &gt; days / <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; days; i++) &#123;</span><br><span class="line">                max += Math.max(prices[i+<span class="number">1</span>] - prices[i],<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> max;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">int</span>[] dp0 = <span class="keyword">new</span> <span class="keyword">int</span>[k + <span class="number">1</span>];<span class="comment">//不持有股票时的最大利润</span></span><br><span class="line">        <span class="keyword">int</span>[] dp1 = <span class="keyword">new</span> <span class="keyword">int</span>[k + <span class="number">1</span>]; <span class="comment">//持有股票后的最大利润</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            dp1[i] = -prices[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; days - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            dp1[<span class="number">0</span>] = Math.max(dp1[<span class="number">0</span>], - prices[i]);<span class="comment">//初始化，db1[0]即上次</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; k + <span class="number">1</span>; j++) &#123;</span><br><span class="line">                dp0[j] = Math.max(dp0[j],dp1[j-<span class="number">1</span>] + prices[i]);</span><br><span class="line">                dp1[j] = Math.max(dp1[j],dp0[j] - prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            max = Math.max(dp0[i],max);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="523-连续的子数组和"><a href="#523-连续的子数组和" class="headerlink" title="523. 连续的子数组和"></a>523. 连续的子数组和</h1><h6 id="问题描述-8"><a href="#问题描述-8" class="headerlink" title="问题描述"></a>问题描述</h6><p>给定一个包含非负数的数组和一个目标整数 k，编写一个函数来判断该数组是否含有连续的子数组，其大小至少为 2，总和为 k 的倍数，即总和为 n*k，其中 n 也是一个整数。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [23,2,4,6,7], k &#x3D; 6</span><br><span class="line">输出: True</span><br><span class="line">解释: [2,4] 是一个大小为 2 的子数组，并且和为 6。</span><br></pre></td></tr></table></figure>

<p>来源：力扣（LeetCode）</p>
<h6 id="思路分析-10"><a href="#思路分析-10" class="headerlink" title="思路分析"></a>思路分析</h6><ul>
<li>利用Hashmap</li>
</ul>
<h6 id="时间复杂度-4"><a href="#时间复杂度-4" class="headerlink" title="时间复杂度"></a>时间复杂度</h6><h6 id="空间复杂度-4"><a href="#空间复杂度-4" class="headerlink" title="空间复杂度"></a>空间复杂度</h6><h6 id="代码实现-9"><a href="#代码实现-9" class="headerlink" title="代码实现"></a>代码实现</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h1 id><a href="#" class="headerlink" title></a></h1>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/111zx/111zx.github.io/2020/05/12/leetcode/" data-id="ckbbzdvs80004t8ubdpgh1t35" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-集合" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/31/%E9%9B%86%E5%90%88/" class="article-date">
  <time datetime="2020-03-31T01:55:33.000Z" itemprop="datePublished">2020-03-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/31/%E9%9B%86%E5%90%88/">集合</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<h1 id="集合框架的概述"><a href="#集合框架的概述" class="headerlink" title="集合框架的概述"></a>集合框架的概述</h1><h2 id="集合与数组的比较"><a href="#集合与数组的比较" class="headerlink" title="集合与数组的比较"></a>集合与数组的比较</h2><ul>
<li><p>集合与数组都是对多个数据进行存储的，简称Java容器</p>
<ul>
<li><p>说明：<strong>此时的存储主要是内存层面的存储</strong>，不涉及到持久化(硬盘)的存储。例如.txt,.sql都是硬盘存储</p>
<h4 id="数组在存储多个数据方面的优缺点"><a href="#数组在存储多个数据方面的优缺点" class="headerlink" title="数组在存储多个数据方面的优缺点"></a>数组在存储多个数据方面的优缺点</h4></li>
<li><p>优点：</p>
<ul>
<li>一旦初始化以后，<strong>长度是确定的</strong></li>
<li>数组一旦定义好，元素的类型也确定了，只能操作<strong>确定类型</strong>的数据。Object[] arr可以实现<strong>多态</strong></li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>一旦初始化好，长度不可修改</li>
<li>数组中提供的操作等<strong>方法非常有限</strong>，效率低</li>
<li>获取数组中<strong>实际元素的个数，数组中没有</strong>现成的方法</li>
<li>数组存储数据的特点：<strong>有序，可重复</strong>。对于无序，不可重复的需求，不能满足</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="集合框架体系"><a href="#集合框架体系" class="headerlink" title="集合框架体系"></a>集合框架体系</h2><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>大概分为Collection和Map两种体系</p>
<ul>
<li>Collection接口，单列集合，用来存储一个一个的对象<ul>
<li>List：有序，可重复。<strong>“动态”</strong>数组</li>
<li>Set：无序，不可重复。类似于高中课本上的集合</li>
</ul>
</li>
<li>Map接口：双列集合，用来存储一对（key，value）的数组。类似于高中课本上的函数y = value（key），一个key不可以对应多个value</li>
</ul>
<hr>
<h3 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h3><h4 id="方法总结"><a href="#方法总结" class="headerlink" title="方法总结"></a>方法总结</h4><h5 id="add"><a href="#add" class="headerlink" title="add()"></a>add()</h5><h5 id="addAll"><a href="#addAll" class="headerlink" title="addAll()"></a>addAll()</h5><ul>
<li>将一个集合中的元素全部加到当前集合</li>
</ul>
<h5 id="isEmpty"><a href="#isEmpty" class="headerlink" title="isEmpty()"></a>isEmpty()</h5><h5 id="clear"><a href="#clear" class="headerlink" title="clear()"></a>clear()</h5><ul>
<li>清空集合元素的<strong>数据</strong></li>
</ul>
<h5 id="contains"><a href="#contains" class="headerlink" title="contains()"></a>contains()</h5><ul>
<li><p>判断当前集合中是否包含括号内元素</p>
</li>
<li><p>调用的是括号内类元素的内置<strong>equals()方法</strong>，String类（重写了equals()方法，比的是变量）和一般的没有重写equals()方法的类contains()结果会有出入</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> Collection coll = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        coll.add(<span class="keyword">new</span> String(<span class="string">"Tom"</span>));</span><br><span class="line">        coll.add(<span class="keyword">new</span> Person(<span class="string">"jerry"</span>,<span class="number">20</span>));</span><br><span class="line">		System.out.println(coll.contains(<span class="keyword">new</span> String(<span class="string">"Tom"</span>)));<span class="comment">//equals比内容</span></span><br><span class="line">		System.out.println(coll.contains(<span class="keyword">new</span> Person(<span class="string">"jerry"</span>,<span class="number">20</span>)));<span class="comment">//equals比地址</span></span><br><span class="line">输出：</span><br><span class="line">    <span class="keyword">true</span></span><br><span class="line">    <span class="keyword">false</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="containsAll"><a href="#containsAll" class="headerlink" title="containsAll()"></a>containsAll()</h5><ul>
<li>判断括号内集合中的元素是否<strong>都包含</strong>在当前集合内</li>
</ul>
<h5 id="remove"><a href="#remove" class="headerlink" title="remove()"></a>remove()</h5><ul>
<li>也会调用<strong>equals()</strong>方法</li>
</ul>
<h5 id="removeAll"><a href="#removeAll" class="headerlink" title="removeAll()"></a>removeAll()</h5><ul>
<li><strong>差集</strong></li>
<li>从当前集合移除括号内集合所有的元素</li>
</ul>
<h5 id="retainAll"><a href="#retainAll" class="headerlink" title="retainAll()"></a>retainAll()</h5><ul>
<li>当前集合和括号内集合的<strong>交集</strong></li>
</ul>
<h5 id="equals"><a href="#equals" class="headerlink" title="equals()"></a>equals()</h5><ul>
<li>比较括号内元素是否相等</li>
</ul>
<h5 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode()"></a>hashCode()</h5><ul>
<li>根据集合内元素，返回哈希值</li>
</ul>
<h5 id="toArray"><a href="#toArray" class="headerlink" title="toArray()"></a>toArray()</h5><ul>
<li>集合转换为数组</li>
<li>数组转变为集合：<ul>
<li>ArrayList list = Arrays.asList({1,2,3})</li>
<li><strong>ArrayList list = Arrays.asList(new int[]{1,2,3})</strong>会出错，被认为是一个数组元素</li>
<li><strong>ArrayList list = Arrays.asList(new Integer[]{1,2,3})</strong>正确，包装类被认为是两个元素</li>
</ul>
</li>
</ul>
<h5 id="iterator"><a href="#iterator" class="headerlink" title="iterator()"></a>iterator()</h5><ul>
<li><p>集合元素的遍历，实现了Iterator接口</p>
</li>
<li><p>hasNext()和next()方法的使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Iterator iterator = coll1.iterator();<span class="comment">//iterator是一个对象实现了Iterator接口，不是容器</span></span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>迭代器执行原理</p>
<ul>
<li>hasNext()只是判断下一个地址有没有数据</li>
<li>next()是指针下移一个位置，指针一开始再第一个的钱一个位置</li>
</ul>
</li>
<li><p>错误写法</p>
<ul>
<li><pre><code class="java"><span class="keyword">while</span>((iterator.next() != <span class="keyword">null</span>)){<span class="comment">//每次调用next()都会下移一位，会丢数据</span>
    <span class="comment">//有可能while循环里的元素是最后一个，不是空，但是执行完之后下移一个，指针变为空，会出空指针现异常</span>
            System.out.println(iterator.next());
        }
&lt;!--￼<span class="number">2</span>--&gt;</code></pre>
</li>
</ul>
</li>
<li><p>每次调用iterator()方法，会生成一个迭代器</p>
</li>
<li><p>remove()方法</p>
<ul>
<li><pre><code class="java"><span class="comment">//删除集合中的"Tom"元素</span>
<span class="keyword">while</span>(iterator.hasNext()){
            Object obj = iterator.next();
            <span class="keyword">if</span>(obj.equals(<span class="string">"Tom"</span>)){
                iterator.remove();
            }
        }
&lt;!--￼<span class="number">3</span>--&gt;</code></pre>
</li>
</ul>
</li>
<li><p><strong>内部调用的还是Iterator</strong></p>
</li>
</ul>
<h4 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h4><h5 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h5><ul>
<li><strong>有序，可重复</strong></li>
<li>每个元素都有对应的顺序索引</li>
<li>ArrayList,LinkedList和Vector区别和联系<ul>
<li>相同点：<ul>
<li>都实现了List接口，存储有序，可重复的</li>
</ul>
</li>
<li>不同点<ul>
<li>Vector是1.2出现的，古老版本。<strong>效率低，线程安全</strong>。底层使用<strong>Object[]</strong>实现。利用了synchronized关键字。</li>
<li>ArrayList：<strong>效率高，线程不安全</strong>。底层使用<strong>Object[]</strong>实现。删除操作时顺序执行。例如，在10000个元素中删掉第三个元素，从第4个到第10000个元素都得变化。</li>
<li>LinkedList：底层是使用<strong>双向链表</strong>。对于频繁插入和<strong>删除</strong>操作，效率比ArrayList高</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h5><h6 id="源码分析（jdk7）"><a href="#源码分析（jdk7）" class="headerlink" title="源码分析（jdk7）"></a>源码分析（jdk7）</h6><ul>
<li><p>底层：Object[] element</p>
</li>
<li><p>构造函数：ArrayList list = new ArrayList（）。<strong>默认</strong>初始有<strong>10</strong>个元素</p>
<ul>
<li><pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>{
        <span class="keyword">super</span>();
        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)
            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+
                                               initialCapacity);
        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];
    }
<span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>{
        <span class="keyword">this</span>(<span class="number">10</span>);
    }
&lt;!--￼<span class="number">4</span>--&gt;</code></pre>
</li>
</ul>
</li>
<li><p><strong>扩容源码</strong></p>
<ul>
<li><pre><code class="java"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>{
        <span class="comment">// overflow-conscious code</span>
        <span class="keyword">int</span> oldCapacity = elementData.length;
        <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);<span class="comment">//变更为1.5倍</span>

    <span class="comment">//如果不够，变为传过来的参数minCapacity</span>
        <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)
            newCapacity = minCapacity;

    <span class="comment">//如果还不够，变为一个提前设置的最大值</span>
    <span class="comment">//再不够，到整型最大值，不够就error</span>
        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)
            newCapacity = hugeCapacity(minCapacity);
        <span class="comment">// minCapacity is usually close to size, so this is a win:建立一个新的数组，把原来的值copy进去，再赋值给elementData</span>
        elementData = Arrays.copyOf(elementData, newCapacity);
    }
&lt;!--￼<span class="number">5</span>--&gt;</code></pre>
</li>
</ul>
</li>
<li><p>此一次调用<strong>add()</strong>方法时，才创建了长度为10的数组，并将数组添加到集合中、</p>
<ul>
<li><pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>{
        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span>
        elementData[size++] = e;
        <span class="keyword">return</span> <span class="keyword">true</span>;
    }
<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>{
        ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));
    }

<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateCapacity</span><span class="params">(Object[] elementData, <span class="keyword">int</span> minCapacity)</span> </span>{
        <span class="comment">//DEFAULT_CAPACITY为10，是默认值</span>
        <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
            <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);
        }
        <span class="keyword">return</span> minCapacity;
        }
<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>{
        modCount++;

        <span class="comment">// overflow-conscious code</span>
        <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)
            grow(minCapacity);
    }
&lt;!--￼<span class="number">6</span>--&gt;</code></pre>
</li>
</ul>
</li>
<li><p>add()</p>
<ul>
<li><pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>{
        linkLast(e);
        <span class="keyword">return</span> <span class="keyword">true</span>;
    }

<span class="comment">/**</span>
<span class="comment">     * Links e as last element.</span>
<span class="comment">     */</span>
<span class="comment">//链表的尾部加如节点</span>
<span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>{
        <span class="keyword">final</span> Node&lt;E&gt; l = last;
        <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);
        last = newNode;
        <span class="keyword">if</span> (l == <span class="keyword">null</span>)<span class="comment">//空的时候</span>
            first = newNode;
        <span class="keyword">else</span>
            l.next = newNode;
        size++;
        modCount++;
    }
&lt;!--￼<span class="number">7</span>--&gt;
</code></pre>
</li>
</ul>
</li>
</ul>
<h6 id="addAll-ArrayList"><a href="#addAll-ArrayList" class="headerlink" title="addAll(ArrayList)"></a>addAll(ArrayList)</h6><ul>
<li><pre><code class="java">list.addAll(list1)<span class="comment">//list1的元素全部添加到list中</span>
&lt;!--￼<span class="number">8</span>--&gt;
</code></pre>
</li>
</ul>
<h6 id="indexof-Object"><a href="#indexof-Object" class="headerlink" title="indexof(Object)"></a>indexof(Object)</h6><ul>
<li><pre><code class="java"><span class="keyword">int</span> index = list.indexOf(<span class="number">123</span>)<span class="comment">//判断123在list的第一次出现的位置上，没有的化返回-1</span>
&lt;!--￼<span class="number">9</span>--&gt;
</code></pre>
</li>
</ul>
<h6 id="remove-index"><a href="#remove-index" class="headerlink" title="remove(index)"></a>remove(index)</h6><ul>
<li><p>和Collection中的remove()不同，这个是删除索引位置，而前一个是删除指定内容元素</p>
</li>
<li><pre><code class="java">list.remove(<span class="number">4</span>)<span class="comment">//返回删除索引位置4上的元素</span>
list.add(<span class="number">2</span>)
list.remove(<span class="number">2</span>)<span class="comment">//会出现错误，没有调用Collection的remove，而停在了List的remove上</span>
&lt;!--￼<span class="number">10</span>--&gt;
</code></pre>
</li>
</ul>
<h6 id="sublist-indexl，indexr"><a href="#sublist-indexl，indexr" class="headerlink" title="sublist(indexl，indexr)"></a>sublist(indexl，indexr)</h6><ul>
<li><pre><code class="java"><span class="comment">//返回一个左闭右开的一子集和，不会对原来的集合造成影响</span>
list.sublist(<span class="number">2</span>，<span class="number">4</span>)
&lt;!--￼<span class="number">11</span>--&gt;

- ```java
  map.put(key1,value1)<span class="comment">//首先调用key1所在类的hashCode()计算key1哈希值，此哈希值经过某种计算之后，会得到在Entry数组中的存放位置</span>
      <span class="comment">//如果位置上为空，则(key1,value1)添加成功</span>
      <span class="comment">//如果不为空（意味着此位置存在一个或者多个元素（多个存放在链表上）），则需要比较key和其他数据的哈希值</span>
          <span class="comment">//如果key1的哈希值和其他的哈希值都不相同，则添加成功</span>
          <span class="comment">//如果存在哈希值相同，调用key1所在类的equals方法</span>
              <span class="comment">//如果返回false，此时添加成功</span>
              <span class="comment">//如果返回true，使用value1替换相同key的value值。（修改了key1值相同的value值）</span>
  &lt;!--￼<span class="number">12</span>--&gt;

- 底层是以一个数组Entry[]存储，每个数组的对象包含<span class="number">4</span>个属性。其中next将每个数组对象组织成了链表</code></pre>
</li>
<li><p>put(key,value) </p>
<ul>
<li><pre><code class="java"><span class="number">1</span>. <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>{
<span class="number">2</span>. <span class="comment">// HashMap 允许存放 null 键和 null 值。</span>
<span class="number">3</span>. <span class="comment">// 当 key 为 null 时，调用 putForNullKey 方法，将 value 放置在数组第一个位置。</span>
<span class="number">4</span>.         <span class="keyword">if</span> (key == <span class="keyword">null</span>)
<span class="number">5</span>.             <span class="keyword">return</span> putForNullKey(value);
<span class="number">6</span>. <span class="comment">// 根据 key 的 keyCode 重新计算 hash 值。</span>
<span class="number">7</span>.         <span class="keyword">int</span> hash = hash(key.hashCode());
<span class="number">8</span>. <span class="comment">// 搜索指定 hash 值在对应 table 中的索引。</span>
<span class="number">9</span>.         <span class="keyword">int</span> i = indexFor(hash, table.length);
<span class="number">10</span>. <span class="comment">// 如果 i 索引处的 Entry 不为 null，通过循环不断遍历 e 元素的下一个元素。</span>
<span class="number">11</span>.     <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) {
<span class="number">12</span>.         Object k;
<span class="number">13</span>.         <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) {
<span class="number">14</span>.             V oldValue = e.value;
<span class="number">15</span>.             e.value = value;
<span class="number">16</span>.             e.recordAccess(<span class="keyword">this</span>);
<span class="number">17</span>.             <span class="keyword">return</span> oldValue;
<span class="number">18</span>.         }
<span class="number">19</span>.        }
<span class="number">20</span>. <span class="comment">// 如果 i 索引处的 Entry 为 null，表明此处还没有 Entry。</span>
<span class="number">21</span>.     modCount++;
<span class="number">22</span>. <span class="comment">// 将 key、value 添加到 i 索引处。</span>
<span class="number">23</span>.     addEntry(hash, key, value, i);
<span class="number">24</span>.     <span class="keyword">return</span> <span class="keyword">null</span>;
<span class="number">25</span>. }
&lt;!--￼<span class="number">13</span>--&gt;

- resize(<span class="number">2</span> * table.length)

&lt;!--￼<span class="number">14</span>--&gt;

- transfer(newTable, rehash)

  &lt;!--￼<span class="number">15</span>--&gt;


</code></pre>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>*hash(int h)</p>
<ul>
<li><pre><code class="java"><span class="comment">//hash(int h)方法根据 key 的 hashCode 重新计算一次散列。此算法加入了高位计算，防</span>
<span class="comment">//止低位不变，高位变化时，造成的 hash 冲突</span>
<span class="number">1</span>. <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> h)</span> </span>{
<span class="number">2</span>.         h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);
<span class="number">3</span>.         <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);
<span class="number">4</span>. }
&lt;!--￼<span class="number">16</span>--&gt;</code></pre>
</li>
</ul>
</li>
<li><p>get(Object key)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line"><span class="number">2</span>. 		<span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line"><span class="number">3</span>. 			<span class="keyword">return</span> getForNullKey();</span><br><span class="line"><span class="number">4</span>. 		<span class="keyword">int</span> hash = hash(key.hashCode());</span><br><span class="line"><span class="number">5</span>. 		<span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];e != <span class="keyword">null</span>;e = e.next)&#123;</span><br><span class="line"><span class="number">8</span>. 			Object k;</span><br><span class="line"><span class="number">9</span>. 			<span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k)))</span><br><span class="line"><span class="number">10</span>. 			<span class="keyword">return</span> e.value;</span><br><span class="line"><span class="number">11</span>. 		&#125;</span><br><span class="line"><span class="number">12</span>. 	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"><span class="number">13</span>. &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>getForNullKey()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在下标为1的数组元素开始遍历链表，找到key为NULL的value</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">getForNullKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[<span class="number">0</span>]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.key == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> e.value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>构造器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//默认数组长度16和负载因子0.75</span></span><br><span class="line">        <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)<span class="comment">//数组长度非法</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)<span class="comment">//数组长度超出最大值，强行以最大值构造</span></span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))<span class="comment">//负载因子非法</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                               loadFactor);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Find a power of 2 &gt;= initialCapacity</span></span><br><span class="line">        <span class="keyword">int</span> capacity = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (capacity &lt; initialCapacity)</span><br><span class="line">            capacity &lt;&lt;= <span class="number">1</span>;<span class="comment">//从2^0开始，保证数组的长度是2^n，有利于查找时的效率优化h&amp;（length-1）</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="comment">//最大不扩容数组长度 capacity * loadFactor</span></span><br><span class="line">        threshold = (<span class="keyword">int</span>)Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">        table = <span class="keyword">new</span> Entry[capacity];</span><br><span class="line">        useAltHashing = sun.misc.VM.isBooted() &amp;&amp;</span><br><span class="line">                (capacity &gt;= Holder.ALTERNATIVE_HASHING_THRESHOLD);</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<ul>
<li><p>remove</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//简单的链表删除节点操作</span></span><br><span class="line"><span class="comment">//根据hashcode算hash，再根据hash算index然后判断，删除</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">removeEntryForKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key);</span><br><span class="line">        <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">        Entry&lt;K,V&gt; prev = table[i];</span><br><span class="line">        Entry&lt;K,V&gt; e = prev;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">            Object k;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                modCount++;</span><br><span class="line">                size--;</span><br><span class="line">                <span class="keyword">if</span> (prev == e)</span><br><span class="line">                    table[i] = next;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    prev.next = next;</span><br><span class="line">                e.recordRemoval(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">return</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">            prev = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>Fail-Fast机制</p>
<ul>
<li><p>由于HashMap是线程不安全的，所以当有其他的线程修改了Map，modCount这个值就会发生改变，迭代器初始化过程中会将这个值赋值为expectedModCount。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. HashIterator() &#123;</span><br><span class="line"><span class="number">2</span>. 		expectedModCount = modCount;</span><br><span class="line"><span class="number">3</span>. 		<span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123; <span class="comment">// advance to first entry</span></span><br><span class="line"><span class="number">4</span>. 			Entry[] t = table;</span><br><span class="line"><span class="number">5</span>. 			<span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>)</span><br><span class="line"><span class="number">6</span>. 				;</span><br><span class="line"><span class="number">7</span>. 		&#125;</span><br><span class="line"><span class="number">8</span>. &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在迭代过程中，会判断expectedModCount 和 modCount值是否相等，不相等就会抛出ConcurrentModificationException异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. <span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">nextEntry</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="number">2</span>.	 	<span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line"><span class="number">3</span>.	 		<span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br></pre></td></tr></table></figure>
</li>
<li><p>编写依赖于此异常的程序的做法是错误的，正确做法是：迭代器的快速失败行为应该仅用于检测程序错误</p>
</li>
</ul>
</li>
</ul>
<h6 id="jdk8"><a href="#jdk8" class="headerlink" title="jdk8"></a>jdk8</h6><ul>
<li><p>一开始没有创建数组，put时创建</p>
</li>
<li><p>HashMap的属性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认的初始容量为 16</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br><span class="line"><span class="comment">//最大的容量上限为 2^30</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="comment">//默认的负载因子为 0.75</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"><span class="comment">//变成树型结构的临界值为 8</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"><span class="comment">//恢复链式结构的临界值为 6</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"><span class="comment">//哈希表</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"><span class="comment">//哈希表中键值对的个数</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"><span class="comment">//哈希表被修改的次数</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"><span class="comment">//它是通过 capacity*load factor 计算出来的，当 size 到达这个值时，</span></span><br><span class="line">就会进行扩容操作</span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"><span class="comment">//负载因子</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"><span class="comment">//当哈希表的大小超过这个阈值，才会把链式结构转化成树型结构，否则仅采取扩容来尝试减少冲突</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>HashMap中的节点不再是Entry，而实Node,具体作用和Entry相同</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"> <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line"> <span class="keyword">final</span> K key;</span><br><span class="line"> V value;</span><br><span class="line"> Node&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>get()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//get 方法主要调用的是 getNode 方法，所以重点要看 getNode 方法的实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">	Node&lt;K,V&gt; e;</span><br><span class="line">	<span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span>: e.value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">	Node&lt;K,V&gt;[] tab; </span><br><span class="line">   Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">	<span class="comment">//如果哈希表不为空 &amp;&amp; key 对应的桶上不为空</span></span><br><span class="line">	<span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;(first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="comment">//是否直接命中</span></span><br><span class="line">		<span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">		((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">			<span class="keyword">return</span> first;</span><br><span class="line">		<span class="comment">//判断是否有后续节点</span></span><br><span class="line">		<span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">//如果当前的桶是采用红黑树处理冲突，则调用红黑树的 get 方法去获取节点</span></span><br><span class="line">			<span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">				<span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">			<span class="comment">//不是红黑树的话，那就是传统的链式结构了，通过循环的方法判断链中是否存在该 key</span></span><br><span class="line">		 <span class="keyword">do</span> &#123;</span><br><span class="line">			 <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; </span><br><span class="line">			key.equals(k))))</span><br><span class="line">					<span class="keyword">return</span> e;</span><br><span class="line">					 &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>put()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">//如果哈希表为空，新创建一个新哈希表</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">//如果哈希表的对应位置为空，则直接插入键值对</span></span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            <span class="comment">//如果哈希值和key值都相等，那么出现重复的键值对，到最后换value即可</span></span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                e = p;</span><br><span class="line">            <span class="comment">//如果链表的结构已经编程了红黑树，那么进行红黑树插值处理</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="comment">//如果不是红黑树结构，那么就是链表结构，进行遍历查找相同key值节点</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                    <span class="comment">//如果没找到相等key值得节点，那么就在链表的末尾直接插入节点</span></span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                        <span class="comment">//如果一个链表的长度大于等于8，就会判断数组长度是否大于64</span></span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//如果找到了key值相同的节点，那么将p的信息修改为相同节点的信息</span></span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//修改key值相同的节点的value值</span></span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>resize()</strong></p>
<ul>
<li><strong>和jdk7有所不同，表现在从旧表网新表插入数据时的方法</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">        <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;<span class="comment">//旧表的长度</span></span><br><span class="line">        <span class="keyword">int</span> oldThr = threshold;<span class="comment">//旧表的阈值</span></span><br><span class="line">        <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//如果旧表的长度大于0</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//如果旧表的长度大于最大值，赋值最大值，不可再扩容</span></span><br><span class="line">            <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">                threshold = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">return</span> oldTab;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果新表的长度（2倍）合法的话，阈值也翻一倍</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">                newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//带有初始阈值参数的构造器，哈希表长度变为传进来的参数</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">            newCap = oldThr;</span><br><span class="line">    <span class="comment">//如股票还没有创建表，则初始化表的长度和阈值</span></span><br><span class="line">        <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">            newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">            newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//如果新的阈值等于0，则根据哈希表的长度计算阈值</span></span><br><span class="line">        <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                      (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        threshold = newThr;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">    <span class="comment">//根据新表的长度创建新表</span></span><br><span class="line">            Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">        table = newTab;</span><br><span class="line">        <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">                Node&lt;K,V&gt; e;</span><br><span class="line">                <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="comment">//如果位置为空，直接插入</span></span><br><span class="line">                    <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                        newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                    <span class="comment">//有树结构，树插入</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                    <span class="comment">//链表插入</span></span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    扩容每次乘以2的原因：增加了1位数据，n-1 相比 之前的 n - 1必定是多了一位1</span></span><br><span class="line"><span class="comment">                    这一位和原来的hash值进行 &amp; 操作时，只有两种情况：</span></span><br><span class="line"><span class="comment">                    等于0，计算结果和原来相同，位置不变</span></span><br><span class="line"><span class="comment">                    等于1，计算结果比原来相比，多了一个固定的值：2^( n-1 )</span></span><br><span class="line"><span class="comment">                    这样一来  原来位置的数据必定分成两拨存储：一部分在x，另一部分在x + 2^( n-1 )存，这样必定减少了冲突的概率</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                    <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                        Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; next;</span><br><span class="line">                        <span class="keyword">do</span> &#123;</span><br><span class="line">                            next = e.next;</span><br><span class="line">                            <span class="comment">////不需要移动的数据</span></span><br><span class="line">                            <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;  </span><br><span class="line">                                <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                    loHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = e;</span><br><span class="line">                                loTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">//需要移动的数据</span></span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                  hiHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = e;</span><br><span class="line">                                hiTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; </span><br><span class="line">                        <span class="comment">//分批插入新的链表中</span></span><br><span class="line">                        <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j] = loHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j + oldCap] = hiHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newTab;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>红黑树插值操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">putTreeVal</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">int</span> h, K k, V v)</span> </span>&#123;</span><br><span class="line">            Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">boolean</span> searched = <span class="keyword">false</span>;</span><br><span class="line">            TreeNode&lt;K,V&gt; root = (parent != <span class="keyword">null</span>) ? root() : <span class="keyword">this</span>;</span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> dir, ph; K pk;</span><br><span class="line">                <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                    dir = -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                    dir = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="keyword">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">                    <span class="keyword">return</span> p;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                          (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                         (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!searched) &#123;</span><br><span class="line">                        TreeNode&lt;K,V&gt; q, ch;</span><br><span class="line">                        searched = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="keyword">if</span> (((ch = p.left) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                             (q = ch.find(h, k, kc)) != <span class="keyword">null</span>) ||</span><br><span class="line">                            ((ch = p.right) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                             (q = ch.find(h, k, kc)) != <span class="keyword">null</span>))</span><br><span class="line">                            <span class="keyword">return</span> q;</span><br><span class="line">                    &#125;</span><br><span class="line">                    dir = tieBreakOrder(k, pk);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">                <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    Node&lt;K,V&gt; xpn = xp.next;</span><br><span class="line">                    TreeNode&lt;K,V&gt; x = map.newTreeNode(h, k, v, xpn);</span><br><span class="line">                    <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                        xp.left = x;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        xp.right = x;</span><br><span class="line">                    xp.next = x;</span><br><span class="line">                    x.parent = x.prev = xp;</span><br><span class="line">                    <span class="keyword">if</span> (xpn != <span class="keyword">null</span>)</span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)xpn).prev = x;</span><br><span class="line">                    moveRootToFront(tab, balanceInsertion(root, x));</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>红黑树获取节点操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">getTreeNode</span><span class="params">(<span class="keyword">int</span> h, Object k)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> ((parent != <span class="keyword">null</span>) ? root() : <span class="keyword">this</span>).find(h, k, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line"> <span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">find</span><span class="params">(<span class="keyword">int</span> h, Object k, Class&lt;?&gt; kc)</span> </span>&#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; p = <span class="keyword">this</span>;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> ph, dir; K pk;</span><br><span class="line">                TreeNode&lt;K,V&gt; pl = p.left, pr = p.right, q;</span><br><span class="line">                <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                    p = pl;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                    p = pr;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="keyword">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">                    <span class="keyword">return</span> p;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (pl == <span class="keyword">null</span>)</span><br><span class="line">                    p = pr;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (pr == <span class="keyword">null</span>)</span><br><span class="line">                    p = pl;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((kc != <span class="keyword">null</span> ||</span><br><span class="line">                          (kc = comparableClassFor(k)) != <span class="keyword">null</span>) &amp;&amp;</span><br><span class="line">                         (dir = compareComparables(kc, k, pk)) != <span class="number">0</span>)</span><br><span class="line">                    p = (dir &lt; <span class="number">0</span>) ? pl : pr;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((q = pr.find(h, k, kc)) != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> q;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    p = pl;</span><br><span class="line">            &#125; <span class="keyword">while</span> (p != <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>remove()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ?</span><br><span class="line">            <span class="keyword">null</span> : e.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, index;</span><br><span class="line">    <span class="comment">//如果哈希表不为空，且哈希表的长度大于0，并且计算出来的位置信息不是空，继续</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node&lt;K,V&gt; node = <span class="keyword">null</span>, e; K k; V v;</span><br><span class="line">            <span class="comment">//如果找到了hash值和key值都相等的节点，记录节点信息</span></span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                node = p;</span><br><span class="line">            <span class="comment">//如果在哈希表的元素上已经形成了链表，那么进行遍历操作</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//如果已经形成了红黑树，进行红黑树查询节点操作</span></span><br><span class="line">                <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">                <span class="comment">//如果没有形成红黑树，那么进行链表查询</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//</span></span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                            ((k = e.key) == key ||</span><br><span class="line">                             (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                            node = e;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        p = e;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                                 (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">                <span class="comment">//查找得到的Node是红黑树节点，那么进行树的删除节点操作</span></span><br><span class="line">                <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</span><br><span class="line">                <span class="comment">//如果节点是哈希表中存放的链表头，那么直接指向下一个节点即可</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                    tab[index] = node.next;</span><br><span class="line">                <span class="comment">//如果是链表里面的节点，那么进行链表删除节点操作</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    p.next = node.next;</span><br><span class="line">                ++modCount;</span><br><span class="line">                --size;</span><br><span class="line">                afterNodeRemoval(node);</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>红黑树删除节点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">removeTreeNode</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> n;</span><br><span class="line">            <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">int</span> index = (n - <span class="number">1</span>) &amp; hash;</span><br><span class="line">            TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index], root = first, rl;</span><br><span class="line">            TreeNode&lt;K,V&gt; succ = (TreeNode&lt;K,V&gt;)next, pred = prev;</span><br><span class="line">            <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">                tab[index] = first = succ;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                pred.next = succ;</span><br><span class="line">            <span class="keyword">if</span> (succ != <span class="keyword">null</span>)</span><br><span class="line">                succ.prev = pred;</span><br><span class="line">            <span class="keyword">if</span> (first == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span> (root.parent != <span class="keyword">null</span>)</span><br><span class="line">                root = root.root();</span><br><span class="line">            <span class="keyword">if</span> (root == <span class="keyword">null</span> || root.right == <span class="keyword">null</span> ||</span><br><span class="line">                (rl = root.left) == <span class="keyword">null</span> || rl.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">                tab[index] = first.untreeify(map);  <span class="comment">// too small</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            TreeNode&lt;K,V&gt; p = <span class="keyword">this</span>, pl = left, pr = right, replacement;</span><br><span class="line">            <span class="keyword">if</span> (pl != <span class="keyword">null</span> &amp;&amp; pr != <span class="keyword">null</span>) &#123;</span><br><span class="line">                TreeNode&lt;K,V&gt; s = pr, sl;</span><br><span class="line">                <span class="keyword">while</span> ((sl = s.left) != <span class="keyword">null</span>) <span class="comment">// find successor</span></span><br><span class="line">                    s = sl;</span><br><span class="line">                <span class="keyword">boolean</span> c = s.red; s.red = p.red; p.red = c; <span class="comment">// swap colors</span></span><br><span class="line">                TreeNode&lt;K,V&gt; sr = s.right;</span><br><span class="line">                TreeNode&lt;K,V&gt; pp = p.parent;</span><br><span class="line">                <span class="keyword">if</span> (s == pr) &#123; <span class="comment">// p was s's direct parent</span></span><br><span class="line">                    p.parent = s;</span><br><span class="line">                    s.right = p;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    TreeNode&lt;K,V&gt; sp = s.parent;</span><br><span class="line">                    <span class="keyword">if</span> ((p.parent = sp) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (s == sp.left)</span><br><span class="line">                            sp.left = p;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            sp.right = p;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> ((s.right = pr) != <span class="keyword">null</span>)</span><br><span class="line">                        pr.parent = s;</span><br><span class="line">                &#125;</span><br><span class="line">                p.left = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> ((p.right = sr) != <span class="keyword">null</span>)</span><br><span class="line">                    sr.parent = p;</span><br><span class="line">                <span class="keyword">if</span> ((s.left = pl) != <span class="keyword">null</span>)</span><br><span class="line">                    pl.parent = s;</span><br><span class="line">                <span class="keyword">if</span> ((s.parent = pp) == <span class="keyword">null</span>)</span><br><span class="line">                    root = s;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.left)</span><br><span class="line">                    pp.left = s;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    pp.right = s;</span><br><span class="line">                <span class="keyword">if</span> (sr != <span class="keyword">null</span>)</span><br><span class="line">                    replacement = sr;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    replacement = p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (pl != <span class="keyword">null</span>)</span><br><span class="line">                replacement = pl;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (pr != <span class="keyword">null</span>)</span><br><span class="line">                replacement = pr;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                replacement = p;</span><br><span class="line">            <span class="keyword">if</span> (replacement != p) &#123;</span><br><span class="line">                TreeNode&lt;K,V&gt; pp = replacement.parent = p.parent;</span><br><span class="line">                <span class="keyword">if</span> (pp == <span class="keyword">null</span>)</span><br><span class="line">                    root = replacement;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.left)</span><br><span class="line">                    pp.left = replacement;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    pp.right = replacement;</span><br><span class="line">                p.left = p.right = p.parent = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            TreeNode&lt;K,V&gt; r = p.red ? root : balanceDeletion(root, replacement);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (replacement == p) &#123;  <span class="comment">// detach</span></span><br><span class="line">                TreeNode&lt;K,V&gt; pp = p.parent;</span><br><span class="line">                p.parent = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (pp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (p == pp.left)</span><br><span class="line">                        pp.left = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.right)</span><br><span class="line">                        pp.right = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (movable)</span><br><span class="line">                moveRootToFront(tab, r);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>hash()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h;</span><br><span class="line">    <span class="comment">//为什么不直接用hashCode的值参加计算，而实使用 (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</span></span><br><span class="line">    <span class="comment">//为了避免hashCode在N很小的情况下，如果hashCode的高16位变化很大，而低16位很少变化；即使变化了，也只有低16位和n-1进行与操作，很容易造成冲突</span></span><br><span class="line">        <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//哈希表的长度必定会被设置成为一个2的整数次幂</span></span><br><span class="line"><span class="comment">//如果为13会是16，27会成为32</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line"> n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line"> n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line"> n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line"> n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line"> n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line"> <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_C</span><br><span class="line">APACITY : n + <span class="number">1</span>; &#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><pre><code class="java"> <span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">putTreeVal</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</span></span>
<span class="function"><span class="params">                                       <span class="keyword">int</span> h, K k, V v)</span> </span>{
            Class&lt;?&gt; kc = <span class="keyword">null</span>;
            <span class="keyword">boolean</span> searched = <span class="keyword">false</span>;
            TreeNode&lt;K,V&gt; root = (parent != <span class="keyword">null</span>) ? root() : <span class="keyword">this</span>;
            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) {
                <span class="keyword">int</span> dir, ph; K pk;
                <span class="keyword">if</span> ((ph = p.hash) &gt; h)
                    dir = -<span class="number">1</span>;
                <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)
                    dir = <span class="number">1</span>;
                <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="keyword">null</span> &amp;&amp; k.equals(pk)))
                    <span class="keyword">return</span> p;
                <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;
                          (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||
                         (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>) {
                    <span class="keyword">if</span> (!searched) {
                        TreeNode&lt;K,V&gt; q, ch;
                        searched = <span class="keyword">true</span>;
                        <span class="keyword">if</span> (((ch = p.left) != <span class="keyword">null</span> &amp;&amp;
                             (q = ch.find(h, k, kc)) != <span class="keyword">null</span>) ||
                            ((ch = p.right) != <span class="keyword">null</span> &amp;&amp;
                             (q = ch.find(h, k, kc)) != <span class="keyword">null</span>))
                            <span class="keyword">return</span> q;
                    }
                    dir = tieBreakOrder(k, pk);
                }

                TreeNode&lt;K,V&gt; xp = p;
                <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) {
                    Node&lt;K,V&gt; xpn = xp.next;
                    TreeNode&lt;K,V&gt; x = map.newTreeNode(h, k, v, xpn);
                    <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)
                        xp.left = x;
                    <span class="keyword">else</span>
                        xp.right = x;
                    xp.next = x;
                    x.parent = x.prev = xp;
                    <span class="keyword">if</span> (xpn != <span class="keyword">null</span>)
                        ((TreeNode&lt;K,V&gt;)xpn).prev = x;
                    moveRootToFront(tab, balanceInsertion(root, x));
                    <span class="keyword">return</span> <span class="keyword">null</span>;
                }
            }
        }
&lt;!--￼<span class="number">33</span>--&gt;</code></pre>
</li>
<li><p>有三个HashMap引用的方法</p>
<ul>
<li><pre><code class="java"><span class="comment">//将节点放到链表尾部</span>
<span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>{ <span class="comment">// move node to last</span>
        LinkedHashMap.Entry&lt;K,V&gt; last;
        <span class="keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) {
            LinkedHashMap.Entry&lt;K,V&gt; p =
                (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;
            p.after = <span class="keyword">null</span>;
            <span class="keyword">if</span> (b == <span class="keyword">null</span>)
                head = a;
            <span class="keyword">else</span>
                b.after = a;
            <span class="keyword">if</span> (a != <span class="keyword">null</span>)
                a.before = b;
            <span class="keyword">else</span>
                last = b;
            <span class="keyword">if</span> (last == <span class="keyword">null</span>)
                head = p;
            <span class="keyword">else</span> {
                p.before = last;
                last.after = p;
            }
            tail = p;
            ++modCount;
        }
    }
&lt;!--￼<span class="number">34</span>--&gt;</code></pre>
</li>
<li><pre><code class="java"><span class="comment">//删除头节点，在哈希表插入节点时使用</span>
<span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>{ <span class="comment">// possibly remove eldest</span>
        LinkedHashMap.Entry&lt;K,V&gt; first;
        <span class="keyword">if</span> (evict &amp;&amp; (first = head) != <span class="keyword">null</span> &amp;&amp; removeEldestEntry(first)) {
            K key = first.key;
            removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);
        }
    }
&lt;!--￼<span class="number">35</span>--&gt;</code></pre>
</li>
</ul>
</li>
<li><p>values(),遍历顺序和key一样</p>
<ul>
<li><pre><code class="java">Collection values = map.values()
&lt;!--￼<span class="number">36</span>--&gt;
</code></pre>
</li>
</ul>
</li>
</ul>
<h4 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h4><ul>
<li><p>TreeMap是按照key进行排序的，key必须是由同一个类创建的对象</p>
<ul>
<li><p>自然排序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//key所在的对象实现Compaaeble，实现ToComparable方法</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>定制排序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TreeMap map = new TreeMap(new Comparator()&#123;</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(object o1,object o2)</span></span>&#123;</span><br><span class="line">....</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h4 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h4><h5 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h5><ul>
<li><p>处理配置文件，key和value都是String类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Properties pros = <span class="keyword">new</span> Properties;</span><br><span class="line">String name = pros.getProperty(<span class="string">"name"</span>);</span><br></pre></td></tr></table></figure>





</li>
</ul>
<h4 id="Collections工具类"><a href="#Collections工具类" class="headerlink" title="Collections工具类"></a>Collections工具类</h4><h5 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h5><ul>
<li><p>可以操作Collection和Map的工具类</p>
</li>
<li><p>Collections和Collection的区别</p>
</li>
</ul>
<h5 id="常用方法（都是static方法）"><a href="#常用方法（都是static方法）" class="headerlink" title="常用方法（都是static方法）"></a>常用方法（都是static方法）</h5><h6 id="reverse-list"><a href="#reverse-list" class="headerlink" title="reverse(list)"></a>reverse(list)</h6><ul>
<li><p>反转List中元素的顺序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collections.reverse(list)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h6 id="shuffle-list"><a href="#shuffle-list" class="headerlink" title="shuffle(list)"></a>shuffle(list)</h6><ul>
<li><p>list随机排列，每次都不一样</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collections.shuffle(list)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h6 id="sort-list"><a href="#sort-list" class="headerlink" title="sort(list)"></a>sort(list)</h6><ul>
<li>自然排序</li>
</ul>
<h6 id="sort-list-Comparator"><a href="#sort-list-Comparator" class="headerlink" title="sort(list,Comparator)"></a>sort(list,Comparator)</h6><ul>
<li>定制排序</li>
</ul>
<h6 id="swap-list-i-j"><a href="#swap-list-i-j" class="headerlink" title="swap(list,i,j)"></a>swap(list,i,j)</h6><ul>
<li>交换list中i和j位置的数据</li>
</ul>
<h6 id="max-Collection"><a href="#max-Collection" class="headerlink" title="max(Collection)"></a>max(Collection)</h6><ul>
<li>自然排序最大/小值</li>
</ul>
<h6 id="max-Collection-Comparator"><a href="#max-Collection-Comparator" class="headerlink" title="max(Collection,Comparator)"></a>max(Collection,Comparator)</h6><ul>
<li>定制排序最大/小值</li>
</ul>
<h6 id="frequency-Collection-Object"><a href="#frequency-Collection-Object" class="headerlink" title="frequency(Collection,Object)"></a>frequency(Collection,Object)</h6><ul>
<li>返回集合指定元素的个数</li>
</ul>
<h6 id="copy-list1-list2"><a href="#copy-list1-list2" class="headerlink" title="*copy(list1,list2)"></a>*copy(list1,list2)</h6><ul>
<li><p>错误做法1</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ArrayList list2 = <span class="keyword">new</span> ArrayList();</span><br><span class="line">Collections.copy(list2,list1);</span><br><span class="line"><span class="comment">//抛出异常，list2的长度是0，不合适</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>错误做法2</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ArrayList list2 = <span class="keyword">new</span> ArrayList(list1.size());</span><br><span class="line">Collections.copy(list2,list1);</span><br><span class="line"><span class="comment">//只是造了一个list1.size()的数组（没有存元素），list1.size()表示的是存由元素的数组元素的个数。</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>正确做法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List dest = Arrays.asList(<span class="keyword">new</span> Object[list.size()])</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>list2中的元素复制到list1中</p>
<ul>
<li>多了之后只覆盖前面的list2的个数</li>
</ul>
</li>
</ul>
<h6 id="replaceAll-list-oldVal-newVal"><a href="#replaceAll-list-oldVal-newVal" class="headerlink" title="replaceAll(list,oldVal,newVal)"></a>replaceAll(list,oldVal,newVal)</h6><ul>
<li>newVal替换list中所有的oldVal值</li>
</ul>
<h6 id="线程安全集合"><a href="#线程安全集合" class="headerlink" title="线程安全集合"></a>线程安全集合</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List list1 = Collections.synchronizedList(list);</span><br><span class="line"><span class="comment">//list1就会变成线程安全的</span></span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/111zx/111zx.github.io/2020/03/31/%E9%9B%86%E5%90%88/" data-id="ckbbzdvt0000jt8ub5j9406kz" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-java面试点" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/27/java%E9%9D%A2%E8%AF%95%E7%82%B9/" class="article-date">
  <time datetime="2020-03-27T09:31:58.000Z" itemprop="datePublished">2020-03-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/27/java%E9%9D%A2%E8%AF%95%E7%82%B9/">java面试点</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><ol>
<li>说说JVM内存模型。</li>
<li>线程的程序计数器是干什么用的？</li>
<li>说说堆里面的垃圾回收算法？为什么新生代用复制算法，老年代用标记整理、标记压缩？</li>
<li>了解CMS这个垃圾回收器吗？说说它的工作流程？</li>
<li>CMS在并发标记的时候，用户线程也会不停的产生一些大对象，Remark再次标记的时候可能会花上很多时间，说说你的优化方案？</li>
</ol>
<p>.java - javac -&gt;class - JVM - &gt;各种操作系统的机器码</p>
<p>.class 会通过类装载子系统加载到 运行时数据区 最后由字节码执行引擎来执行</p>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><ol>
<li>tcp time_wait和close_wait区别以及产生原因，过多的话处理方法？ </li>
</ol>
<h2 id="springboot"><a href="#springboot" class="headerlink" title="springboot"></a>springboot</h2><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><ol>
<li><p>数据库的锁</p>
</li>
<li><p>索引方面<br>索引是帮助MySQL高校获取数据的排好序的数据结构<br>索引数据结构<br> 二叉排序树</p>
<pre><code>缺点：若是非递增序列，则变成线性的链表，查询效率低下</code></pre><p> 红黑树</p>
<pre><code>二叉平衡：差距大于2时平衡
    缺点：数据量很大时，树高度也很大，效率很低</code></pre><p> Hash表<br> B-Tree叶节点具有相同的深度，叶结点指针为空</p>
<pre><code>所有索引元素不重复
节点中的数据索引从左到右递增排列</code></pre><p> B+Tree（叶子节点间双向指针）（MySQL索引）</p>
<pre><code>每次从磁盘拿来一个索引 在内存中查找（速度比磁盘io快很多）
MySQL 一个节点16KB
非叶子节点不存储data，只存储索引，叶子节点用指针连接，提高区间访问的性能
非叶子节点不存储data的原因;让一个节点的索引更多，提高查询效率。</code></pre><p> 存储引擎是形容数据表的<br> InnoiDB</p>
<pre><code>索引和数据存储在一起
聚集索引
    数据和索引放在一起
非聚集索引
    数据和索引分开
为什么InnoDB表必须要主键，并且推荐用整型的自增主键？
    没有主键就没有什么作为索引形成索引的B+树结构，如果没有设置索引，MYsql会自动设置一个主键。整型的存储空间更小，更好比较。自增是因为

为什么hash快但是不用hash用B+树
    ：hash只能单点查找，而B+树可以范围查找。</code></pre><p> 联合索引的底层存储结构长什么样子</p>
</li>
</ol>
<pre><code>MyISAM
    索引文件和数据文件是分离的</code></pre><ol start="3">
<li>为啥索引用b+树，比较其他数据结构，他的优点是啥</li>
<li>查询语句走不走索引</li>
<li>sql语句执行慢的可能原因</li>
</ol>
<h2 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h2><ol start="6">
<li>redis基本数据结构 </li>
</ol>
<h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><ol>
<li>三次握手，四次挥手</li>
<li>https概念</li>
</ol>
<p>##java SE<br>3. 数组和arraylist的区别<br>4. Hashmap<br>5. Hashset<br>6. 并发模块：两个关键字<br>7. 接口和抽象类</p>
<h2 id="自增变量"><a href="#自增变量" class="headerlink" title="自增变量"></a>自增变量</h2><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><ol start="11">
<li>进程和线程，为什么需要线程程</li>
<li>保证线程安全的方法。Lock加锁复习，synchronized优化复习</li>
<li>Linux内核，操作系统？C++</li>
<li>Linux查找那个线程使用CPU最大</li>
<li>消息队列原理</li>
</ol>
<h2 id="spring-mvc"><a href="#spring-mvc" class="headerlink" title="spring mvc"></a>spring mvc</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/111zx/111zx.github.io/2020/03/27/java%E9%9D%A2%E8%AF%95%E7%82%B9/" data-id="ckbbzdvst000dt8ube5xyd1ky" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-软件过程管理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/26/%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B%E7%AE%A1%E7%90%86/" class="article-date">
  <time datetime="2020-03-26T04:31:17.000Z" itemprop="datePublished">2020-03-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/26/%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B%E7%AE%A1%E7%90%86/">软件过程管理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<p>title: 软件过程管理<br>date: 2020-03-19 11:10:24<br>tags:</p>
<hr>
<h2 id="项目集成管理"><a href="#项目集成管理" class="headerlink" title="项目集成管理"></a>项目集成管理</h2><h3 id="需求获取"><a href="#需求获取" class="headerlink" title="需求获取"></a>需求获取</h3><h3 id="过程（已经有了用户需求）"><a href="#过程（已经有了用户需求）" class="headerlink" title="过程（已经有了用户需求）"></a>过程（已经有了用户需求）</h3><ol>
<li>制定项目章程<br> sponsor（sign）</li>
<li>指定项目管理计划<br> PM（plan）</li>
<li>指导和管理项目的工作</li>
<li>管理项目的知识</li>
<li>监管和控制项目工作</li>
<li>执行整体的变更控制</li>
<li>关闭项目</li>
</ol>
<p>战略规划：<br>    通过分析组织的优势和劣势，研究商业环境的机会和威胁，预测未来趋势，预测对新产品和服务的需求来确定长远的目标<br>SWOT：<br>    优势，劣势，机会和威胁。</p>
<p>选择项目的方法<br>    缩小项目的范围，没有足够的时间和资源完成所有<br>    1.关注广泛的组织需求<br>        很多人认同这个项目又很高的价值（即使没有理由）<br>    2. 为IT项目分类<br>        …<br>    3. 财务分析<br>        NPV<br>            Net Present Value<br>            time value of time<br>        …<br>    4. 投资回收率 return on investment ROI<br>        (收益-成本)/成本<br>    5. 投资回收期 payback analysis<br>        收回项目投资总资金所需要的时间</p>
<p>加权平均项目评价<br>    标准划分权重；<br>    每个项目对于各个标准进行评分；<br>    加权平均计算</p>
<p>平衡记分卡 implementing a balanced scorecard<br>    increase stock value<br>    Lv1 -&gt;Lv2 -&gt;Lv3 -&gt;Lv4<br>    financial -&gt;customer -&gt;internal -?learning&amp;growth<br>指定项目章程</p>
<p>制定项目管理计划<br>    项目简介<br>    组织方式说明<br>    要做的工作<br>    进度以及预算<br>    参考其他项目计划文件<br>    项目上使用的方法和技术</p>
<p>Project Document</p>
<p>指导和管理项目工作</p>
<p>规划和执行</p>
<p>组织文化和强大的领导能力</p>
<p>利用产品，业务和应用领域的知识<br>    大型项目项目经理必须了解业务相关领域的知识</p>
<p>项目执行工具和技术<br>    专家判断<br>    会议<br>    项目信息管理系统</p>
<p>监管和控制项目工作<br>     baseline ：记录在案的起点，测量或观察，一边用于将来的比较<br>    变更请求<br>    工作绩效报告<br>    change request date：只要发生了变化，需要一个文件来记录改变了什么</p>
<p>结束项目或者阶段<br>    项目产出：<br>        …</p>
<h2 id="项目范围管理"><a href="#项目范围管理" class="headerlink" title="项目范围管理"></a>项目范围管理</h2><p>重点：工作分解结构</p>
<h3 id="什么是项目范围管理"><a href="#什么是项目范围管理" class="headerlink" title="什么是项目范围管理"></a>什么是项目范围管理</h3><pre><code>与项目成功相关的许多因素：
    用户参与
    明确业务目标
    优化的范围
范围：创建项目的产品和用于创建产品的过程之所涉及的所有工作。
deliverable 可交付成果

项目范围管理是确定和控制项目中应包含哪些过程。

六大过程：

    计划项目管理：
        决定项目的范围和需求
    采集需求
    定义范围
    创建WBS：将可交付成果细分为更小，更易管理的组件
    确认范围：正式接受项目可交付成果
    控制范围：在项目整个生命周期中控制对项目的变更


项目团队用专家判断，数据分析和会议来开发宪哥重要的输出：
    范围管理计划
        编制详细的项目说明书
        创建WBS
        维护和批准WBS
        获得已完成项目可交付成果的验收
        控制对项目范围的更改请求
    需求管理计划
        概念： 产品，服务或结果中满足业务所必须的条件或能力
        需求工程是软件工程的一个分支，包含和需求获取，需求分析，需求规格说明，需求验证和需求管理

        收集初级资料有四种方法：
            一对一采访
            focus group
                决定焦点小组的话题和目标
                确定参与者
                准备指南和问题清单
                选择地点
                。。。。。。
            运用团队创造力和决策技巧
                头脑风暴
                德尔菲技术
                。。。
            问卷和调查

            观察，涉及到改进过程的更适合。

            原型和文档分析，有助于澄清项目的边界

            基准话分析法，标杆分析法（和业内最大竞争对手比较）

            需求跟踪矩阵：列出了需求、每个需求的各种属性，以及需求的状态，
            以确保所有的需求都得到了满足
    确认范围
        包括：
            产品范围描述
            产品用户验证标准
            所有可交付成果的详细信息

    WBS 工作分解结构：项目中设计的面向交付的工作分组，定义了项目的整个氛围，是一个基础文档，它为计划和管理项目进度表，成本，资源和变更提供了基础

        分解是创建工作分解的主要技术
            工作包是分解结构的最低技术
                例如：PROJECT-TasK-SubTask-Work Package（工作包，最低的层次）
    NOT EVERY WBS is good

    WBS例子：某公寓建设项目工作分解图</code></pre><img src="/2020/03/26/%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B%E7%AE%A1%E7%90%86/WPS.png" class title="[WBS]">

<img src="/2020/03/26/%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B%E7%AE%A1%E7%90%86/WPS%E6%A1%86%E6%9E%B6.png" class title="[WBS框架]">




<pre><code>    两种WBS 

    开发WBS的方法
        使用指南
        回顾法
        。。。

    WBS scrum 图



    WBS Dictionary
        WBS项目只由一人负责    
        工作单元只能出现再WBS的一个地方


validating验证范围
        验证分为并且最小化分为更改
        包括：对完成项目的可交付成果的正式接受
            通常是由用户检查签字实现的

控制范围
    包括：
        项目范围的变更
    范围控制目标：
        1影响项目变更的因素
        2确保变更按照作为综合变更控制的一部分的程序进行处理
        3当变更发生时管理他们
    差异是指计划和实际表现之间的差异
    减少不完整和变更需求的建议</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/111zx/111zx.github.io/2020/03/26/%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B%E7%AE%A1%E7%90%86/" data-id="ck88at6vi000b14ubbm8z51tk" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-javaWeb项目出现问题整合" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/25/javaWeb%E9%A1%B9%E7%9B%AE%E5%87%BA%E7%8E%B0%E9%97%AE%E9%A2%98%E6%95%B4%E5%90%88/" class="article-date">
  <time datetime="2020-03-25T00:22:36.000Z" itemprop="datePublished">2020-03-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/25/javaWeb%E9%A1%B9%E7%9B%AE%E5%87%BA%E7%8E%B0%E9%97%AE%E9%A2%98%E6%95%B4%E5%90%88/">javaWeb项目出现问题整合</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="中文搜索出现乱码问题"><a href="#中文搜索出现乱码问题" class="headerlink" title="中文搜索出现乱码问题"></a>中文搜索出现乱码问题</h2><p>问题描述：在用户查询操作时，如果时输入英文关键字，查询成功；但是如果输入中文，会在文本框返回一个乱码，并且查询失败。</p>
<p>点击搜索之后显示如下：</p>
<img src="/2020/03/25/javaWeb%E9%A1%B9%E7%9B%AE%E5%87%BA%E7%8E%B0%E9%97%AE%E9%A2%98%E6%95%B4%E5%90%88/%E6%90%9C%E7%B4%A2%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81.png" class title="[中文搜索乱码]">

<p>问题分析：<br> UTF-8为国际编码，GBK为中文编码，Web tomcat7之前的默认编码方式为ISO-8859-1,而tomcat8之后的默认编码为utf-8（本次使用的运行环境时tomcat7，出现了问题）.</p>
<p>问题解决方案：</p>
<p>修改tomacat的编码方式，添加一条UTF-8的编码方式具体操作如下：<br>tomact根目录—&gt;conf—&gt;server.xml 找到：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Connector protocol=<span class="string">"HTTP/1.1"</span></span><br><span class="line">               connectionTimeout=<span class="string">"20000"</span></span><br><span class="line">               redirectPort=<span class="string">"8443"</span> /&gt;</span><br></pre></td></tr></table></figure>
<p>修改为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Connector URIEncoding=<span class="string">"UTF-8"</span> port=<span class="string">"8080"</span> protocol=<span class="string">"HTTP/1.1"</span></span><br><span class="line">               connectionTimeout=<span class="string">"20000"</span></span><br><span class="line">               redirectPort=<span class="string">"8443"</span> /&gt;</span><br></pre></td></tr></table></figure>

<p>修改后可正常进行中文关键字搜索</p>
<p>注意：修改之后需要重新配置一遍tomact，会影响到整个项目的其他部分，一定要做好备份</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/111zx/111zx.github.io/2020/03/25/javaWeb%E9%A1%B9%E7%9B%AE%E5%87%BA%E7%8E%B0%E9%97%AE%E9%A2%98%E6%95%B4%E5%90%88/" data-id="ck88at6vc000614ub2ulw9k0g" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Web案例学习" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/24/Web%E6%A1%88%E4%BE%8B%E5%AD%A6%E4%B9%A0/" class="article-date">
  <time datetime="2020-03-24T05:57:07.000Z" itemprop="datePublished">2020-03-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/24/Web%E6%A1%88%E4%BE%8B%E5%AD%A6%E4%B9%A0/">Web案例学习</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>创建一个数据库 LmonkeyShop</p>
<h2 id="第一步-从用户模块开始"><a href="#第一步-从用户模块开始" class="headerlink" title="第一步 从用户模块开始"></a>第一步 从用户模块开始</h2><pre><code>1. 用户表设计
    用户表lmonkey_user
        ...
    做一个用户的实体（IMONKEY_USER）



1. 用户的增删改查</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/111zx/111zx.github.io/2020/03/24/Web%E6%A1%88%E4%BE%8B%E5%AD%A6%E4%B9%A0/" data-id="ck88at6v9000314ubgl0r7diy" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/07/06/%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%E7%B3%BB%E7%BB%9F/">文件传输系统</a>
          </li>
        
          <li>
            <a href="/2020/07/05/1.%20%E7%82%B9%E5%87%BB%E6%96%87%E4%BB%B6%E6%A0%91%E6%98%BE%E7%A4%BA%E6%96%87%E4%BB%B6%E5%88%97%E8%A1%A8/">1. 点击文件树显示文件列表</a>
          </li>
        
          <li>
            <a href="/2020/06/22/IO%E6%B5%81/">IO流</a>
          </li>
        
          <li>
            <a href="/2020/06/10/%E6%B3%9B%E5%9E%8B/">泛型</a>
          </li>
        
          <li>
            <a href="/2020/06/09/%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E8%AF%BE%E7%A8%8B%E6%8A%A5%E5%91%8A/">软件体系结构课程报告</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 zx<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>