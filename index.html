<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="https://github.com/111zx/111zx.github.io/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="zx">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://github.com/111zx/111zx.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-软件体系结构" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/26/%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/" class="article-date">
  <time datetime="2020-03-26T05:01:02.000Z" itemprop="datePublished">2020-03-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/26/%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/">软件体系结构</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/111zx/111zx.github.io/2020/03/26/%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/" data-id="ck88at6vi000a14ub5510hll0" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-软件过程管理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/26/%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B%E7%AE%A1%E7%90%86/" class="article-date">
  <time datetime="2020-03-26T04:31:17.000Z" itemprop="datePublished">2020-03-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/26/%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B%E7%AE%A1%E7%90%86/">软件过程管理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<p>title: 软件过程管理<br>date: 2020-03-19 11:10:24<br>tags:</p>
<hr>
<h2 id="项目集成管理"><a href="#项目集成管理" class="headerlink" title="项目集成管理"></a>项目集成管理</h2><h3 id="需求获取"><a href="#需求获取" class="headerlink" title="需求获取"></a>需求获取</h3><h3 id="过程（已经有了用户需求）"><a href="#过程（已经有了用户需求）" class="headerlink" title="过程（已经有了用户需求）"></a>过程（已经有了用户需求）</h3><ol>
<li>制定项目章程<br> sponsor（sign）</li>
<li>指定项目管理计划<br> PM（plan）</li>
<li>指导和管理项目的工作</li>
<li>管理项目的知识</li>
<li>监管和控制项目工作</li>
<li>执行整体的变更控制</li>
<li>关闭项目</li>
</ol>
<p>战略规划：<br>    通过分析组织的优势和劣势，研究商业环境的机会和威胁，预测未来趋势，预测对新产品和服务的需求来确定长远的目标<br>SWOT：<br>    优势，劣势，机会和威胁。</p>
<p>选择项目的方法<br>    缩小项目的范围，没有足够的时间和资源完成所有<br>    1.关注广泛的组织需求<br>        很多人认同这个项目又很高的价值（即使没有理由）<br>    2. 为IT项目分类<br>        …<br>    3. 财务分析<br>        NPV<br>            Net Present Value<br>            time value of time<br>        …<br>    4. 投资回收率 return on investment ROI<br>        (收益-成本)/成本<br>    5. 投资回收期 payback analysis<br>        收回项目投资总资金所需要的时间</p>
<p>加权平均项目评价<br>    标准划分权重；<br>    每个项目对于各个标准进行评分；<br>    加权平均计算</p>
<p>平衡记分卡 implementing a balanced scorecard<br>    increase stock value<br>    Lv1 -&gt;Lv2 -&gt;Lv3 -&gt;Lv4<br>    financial -&gt;customer -&gt;internal -?learning&amp;growth<br>指定项目章程</p>
<p>制定项目管理计划<br>    项目简介<br>    组织方式说明<br>    要做的工作<br>    进度以及预算<br>    参考其他项目计划文件<br>    项目上使用的方法和技术</p>
<p>Project Document</p>
<p>指导和管理项目工作</p>
<p>规划和执行</p>
<p>组织文化和强大的领导能力</p>
<p>利用产品，业务和应用领域的知识<br>    大型项目项目经理必须了解业务相关领域的知识</p>
<p>项目执行工具和技术<br>    专家判断<br>    会议<br>    项目信息管理系统</p>
<p>监管和控制项目工作<br>     baseline ：记录在案的起点，测量或观察，一边用于将来的比较<br>    变更请求<br>    工作绩效报告<br>    change request date：只要发生了变化，需要一个文件来记录改变了什么</p>
<p>结束项目或者阶段<br>    项目产出：<br>        …</p>
<h2 id="项目范围管理"><a href="#项目范围管理" class="headerlink" title="项目范围管理"></a>项目范围管理</h2><p>重点：工作分解结构</p>
<h3 id="什么是项目范围管理"><a href="#什么是项目范围管理" class="headerlink" title="什么是项目范围管理"></a>什么是项目范围管理</h3><pre><code>与项目成功相关的许多因素：
    用户参与
    明确业务目标
    优化的范围
范围：创建项目的产品和用于创建产品的过程之所涉及的所有工作。
deliverable 可交付成果

项目范围管理是确定和控制项目中应包含哪些过程。

六大过程：

    计划项目管理：
        决定项目的范围和需求
    采集需求
    定义范围
    创建WBS：将可交付成果细分为更小，更易管理的组件
    确认范围：正式接受项目可交付成果
    控制范围：在项目整个生命周期中控制对项目的变更


项目团队用专家判断，数据分析和会议来开发宪哥重要的输出：
    范围管理计划
        编制详细的项目说明书
        创建WBS
        维护和批准WBS
        获得已完成项目可交付成果的验收
        控制对项目范围的更改请求
    需求管理计划
        概念： 产品，服务或结果中满足业务所必须的条件或能力
        需求工程是软件工程的一个分支，包含和需求获取，需求分析，需求规格说明，需求验证和需求管理

        收集初级资料有四种方法：
            一对一采访
            focus group
                决定焦点小组的话题和目标
                确定参与者
                准备指南和问题清单
                选择地点
                。。。。。。
            运用团队创造力和决策技巧
                头脑风暴
                德尔菲技术
                。。。
            问卷和调查

            观察，涉及到改进过程的更适合。

            原型和文档分析，有助于澄清项目的边界

            基准话分析法，标杆分析法（和业内最大竞争对手比较）

            需求跟踪矩阵：列出了需求、每个需求的各种属性，以及需求的状态，
            以确保所有的需求都得到了满足
    确认范围
        包括：
            产品范围描述
            产品用户验证标准
            所有可交付成果的详细信息

    WBS 工作分解结构：项目中设计的面向交付的工作分组，定义了项目的整个氛围，是一个基础文档，它为计划和管理项目进度表，成本，资源和变更提供了基础

        分解是创建工作分解的主要技术
            工作包是分解结构的最低技术
                例如：PROJECT-TasK-SubTask-Work Package（工作包，最低的层次）
    NOT EVERY WBS is good

    WBS例子：某公寓建设项目工作分解图</code></pre><img src="/2020/03/26/%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B%E7%AE%A1%E7%90%86/WPS.png" class title="[中文搜索乱码]">

<img src="/2020/03/26/%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B%E7%AE%A1%E7%90%86/WPS%E6%A1%86%E6%9E%B6.png" class title="[中文搜索乱码]">


<pre><code>    两种WBS 

    开发WBS的方法
        使用指南
        回顾法
        。。。

    WBS scrum 图



    WBS Dictionary
        WBS项目只由一人负责    
        工作单元只能出现再WBS的一个地方


validating验证范围
        验证分为并且最小化分为更改
        包括：对完成项目的可交付成果的正式接受
            通常是由用户检查签字实现的

控制范围
    包括：
        项目范围的变更
    范围控制目标：
        1影响项目变更的因素
        2确保变更按照作为综合变更控制的一部分的程序进行处理
        3当变更发生时管理他们
    差异是指计划和实际表现之间的差异
    减少不完整和变更需求的建议</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/111zx/111zx.github.io/2020/03/26/%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B%E7%AE%A1%E7%90%86/" data-id="ck88at6vi000b14ubbm8z51tk" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-javaWeb项目出现问题整合" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/25/javaWeb%E9%A1%B9%E7%9B%AE%E5%87%BA%E7%8E%B0%E9%97%AE%E9%A2%98%E6%95%B4%E5%90%88/" class="article-date">
  <time datetime="2020-03-25T00:22:36.000Z" itemprop="datePublished">2020-03-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/25/javaWeb%E9%A1%B9%E7%9B%AE%E5%87%BA%E7%8E%B0%E9%97%AE%E9%A2%98%E6%95%B4%E5%90%88/">javaWeb项目出现问题整合</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="中文搜索出现乱码问题"><a href="#中文搜索出现乱码问题" class="headerlink" title="中文搜索出现乱码问题"></a>中文搜索出现乱码问题</h2><p>问题描述：在用户查询操作时，如果时输入英文关键字，查询成功；但是如果输入中文，会在文本框返回一个乱码，并且查询失败。</p>
<p>点击搜索之后显示如下：</p>
<img src="/2020/03/25/javaWeb%E9%A1%B9%E7%9B%AE%E5%87%BA%E7%8E%B0%E9%97%AE%E9%A2%98%E6%95%B4%E5%90%88/%E6%90%9C%E7%B4%A2%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81.png" class title="[中文搜索乱码]">

<p>问题分析：<br> UTF-8为国际编码，GBK为中文编码，Web tomcat7之前的默认编码方式为ISO-8859-1,而tomcat8之后的默认编码为utf-8（本次使用的运行环境时tomcat7，出现了问题）.</p>
<p>问题解决方案：</p>
<p>修改tomacat的编码方式，添加一条UTF-8的编码方式具体操作如下：<br>tomact根目录—&gt;conf—&gt;server.xml 找到：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Connector protocol=<span class="string">"HTTP/1.1"</span></span><br><span class="line">               connectionTimeout=<span class="string">"20000"</span></span><br><span class="line">               redirectPort=<span class="string">"8443"</span> /&gt;</span><br></pre></td></tr></table></figure>
<p>修改为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Connector URIEncoding=<span class="string">"UTF-8"</span> port=<span class="string">"8080"</span> protocol=<span class="string">"HTTP/1.1"</span></span><br><span class="line">               connectionTimeout=<span class="string">"20000"</span></span><br><span class="line">               redirectPort=<span class="string">"8443"</span> /&gt;</span><br></pre></td></tr></table></figure>

<p>修改后可正常进行中文关键字搜索</p>
<p>注意：修改之后需要重新配置一遍tomact，会影响到整个项目的其他部分，一定要做好备份</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/111zx/111zx.github.io/2020/03/25/javaWeb%E9%A1%B9%E7%9B%AE%E5%87%BA%E7%8E%B0%E9%97%AE%E9%A2%98%E6%95%B4%E5%90%88/" data-id="ck88at6vc000614ub2ulw9k0g" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Web案例学习" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/24/Web%E6%A1%88%E4%BE%8B%E5%AD%A6%E4%B9%A0/" class="article-date">
  <time datetime="2020-03-24T05:57:07.000Z" itemprop="datePublished">2020-03-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/24/Web%E6%A1%88%E4%BE%8B%E5%AD%A6%E4%B9%A0/">Web案例学习</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>创建一个数据库 LmonkeyShop</p>
<h2 id="第一步-从用户模块开始"><a href="#第一步-从用户模块开始" class="headerlink" title="第一步 从用户模块开始"></a>第一步 从用户模块开始</h2><pre><code>1. 用户表设计
    用户表lmonkey_user
        ...
    做一个用户的实体（IMONKEY_USER）



1. 用户的增删改查</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/111zx/111zx.github.io/2020/03/24/Web%E6%A1%88%E4%BE%8B%E5%AD%A6%E4%B9%A0/" data-id="ck88at6v9000314ubgl0r7diy" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-系统分析与设计" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/24/%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/" class="article-date">
  <time datetime="2020-03-24T03:02:32.000Z" itemprop="datePublished">2020-03-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/24/%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/">系统分析与设计</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="第五章-系统分析阶段"><a href="#第五章-系统分析阶段" class="headerlink" title="第五章 系统分析阶段"></a>第五章 系统分析阶段</h2><p>业务领域由功能划分成不同的的业务模块，再划分成软件模块，最后继承成软件系统</p>
<p>每一阶段的主要工作，业务成果，参与者</p>
<p>一阶段：初始的调查研究<br>    目标：找问题<br>    输出：列出问题<br>    参与：业主</p>
<p>二阶段：问题分析（由症状分析病因）<br>    目标：现有系统的分析（有可能是业务系统，也有可能是技术系统）<br>    输出：确定需要达到什么样的目标<br>    需要业主和用户的参与</p>
<p>三阶段：需求分析<br>    逻辑系统模型-业务<br>        what<br>    物理系统模型-技术<br>        how<br>    目标：确定系统需求<br>    输出：业务需求陈述<br>        功能性需求和非功能性需求<br>    参与：用户，系统分析员</p>
<p>四阶段：决策分析<br>    目标：怎么去选择一个最好的方案（可行性分析）<br>        技术可行性（效率与是非会用），操作可行性（是否可以满足所有需求），经济可行性（成本效益），进度可行性（是否在规定事件可做完）<br>        权重计算表<br>    输出：方案建议书<br>    参与：分析与系统设计师<br>目标：做一个信息系统</p>
<p>系统分析方法：<br>    1. 模型驱动的分析方法<br>    2. 加速分析方法 </p>
<p>模型驱动：强调给系统建模<br>    结构化分析：注重业务处理过程，重点强调交互过程<br>        采用DFD（数据流图）描述结构化分析的业务逻辑<br>    信息工程：以数据为核心<br>        采用ERDs(实体联系图)<br>    面向对象分析：以对象为中心<br>        采用UML图（和类图的区别）<br>快速分析：<br>    发现原型方法：<br>        给出一个提供用户修改的原型框架（更多的是一种向用户展示的作用）</p>
<p>敏捷开发方法：<br>    在实际开发方法没有固定的体系，在不同的阶段根据需要用不同的方法</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/111zx/111zx.github.io/2020/03/24/%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/" data-id="ck88at6vg000914ub3xnealwp" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-构件与中间件技术" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/22/%E6%9E%84%E4%BB%B6%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%8A%80%E6%9C%AF/" class="article-date">
  <time datetime="2020-03-22T11:25:53.000Z" itemprop="datePublished">2020-03-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/22/%E6%9E%84%E4%BB%B6%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%8A%80%E6%9C%AF/">构件与中间件技术</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="第二章-CORBA基本原理"><a href="#第二章-CORBA基本原理" class="headerlink" title="第二章 CORBA基本原理"></a>第二章 CORBA基本原理</h2><pre><code>对象管理体系结构
CORBA体系结构
对象的客户操作性
CORBA规范和产品

对象管理组织OMG
    OMG主要规范
        UML(Unified Model Language)：是面向对象分析与设计阶段的表示技术规范
        CORBA：（Common Object Request Broker Architecture）

对象管理体系结构OMA：
Object Management Architecture是CORBA所给予的概念框架，他描述了一个较高层次的分布式计算环境
    核心内容是对象模型和参考模型
        对象模型：定义了外部可见特征的，独立于具体实现的语义
        参考模型：标识和刻画了组成OMA的组件，接口和协议

组成：

    对象请求代理(ORB): 连接对象服务（功能），靠接口来实现功能（应用程序接口，领域接口，公共设施）。
        是OMA参考模型的核心
        提供了分布式对象之间透明的发送和接受响应的基本机制


    对象服务（需要完成的功能）：
        对象服务是一种通用的服务
        对象服务的本质是将覆盖对象整个生存期的对象管理任务标准化：
            例如，对象的创建，对象的访问控制，并发和安全性等
            可导致不同应用程序的一致性，提高开发的效率
            COSS：包括对象命名，事件，等的规范

    公共设施：包括分布式文档设施，打印社是，数据库设施，电子邮件设施等
        同样具有自己的规范

    领域接口：
        与应用领域有关的接口
        例如，金融，医疗，电子商务等
        不同领域有不同的规范
        标准划主要是指针对接口的标准化

    应用程序的接口：
        应用程序对象是终端用户执行的任务
        不是OMG标准划的内容，是构成整个OMA模型的最上层</code></pre><h3 id="CORBA体系结构"><a href="#CORBA体系结构" class="headerlink" title="CORBA体系结构"></a>CORBA体系结构</h3><pre><code>对象模型
    对象模型描述了对象外部特征的标准语义
    对象，类型，操作属性等语义和Java等OO语言十分相近
    但同时具有组件/构件的特征
    分布式对象
客户程序与对象实现之间的界面是对象的接口定义
    接口
        客户程序所看到的对象接口完全独立于
            对象所处的位置
            实现对象的程序设计语言
            对象接口中未反映的其他特性
    这种独立性是独立于ORB来保证
对象接口采用接口定义语言IDL定义

OMG请求可携带的信息：
    操作
    提供服务的目标对象引用
    实际参数
    一个可选的上下文
    请求表

对象的创建和撤销
    从客户的角度看，没有特别的机之用于创建和撤销对象

ORB结构
    客户程序与动态调用接口，IDL Stub，ORB接口交互
    对象实现与ORB接口，静态IDLSkeleton，动态框架，对象适配器交互

ORB接口：
    客户程序只能通过对象的接口定义掌握对象的逻辑结构，客户程序不会知道对象具体的实现方式，也不必知道哪个对象适配器以及需要哪个ORB访问该对象实现
    对象实现可以用多种方式实现
        独立的服务程序，程序库每个方法用一个程序实现
        通过附加的程序适配器，ORB事实上可以支持所有风格的对象实现

Stub/Skeleton机制
    采用Stub/Skeleton机制支持客户端和服务端的交互
    stub桩的调用方式：静态调用
        静态调用借助于客户程序桩完成
        桩与框架再编译时创建并且在运行时不再改变，所以这些接口成为SII（Static Invocation Interface）
        IDL桩负责客户程序的实现语言与ORB内核之间的映射
        客户程序需要在编译之前知道操作的名字，方式等
    IDL skeleton：静态请求分派方式
        静态方式通过由IDL生成的框架完成
        ORB通过IDL框架查找合适的实现代码，传送参数，并将控制传送给对象实现
        对象实现执行请求时可以通过对象适配器OA获取ORB的某些服务，请求完成后控制与结果返回客户程序

    动态调用接口（DII）
        客户程序使用DII时不许生成一个请求，其中包括对象引用，操作以及参数表
        使用DII的应用程序访问对象实现提供的服务时，不必包含由IDL编译器生成的桩，只需在运行时间访问ANY对象
        代价：程序员必须用DII接口指定操作和每个操作的类型和值，并由我们自己解决类型检查
        延迟同步调用：
            用户程序提交请求后不必等候答复，还必须轮询，可以利用CORBA的异步消息服务来实现纯异步
        DII较SII更适合的场合：
            编写CORBA服务的浏览器
            应用程序浏览器
            转换协议的桥接
            访问大量不同的接口
            应用程序的监控
            同意对象测试程序等

    动态框架接口（DSI）
        动态方式使用DSI
        不必包含IDL产生的框架
        需要手工编程必须检查类型的安全性
        DIS优于静态的场合：
            类似DII

    对象适配器
        对象实现与ORB内核之间的通信由对象适配器完成（客户程序不需要与ORB内核交互）
            对象适配器负责与对象有关的一系列操作，包括
                对象引用的生成与解释，方法调用，交互的安全性，对象实现的激活与冻结等
            为满足特定的系统，不同的系统又不同的适配器

CORBA的可操作性
    ORB对于可操作性的支持
        ORB可以支持同一厂家ORB上的客户端与服务端方便的交互
        不同的ORB产品之间的互操作性
        影响互操作性的因素    
            实现方面的差异
            安全性
    域：支持开发人员根据自己实现因素或者管理原因将对象划分为不同的集合
        不同域的对象之间需要桥接机制才可以彼此交互
    域之间的桥接
        直接桥接
            需交互的元素直接转换为两个域的内部表示
            效率高通用性不好
        简介桥接
            需交互元素在域的内部表现形式和各个域认可的另一种表现形式之间互相转换
    不同平台域语言之间的互操作性
        IDL标准和IDL到程序语言的映射
    不同厂商的ORB产品之间的互操作性
        靠FIOP和IIOP的协议实现</code></pre><h2 id="第三章-CORBA应用程序的开发"><a href="#第三章-CORBA应用程序的开发" class="headerlink" title="第三章 CORBA应用程序的开发"></a>第三章 CORBA应用程序的开发</h2><h3 id="CORBA平台架构"><a href="#CORBA平台架构" class="headerlink" title="CORBA平台架构"></a>CORBA平台架构</h3><pre><code>建议使用OO语言实现CORBA
    IDL是OO风格的

CORBA运行平台
网络传输
消息传递
    同步方式
        ORB默认的通信方式    
    异步方式（延迟同步方式）
    单向通信
        监控
    不同场合使用：
        所申请的服务只需要很短时间就可以完成（同步）
        所申请的服务需要较长的时间才可以完成（异步）
        客户端无需获取请求已完成的确认信息（单向）
资源优化

CORBA应用程序开发过程
    面向对象分析与设计
    用IDL编写对象接口
    编译IDL文件生成装与框架
    编写客户端/服务程序代码
    编译客户端/服务程序
    部署应用程序
    运行应用程序

银行账户管理案例：
    定义接口对象：</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 银行帐户管理系统的对象接口定义</span><br><span class="line">module Bank &#123;</span><br><span class="line">    // 帐户</span><br><span class="line">    interface Account &#123;</span><br><span class="line">        // 存款</span><br><span class="line">        void deposit(<span class="keyword">in</span> <span class="built_in">float</span> amount);</span><br><span class="line">        // 取款</span><br><span class="line">        boolean withdraw(<span class="keyword">in</span> <span class="built_in">float</span> amount);</span><br><span class="line">        // 查询余额</span><br><span class="line">        <span class="built_in">float</span> getBalance();</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    // 帐户管理员</span><br><span class="line">    interface AccountManager &#123;</span><br><span class="line">        // 查询指定名字的帐户，查无则新开帐户</span><br><span class="line">        Account open(<span class="keyword">in</span> string name);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<pre><code>    定义结构定义对象为了生成stub与skeleton
        账户对象Account：

            AccountOperations.java ：
            Account.java
            _AccountStub.java ：客户端存根（stub），是Account再客户端的桩代码，它实现的Account接口
                程序员编写的客户程序代码一般不调用这个类中的方法
                VisiBroker for java生成了另外的辅助类AccountHelper
                    该类提供了一个narrow方法，用于返回一个Account接口的指针
                    实际上该方法实例化了一个_AccountStub对象，所以客户端通过返回的接口指针实际调用了桩对象的代码
                    由桩对象完成具体的和服务端的通信
            AccountPOA.java ：服务端框架（skeletion），是Account对象的服务器框架代码，功能：
                解开in类型的参数，并将参数传递给对象实现
                打包返回值与所有out类型的参数
                    打包：java的数据类型转化为CORBA的ⅡOP流格式
                    解包：从ⅡOP流格式转换为依赖于JAVA的数据结构
                编写对象实现的最简单途径是继承这些POA类
                    即把他们作为对象的基类
    生成的纽带机制类：
        AccountPOAtIE.java用于采用纽带机制实现服务端的Account对象
            AccountPOATie是Account接口的委托方的实现
            应为java语言的单重继承限制，所以引入了纽带机制
            每一个AccountTie对象必须关联一个真正的实现类
            真正的实现类必须实现AccountOperations接口
    生成的辅助工具类：
        AccountHelper.java声明AccountHelper类
            该类为Account接口定义了许多实用功能和支持功能的静态方法
            绑定对象与类型转换操作
            从输入/输出流读写对象
    生成的对象传递支撑类：
        AccountHolder.java声明的AccountHeolder类为传递对象提供支持
            IDL由三种传递参数的方式：in，out，inout
            in类型的参数以及返回结构与java类型参数传递与返回结构完全相同
            out和inout两种类型的参数允许参数具有返回结果的能力，无法直接映射到java语言的参数传递机制
            这是AccountHolder类为参数传递out和inout参数提供了一个托架
账户对象实现：</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class AccountImpl</span><br><span class="line">	extends Bank.AccountPOA</span><br><span class="line">&#123;</span><br><span class="line">	protected <span class="built_in">float</span> balance;//定义余额属性</span><br><span class="line">	</span><br><span class="line">	public AccountImpl(<span class="built_in">float</span> bal)</span><br><span class="line">	//构造方法，按照传递的余额（bal）创建新的账户</span><br><span class="line">	&#123;</span><br><span class="line">		balance = bal;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public void deposit(<span class="built_in">float</span> amount)</span><br><span class="line">	//存款 </span><br><span class="line">	&#123;</span><br><span class="line">		balance += amount;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public boolean withdraw(<span class="built_in">float</span> amount)</span><br><span class="line">	//取款，如果不够返回<span class="literal">false</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(balance &lt; amount)</span><br><span class="line">			<span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			balance -= amount;</span><br><span class="line">			<span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public <span class="built_in">float</span> getBalance()</span><br><span class="line">	//查询余额</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">return</span> balance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>账户管理员对象实现：</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">import org.omg.PortableServer.*;</span><br><span class="line"></span><br><span class="line">public class AccountManagerImpl</span><br><span class="line">	extends Bank.AccountManagerPOA</span><br><span class="line">&#123;</span><br><span class="line">	protected Hashtable accountList;//该账户管理员所负责的账户清单</span><br><span class="line">	public AccountManagerImpl()</span><br><span class="line">	//构造方法，创建一个管理员对象</span><br><span class="line">	&#123;</span><br><span class="line">		accountList = new Hashtable();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public synchronized Bank.Account open(String name)</span><br><span class="line">	//给用户开户</span><br><span class="line">	&#123;</span><br><span class="line">		Bank.Account account = (Bank.Account)accountList.get(name);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(account == null)</span><br><span class="line">		//如果该name对应的账户不存在，则新开一个账户，初始余额为0</span><br><span class="line">			&#123;			</span><br><span class="line">			<span class="built_in">float</span> balance = 0;</span><br><span class="line">			AccountImpl accountServant = new AccountImpl(balance);</span><br><span class="line">			try&#123;</span><br><span class="line">				//用缺省的POA激活对象，这里缺省的POA就是根POA</span><br><span class="line">				org.omg.CORBA.Object obj = </span><br><span class="line">					_default_POA().servant_to_reference(accountServant);</span><br><span class="line">				//将对象引用窄化为Account类型</span><br><span class="line">				account = Bank.AccountHelper.narrow(obj);</span><br><span class="line">			&#125;catch(Exception exc)&#123;</span><br><span class="line">				exc.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			accountList.put(name, account);</span><br><span class="line">			System.out.println(<span class="string">"新开账户："</span> + name);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">return</span> account;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>编写服务程序：
    初始化ORB
    创建一个对象适配器
    创建提供服务的伺服对象
    激活私服对象
    激活POA管理器
    等待客户程序发来请求
服务程序：</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">import org.omg.PortableServer.*;</span><br><span class="line"></span><br><span class="line">public class Server</span><br><span class="line">&#123;</span><br><span class="line">	public static void main(String[] args)</span><br><span class="line">	&#123;</span><br><span class="line">		try&#123;</span><br><span class="line">			//初始化ORB</span><br><span class="line">			org.omg.CORBA.ORB orb = org.omg.CORBA.ORB.init(args, null);</span><br><span class="line">			//获取根POA的引用</span><br><span class="line">			POA rootPOA = POAHelper.narrow(</span><br><span class="line">				orb.resolve_initial_references(<span class="string">"RootPOA"</span>));</span><br><span class="line">			//创建持久POA的策略</span><br><span class="line">			org.omg.CORBA.Policy[] policies = &#123;</span><br><span class="line">				rootPOA.create_lifespan_policy(LifespanPolicyValue.PERSISTENT),</span><br><span class="line">				//rootPOA.create_id_assignment_policy(IdAssignmentPolicyValue.USER_ID)</span><br><span class="line">			&#125;;</span><br><span class="line">			//用新定义的策略创建myPOA</span><br><span class="line">			POA myPOA = rootPOA.create_POA(<span class="string">"BankPOA"</span>, rootPOA.the_POAManager(), policies);</span><br><span class="line">			//创建伺服对象</span><br><span class="line">			AccountManagerImpl managerServant = new AccountManagerImpl();</span><br><span class="line">			//在myPOA上用标识<span class="string">"BankManager"</span>激活伺服对象</span><br><span class="line">			myPOA.activate_object_with_id(<span class="string">"BankManager"</span>.getBytes(), managerServant);</span><br><span class="line">			//激活POA管理器</span><br><span class="line">			rootPOA.the_POAManager().activate();</span><br><span class="line">			//等待处理客户程序的请求</span><br><span class="line">			System.out.println(<span class="string">"账户管理员BankManager已就绪...\n"</span>);</span><br><span class="line">			orb.run();</span><br><span class="line">		&#125;catch(Exception exc)&#123;</span><br><span class="line">			exc.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>客户程序：</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class Client</span><br><span class="line">&#123;</span><br><span class="line">	public static void main(String[] args)</span><br><span class="line">	&#123;</span><br><span class="line">		//初始化ORB</span><br><span class="line">		org.omg.CORBA.ORB orb = org.omg.CORBA.ORB.init(args, null);</span><br><span class="line">		//利用POA全称与对象标识<span class="string">"BankManager"</span>查找账户管理员</span><br><span class="line">		Bank.AccountManager manager = Bank.AccountManagerHelper.bind(</span><br><span class="line">			orb, <span class="string">"/BankPOA"</span>, <span class="string">"BankManager"</span>.getBytes());//,<span class="string">"192.168.118.3"</span>, new com.inprise.vbroker.CORBA.BindOptions());</span><br><span class="line">		String name = args.length &gt; 0? args[0]:<span class="string">"SHLSong"</span>;</span><br><span class="line">		Bank.Account account = manager.open(name);</span><br><span class="line">		</span><br><span class="line">		System.out.println(name + <span class="string">"的账户余额为"</span> + account.getBalance() + <span class="string">"元"</span>);</span><br><span class="line">		account.deposit(400);</span><br><span class="line">		System.out.println(<span class="string">"存款400元后，余额为"</span> + account.getBalance() + <span class="string">"元"</span>);</span><br><span class="line">		<span class="keyword">if</span>(account.withdraw(500))&#123;</span><br><span class="line">			System.out.println(<span class="string">"取款500元后，余额为"</span> + account.getBalance() + <span class="string">"元"</span>);</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			System.out.println(<span class="string">"余额不足500元，取款失败，余额保持不变"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>编译应用程序
    利用VisiBroker for java提供的编译器vbjc完成这一工作：</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vbjc Server.java</span><br><span class="line">vbjc Client.java</span><br></pre></td></tr></table></figure>
<pre><code>    vbjc十几张封装了JDK提供的Java编译器
    Holder类和POATie需要指定额外的参数才会下生成
按一定的顺序启动应用程序
    1. 启动智能代理
        运行CORBA应用程序之前，网络之中必须至少有一台主机上启动了智能代理osagent
        这是VisiBroker特有的分布式位置服务守护进程，网络中多个智能代理可写作查找合适的对象实现</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">osagent</span><br></pre></td></tr></table></figure>
<pre><code>2. 启动服务程序</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start vbj Server</span><br></pre></td></tr></table></figure>
<pre><code>3. 启动客户程序</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vbj Client</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/111zx/111zx.github.io/2020/03/22/%E6%9E%84%E4%BB%B6%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%8A%80%E6%9C%AF/" data-id="ck88at6vd000714ubh0pkb3z4" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Web工程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/21/Web%E5%B7%A5%E7%A8%8B/" class="article-date">
  <time datetime="2020-03-21T06:42:35.000Z" itemprop="datePublished">2020-03-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/21/Web%E5%B7%A5%E7%A8%8B/">Web工程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="软件架构"><a href="#软件架构" class="headerlink" title="软件架构"></a>软件架构</h2><p>软件架构能够体现出动态的特性</p>
<p>Web架构：</p>
<p>设计模式：<br>各个组件之间如何联系以及怎么设计<br>三个不同的抽象层次：<br>    架构模式：<br>        系统的结构解决方案；<br>        子系统的架构没职责和相互作用<br>    设计模式：<br>        特定情况下。。。<br>    编程模式：<br>        …<br>MVC （model-view-controller）<br>框架：一组组件的综合，对相关的应用提供可重用的框架结构<br>    可以进行实例化<br>    特定领域的基本蓝图<br>    通用的功能已经类实现的可复用软件系统</p>
<p>Struts：</p>
<p>框架的优点：<br>    简单重用框架的架构和功能<br>缺点：<br>    需要专业知识<br>    不同的框架之间没有联系<br>    商业产品太过依赖架构<br>层次特性：<br>    分而治之：<br>数据特性：<br>    结构化还是非结构化<br>分布特性：<br>    分布对象中间件<br>    虚拟共享内存<br>    面向消息中间件<br>    P2P<br>    面向服务的中间件<br>Web应用架构特性<br>    Web基础架构<br>    WPA<br>    不同的系统是使得更难评估和维护各种质量需求<br>    技术架构的异构性和不成熟<br>    国际化<br>通用的包含的组件<br>    那些事Web端，那些事服务端<br>    客户端（浏览器和外部应用）<br>    防火墙<br>    Web服务器</p>
<p>层次架构:<br>    Web应用的两层架构<br>         客户端只有客户<br>        服务端：数据库，业务逻辑等等<br>    Web应用的三层架构<br>        展示层：封装用户和其他系统的交互<br>        逻辑层：业务逻辑<br>        数据层：相关数据<br>    Ruby on Rauls应用架构<br>     ASP.NET应用架构:三层架构<br>     Web应用的N曾架构<br>         业务层的扩展，其他和三层差不多的</p>
<pre><code>后端：三层五共享架构
...
JAVA EE应用架构
    客户层
    Web层
    业务层
    数据层
JSP-Model-2：html代码镶嵌上JAVA代码
jsp不需要编译过后再运行，在应用服务器可以直接运行
JSP运行模式：先回转成JAVA代码，而HTML会翻译成字符串（后来的开发工具已经解决）
JSP-Model 实现 in Struts
    Web-Server包括 Serverlet -Container
Websphere
SPA:四层
    view
    应用服务
    存储
    。。。
单体架构
    打包成一个包，部署和测试会更容易
多层应用的优点：
    重用：
        扩展性好
        代码好维护
缺点：
    切割复杂
    故障点</code></pre><p> 层次架构的设计：<br>     …<br> 集成架构：<br>     展示层面<br>     应用逻辑层面<br>     服务层<br> 门户（Poetal）：针对具体用户或者社区的应用平台<br>                 水平门户：新浪，腾讯<br>                 垂直门户：W3C,语义Web社区等<br> EAI（企业应用集成）：<br>     强调内容层面和应用逻辑层面集成的架构<br>     集成遗留系统<br>     采用中间件<br>     继承不同数据源，不同平台的异构应用<br> SOA（面向服务的架构）：<br>     提供一种集成框架<br>     关键是服务<br>         Web服务是实现SOA的方式之一<br>         应用程序的业务功能称为服务<br> 面向数据的架构<br>     数据结构分类<br>         数据库的结构化数据<br>         文档类<br>         多媒体数据和媒体服务器<br>     Web应用结合使用<br>     以数据库为中心的架构<br>     Web文档管理架构<br>     流媒体数据的架构：<br>         直播是 实时流协议<br>     使用广播的流架构</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><pre><code>好的架构可以提高Web应用的开发效率，可重用性，易于维护和扩展
    架构模式
    层次架构
    面向数据的架构
    集成架构</code></pre><p>淘宝基于Node的前后端分离<br>    Node服务：</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/111zx/111zx.github.io/2020/03/21/Web%E5%B7%A5%E7%A8%8B/" data-id="ck88at6v7000214ub0h7mg3kf" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Python基础" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/18/Python%E5%9F%BA%E7%A1%80/" class="article-date">
  <time datetime="2020-03-18T08:31:31.000Z" itemprop="datePublished">2020-03-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/18/Python%E5%9F%BA%E7%A1%80/">Python基础</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="第一章-Python介绍"><a href="#第一章-Python介绍" class="headerlink" title="第一章 Python介绍"></a>第一章 Python介绍</h2><h3 id="Python历史"><a href="#Python历史" class="headerlink" title="Python历史"></a>Python历史</h3><pre><code>Gudi van Rossum（python之父）开发的一种解释程序，作为ABC语言的一种继承。
第一个Python解释器是由C语言实现的，并且可以调用C语言的库文件。

Python的设计目标
    1. 简单直观
    2. 开源，以便任何人都可以为它做出贡献
    3. 代码像纯英文那样容易理解
    4. 适用于短期开发的日常任务</code></pre><h3 id="Python的执行方式"><a href="#Python的执行方式" class="headerlink" title="Python的执行方式"></a>Python的执行方式</h3><pre><code>Python是一种跨平台，开源，免费的解释习性高级动态编程语言。但不是一种严格的解释型语言（和JAVA类似）。
    Python语言在运行前，.py文件会先伪编译成.pyc文件（字节码文件），.pyc文件与平台无关，不论是Windows还是Linux都可以执行，运行时虚拟机逐行把字节码翻译成目标代码。</code></pre><img src="/2020/03/18/Python%E5%9F%BA%E7%A1%80/1.jpg" class title="[Python程序执行流程]">

<h2 id="第二章-Python语言基础"><a href="#第二章-Python语言基础" class="headerlink" title="第二章 Python语言基础"></a>第二章 Python语言基础</h2><h3 id="Python的对象模式"><a href="#Python的对象模式" class="headerlink" title="Python的对象模式"></a>Python的对象模式</h3><pre><code>Python种有许多内置对象可供编程者使用，内置对象可直接使用，如数字，字符串，列表，del等；非内置对象需要导入模块才能使用，如正选函数sin(),随机数产生函数random().

常用的内置对象：
    1. 数字（int，float，complex），数字没有大小限制，内置支持复数及其运算。
    2. 字符串(str)，单引号，双引号和三引号作为定界符，以字母R或者r引导的表示原始字符串（忽略转义字符）。
    3. 字节串（bytes），以字母b引导，可以使用单引号，双引号和三引号作为定界符
    4. 列表（list），所有元素放在一对括号中，元素之间用逗号分隔，其中元素可以是任意类型。
    5. 字典（dict），所有元素放在一对大括号中，元素之间用逗号分隔，元素形式为“键：值”。
    6. 元组（tuple），不可变，所有元素放在一对大括号中，元素之间使用逗号分隔。如果元组只有一个元素的话，后面的都好不能省略。
    7. 集合（set，frozenset），所有元素放在一对大括号中，元素之间使用逗号分隔，元素不允许重复；另外set是可变的，frozenset是不可变的。</code></pre><h3 id="Python变量"><a href="#Python变量" class="headerlink" title="Python变量"></a>Python变量</h3><pre><code>在Python之中不需要事先声明变量名以及其类型，直接复制即可创建各种类型的变量。
Python是一种强类型编程语言，Python解释器会根据赋值或运算自动推断变量类型。而且Python的变量类型是可以随时变化的。</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x = 3</span><br><span class="line">&gt;&gt;&gt; <span class="built_in">print</span>(<span class="built_in">type</span>(x))</span><br><span class="line">&lt;class <span class="string">'int'</span>&gt;</span><br><span class="line">&gt;&gt;&gt; x = <span class="string">"python"</span></span><br><span class="line">&gt;&gt;&gt; <span class="built_in">print</span>(<span class="built_in">type</span>(x))</span><br><span class="line">&lt;class <span class="string">'str'</span>&gt; //类型从int转成了str</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; isinstance(x,int)</span><br><span class="line">False //x类型判断不是int</span><br></pre></td></tr></table></figure>
<pre><code>字符串和元组属于不可变序列，不能通过下标的方式修改其中的元素值
在Python中允许多个变量指向同一个值，当其中一个变量修改值之后，其内存地址将会发生变化，但不影响另一个变量。</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x = 3</span><br><span class="line">&gt;&gt;&gt; y = 3</span><br><span class="line">&gt;&gt;&gt; id(x)</span><br><span class="line">2073487312</span><br><span class="line">&gt;&gt;&gt; id(y)</span><br><span class="line">2073487312 //x 和 y指向同一个地址</span><br><span class="line">&gt;&gt;&gt; y = y+3</span><br><span class="line">&gt;&gt;&gt; y</span><br><span class="line">6</span><br><span class="line">&gt;&gt;&gt; id(y)</span><br><span class="line">2073487360 // y变量改变值，生成了一个新的地址，值为6</span><br><span class="line">&gt;&gt;&gt; id(x)</span><br><span class="line">2073487312 //y的盖面并没有影响x指向的地址</span><br></pre></td></tr></table></figure>
<pre><code>Python语句执行的过程
    1. 将等号右侧的表达式的值计算出来，存在内存中。
    2. 创建变量指向这个内存地址
Python具有自动内存管理功能，对于没有变量指向的值，会自动将其删除。
但是使用del删除不需要的资源也是一个很好的习惯
变量命名需要注意的问题：
    1. 必须以下划线或者字母开头，下划线开头有特殊的含义
    2. 不能有关键字
    3. 不能有空格以及标点符号
    4. 不建议使用系统内置的模块名，类型名或者函数名
    5. python对大小写敏感，Stu和stu是不同的
数字：
    数字式不可变对象，可以表示无限大的数
    进制表示：
        十进制： 5
        二进制： 0b101
        八进制： 0o5
        十六进制：0x5
    python内置支持复数类型</code></pre><h2 id="第四章-字符串"><a href="#第四章-字符串" class="headerlink" title="第四章 字符串"></a>第四章 字符串</h2><pre><code>在python，字符串属于不可变序列类型，只能访问和读取，但是不可以修改。
Python字符串驻留机制：短字符串，赋值给多个对象时，内存之中只会有一个副本，但是长字符串就不会只有一个副本。</code></pre><p>字符串格式化<br>%r和%s<br>int函数转整型<br>str可以把对象转换成字符串<br>eval函数<br>format方法可以格式化</p>
<p>python3.6之后支持新的格式化方式在字符串前+f</p>
<p>字符串常用的个方法<br>find(),rfind(),ubdex(),rindex(),count()等.</p>
<p>split(),rsplit()从左往右，从右往左，允许需指定最大分割次数 None参数的含义：任何空白符号，空格，换行，制表符连续多个空白符好被看作一个空白符，再明确指定分隔符时正常分割。</p>
<p>连接符join（）可指定连接符  ，效率相比其他的方法会快很多</p>
<p>timeit显示运行时间</p>
<p>效率： map函数&gt;列表&gt;普通<br>lower()等<br>replace()，全部替换，换成一个新的字符串</p>
<p>例子：替换敏感词</p>
<p>maketrans() 和 translate() 相比replace而言不是整体的替换，此处是映射替换，maketrans()生成字符映射表，translate根据表中的映射规则替换其中的字符</p>
<p>例子：转钱的数字转换，凯撒加密</p>
<p>partition rpartition</p>
<p>strip 从两边开始向里面开始逐个删除</p>
<p>文本规范化</p>
<p>内置函数eval()：对字符串进行求值  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="string">'a+b'</span>)</span><br></pre></td></tr></table></figure>
<p>结果为8<br>eval()函数是非常危险的，只管执行，不管判断<br>合法的eval()代替eval()可以降低危险</p>
<p>关键字in</p>
<p>字符串的乘法：重复并且时新的串</p>
<p>startswith，endswith 判断是否以指定的字符开始或者结束，可以根据文件格式查找文件。</p>
<p>center，ljust，rjust为居中，左对齐和右对齐。</p>
<p>zfill()返回指定宽度的字符串，默认填0</p>
<p>判断的一系列方法（isalnum，isalpha，isdigit等）</p>
<p>isdigit只能判断整数</p>
<p>isnumeric可以判断汉字的数字和罗马数字</p>
<p>len(),max(),min(),list(zip(x,x))</p>
<p>切片也适用于字符串，但是仅限于读取其中的元素，不可以修改</p>
<p>zlib.compress</p>
<p>随机密码生成原理</p>
<p>可变字符串</p>
<p>正则表达式</p>
<h2 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h2><p>作用：省去定义函数过程<br>     不需要给代码起名字<br>     增加可读性<br>emample：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; list(filter(lambda x : x % 2, range(10)))</span><br><span class="line">[1, 3, 5, 7, 9]</span><br></pre></td></tr></table></figure>
<p>等价于</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def <span class="built_in">test</span>(x):</span><br><span class="line">	<span class="built_in">return</span> x % 2</span><br><span class="line">&gt;&gt;&gt; list(filter(<span class="built_in">test</span>,range(10)))</span><br><span class="line">[1, 3, 5, 7, 9]</span><br></pre></td></tr></table></figure>

<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><pre><code>匹配IP地址：</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/111zx/111zx.github.io/2020/03/18/Python%E5%9F%BA%E7%A1%80/" data-id="ck88at6v5000114ub614c0370" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-算法设计与分析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/18/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/" class="article-date">
  <time datetime="2020-03-18T02:28:17.000Z" itemprop="datePublished">2020-03-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/18/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/">算法设计与分析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="第一章-算法介绍"><a href="#第一章-算法介绍" class="headerlink" title="第一章 算法介绍"></a>第一章 算法介绍</h2><p>算法设计的基本步骤：</p>
<ol>
<li>问题的建模。</li>
<li>选择什么样的算法以及怎样描述这个方法？</li>
<li>这个算法是否对所有的实例都能得到最优解（算法的效率）？如何证明？</li>
<li>如果不是，能否找到反例？</li>
</ol>
<p>投资问题蛮力算法的排列组合算法</p>
<p>方程X1 + X2 + … + Xn = m 的非负整数解&lt;x1,x2, … xn&gt;的个数估计：<br>可行解表示成0-1序列： m个1，n-1个0<br> 例如  m = 5  n = 4<br>  0 0 0 1 1 1 1 1<br>  则该解的集合会有C（5+4-1，3）= 56个元素。</p>
<h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><p>一. 插入排序<br>二. 归并排序<br>三. 堆排序<br>四. 快速排序<br>（以上是非线性排序算法，以下是线性排序算法）<br>五. 计数排序<br>六. 基数排序<br>七. 桶排序</p>
<ol>
<li>数组A放入数组B中。分桶</li>
<li>数组B内插入排序。桶内采用插入排序</li>
<li>B[0]-B[9]数组接起来。接桶<br>时间复杂度分析：<br>T（n）= O（n）+ ΣO（n^2）<br>使用要求：最好是数组内的元素按一定的规律事先排序好的。<br>空间复杂度？<br>稳定性？</li>
</ol>
<h2 id="中位数和顺序统计学"><a href="#中位数和顺序统计学" class="headerlink" title="中位数和顺序统计学"></a>中位数和顺序统计学</h2><p>顺序统计学：<br>找到N个元素中第i小的元素</p>
<p>中位数：最中间的位置（不受极大值和极小值的影响）<br>偶数位会有两个中位数（3，4位），只取一个的话取小（？）。</p>
<p>最大最小的话时间复杂度O（n）</p>
<p>第i小的话O（nlgn）<br>可以使用构建堆的方式时间复杂度为O（n）时间复杂度为O(nlgi)</p>
<p>利用快速排序 先找到基准元素的位置k，k为第k小的元素，之后即可根据k和i关系找到第i小的元素伪代码展示如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RANDOMIZED-SELECT(A,p,r,i)</span><br><span class="line"><span class="keyword">if</span>(p = r)</span><br></pre></td></tr></table></figure>
<p>最坏的情况下：9：1（k为最开始或最末尾）<br>时间复杂度为O（n^2）<br>T（n）= T（n-1）+O（n）</p>
<p>大部分状况下为：O（n）使用主方法证明<br>T（n）= T（9n/10）+ O（n）</p>
<p>解决方法尽量避免最坏情况：找到一个尽量好的基准元素。<br>插入排序对组内元素进行排序（5个元素一组），找出中位数，再递归进行插入排序，依然为5个一组，知道找到合适的中位数。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT(A,i)</span><br><span class="line">1. 分成n/5个中位数组插入排序</span><br><span class="line">2. 找到中位数</span><br><span class="line">3. 将中位数再排序，找到中位数x （n/5）/2</span><br><span class="line">4. 3倍的大于，3倍的小于</span><br><span class="line">5.  7n/10 + 6 e  ？？？？？？</span><br></pre></td></tr></table></figure>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>往往用来求最优化问题<br>最短路线，最优方案，最小值。<br>方法：自底向上（分治总是和递归方法在一起）<br>步骤：</p>
<ol>
<li>刻画最优解的结构；</li>
<li>递归地去定义最优解的值；(以递归方式去定义)</li>
<li>以自底向上的方式求最优解的值；（以迭代的方式去求解，并记录最优解的路线）</li>
<li>根据最优解的路线最优解构造出来。</li>
</ol>
<p>问题背景：<br>公司有两条装配线1，2，每条线有n个工位<br>S1，1 - S1，n<br>S2，1 - S2，n对应的工作完全一样<br>但是每个对应工位的效率是不同的<br>相同装配线工位的交接是可以忽略不计的，不同的装配线之间的交接是需要时间的。<br>问：快速装配汽车，找一条从汽车底盘进入装配线到离开装配线为止最快的路线？（链接 dp6）<br>动态规划只求一个最优解</p>
<p>问题解决：</p>
<ol>
<li>刻画最优解的结构：<br>经过S1，j最快的路径，j = 1，直接上配置线1；如果j &gt;= 2，必须经过S2，j-1或者S1，j-1<br>  经过S1，j-1的话必须经过S1，j-1的最佳路径<br> 经过S2，j-1的话必须经过S2，j-1的最佳路径<br>最优解结构：<br>一个问题的最优解一定包含子问题的最优解。</li>
<li>递归地去定义最优解的值：<br> 第一种方法（但是不用递归求解，而是用自底向上求）：<br> 经过S1（dp page8）切换线需要额外的传输时间<br> 经过S2（dp page8）</li>
<li>以自底向上的方式求最优解的值：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FASTEST-WAY(a,t,e,x,n)</span><br></pre></td></tr></table></figure>
L1[J] 和L2[J]不是记录最优路线的。L[J]是记录最有路线的。</li>
</ol>
<h3 id="矩阵链乘"><a href="#矩阵链乘" class="headerlink" title="矩阵链乘"></a>矩阵链乘</h3><p>目的是确定那些矩阵先相乘，那些矩阵后相乘</p>
<p>蛮力法数量太大</p>
<p>假设Ai ~ Aj 相乘 在Ak断开，是最优解，包含子问题最优解<br>自底向上的伪代码算法</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="问题：非递减数组一定是最小堆吗"><a href="#问题：非递减数组一定是最小堆吗" class="headerlink" title="问题：非递减数组一定是最小堆吗"></a>问题：非递减数组一定是最小堆吗</h3><h3 id="动态规划最重要的一步：刻画最优子结构"><a href="#动态规划最重要的一步：刻画最优子结构" class="headerlink" title="动态规划最重要的一步：刻画最优子结构"></a>动态规划最重要的一步：刻画最优子结构</h3><pre><code>问题的最优解包含了子问题的最优解

不是所有的最优解都有最优子结构

最长路径没有最优子结构 最短路径有最优子结构</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/111zx/111zx.github.io/2020/03/18/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/" data-id="ck88at6ve000814ubeq3h9g87" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-IDEA-学习" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/15/IDEA-%E5%AD%A6%E4%B9%A0/" class="article-date">
  <time datetime="2020-03-15T07:13:57.000Z" itemprop="datePublished">2020-03-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/15/IDEA-%E5%AD%A6%E4%B9%A0/">IDEA 学习</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一-Intellij-IDEA的介绍和优势"><a href="#一-Intellij-IDEA的介绍和优势" class="headerlink" title="一. Intellij IDEA的介绍和优势"></a>一. Intellij IDEA的介绍和优势</h2><h3 id="1-所属公司：JetBrains"><a href="#1-所属公司：JetBrains" class="headerlink" title="1.所属公司：JetBrains"></a>1.所属公司：JetBrains</h3><pre><code>其他产品：
AppCode
GoLand
PyCharm
WebStorm等
Android Studio：谷歌公司基于IDEA开发的。</code></pre><h3 id="2-Intellj-IDEA-介绍"><a href="#2-Intellj-IDEA-介绍" class="headerlink" title="2.Intellj IDEA 介绍"></a>2.Intellj IDEA 介绍</h3><pre><code>Intellj IDEA是用于支持JAVA,Sacla，Groovy等语言的开发工具，擅长于企业应用，移动应用和Web应用。</code></pre><h3 id="3-Intellj-IDEA-优势（相比Eclipse）"><a href="#3-Intellj-IDEA-优势（相比Eclipse）" class="headerlink" title="3.Intellj IDEA 优势（相比Eclipse）"></a>3.Intellj IDEA 优势（相比Eclipse）</h3><pre><code>①强大的整合能力。
②提示功能快速，便捷。
③提示功能的范围广。
④好用的快捷键和代码模板。
⑤精准搜索。</code></pre><h2 id="二-Intellj-IDEA的安装"><a href="#二-Intellj-IDEA的安装" class="headerlink" title="二. Intellj IDEA的安装"></a>二. Intellj IDEA的安装</h2><h3 id="1-Intellj-IDEA的安装目录"><a href="#1-Intellj-IDEA的安装目录" class="headerlink" title="1.Intellj IDEA的安装目录"></a>1.Intellj IDEA的安装目录</h3><p>①bin目录：启动文件和虚拟机的配置信息和IDEA的基本属性的信息等。<br>    虚拟机配置信息文档idea64.exe.vmoptions<br>            <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">-Xms2048m <span class="comment">#初始内存</span></span><br><span class="line">-Xmx4096m <span class="comment">#最大内存 可以降低垃圾回收频率</span></span><br><span class="line">-XX:ReservedCodeCacheSize=512m <span class="comment">#可保留代码的缓存大小 可以降低垃圾回收频率</span></span><br><span class="line">-XX:+UseConcMarkSweepGC</span><br><span class="line">-XX:SoftRefLRUPolicyMSPerMB=50</span><br><span class="line">-ea</span><br><span class="line">-XX:CICompilerCount=2</span><br><span class="line">-Dsun.io.useCanonPrefixCache=<span class="literal">false</span></span><br><span class="line">-Djava.net.preferIPv4Stack=<span class="literal">true</span></span><br><span class="line">-Djdk.http.auth.tunneling.disabledSchemes=<span class="string">""</span></span><br><span class="line">-XX:+HeapDumpOnOutOfMemoryError</span><br><span class="line">-XX:-OmitStackTraceInFastThrow</span><br><span class="line">-Djdk.attach.allowAttachSelf=<span class="literal">true</span></span><br><span class="line">-Dkotlinx.coroutines.debug=off</span><br><span class="line">-Djdk.module.illegalAccess.silent=<span class="literal">true</span></span><br><span class="line">-Xverify:none</span><br><span class="line">-javaagent:..\..\bin\JetbrainsCrack.jar</span><br></pre></td></tr></table></figure></p>
<p>②help：帮助文档。<br>③jre64：jre的运行环境。<br>④lib：IDEA相关的类库。<br>⑤license：相关插件的一些许可信息。<br>⑥plugins：插件信息。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/111zx/111zx.github.io/2020/03/15/IDEA-%E5%AD%A6%E4%B9%A0/" data-id="ck88at6uv000014ub8sfxhzei" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/03/26/%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/">软件体系结构</a>
          </li>
        
          <li>
            <a href="/2020/03/26/%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B%E7%AE%A1%E7%90%86/">软件过程管理</a>
          </li>
        
          <li>
            <a href="/2020/03/25/javaWeb%E9%A1%B9%E7%9B%AE%E5%87%BA%E7%8E%B0%E9%97%AE%E9%A2%98%E6%95%B4%E5%90%88/">javaWeb项目出现问题整合</a>
          </li>
        
          <li>
            <a href="/2020/03/24/Web%E6%A1%88%E4%BE%8B%E5%AD%A6%E4%B9%A0/">Web案例学习</a>
          </li>
        
          <li>
            <a href="/2020/03/24/%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/">系统分析与设计</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 zx<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>