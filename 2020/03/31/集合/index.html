<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>集合 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="[TOC] 集合框架的概述集合与数组的比较 集合与数组都是对多个数据进行存储的，简称Java容器  说明：此时的存储主要是内存层面的存储，不涉及到持久化(硬盘)的存储。例如.txt,.sql都是硬盘存储 数组在存储多个数据方面的优缺点 优点：  一旦初始化以后，长度是确定的 数组一旦定义好，元素的类型也确定了，只能操作确定类型的数据。Object[] arr可以实现多态   缺点：  一旦初始化好">
<meta property="og:type" content="article">
<meta property="og:title" content="集合">
<meta property="og:url" content="https://github.com/111zx/111zx.github.io/2020/03/31/%E9%9B%86%E5%90%88/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="[TOC] 集合框架的概述集合与数组的比较 集合与数组都是对多个数据进行存储的，简称Java容器  说明：此时的存储主要是内存层面的存储，不涉及到持久化(硬盘)的存储。例如.txt,.sql都是硬盘存储 数组在存储多个数据方面的优缺点 优点：  一旦初始化以后，长度是确定的 数组一旦定义好，元素的类型也确定了，只能操作确定类型的数据。Object[] arr可以实现多态   缺点：  一旦初始化好">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-03-31T01:55:33.000Z">
<meta property="article:modified_time" content="2020-06-10T03:27:32.002Z">
<meta property="article:author" content="zx">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://github.com/111zx/111zx.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-集合" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/31/%E9%9B%86%E5%90%88/" class="article-date">
  <time datetime="2020-03-31T01:55:33.000Z" itemprop="datePublished">2020-03-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      集合
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<h1 id="集合框架的概述"><a href="#集合框架的概述" class="headerlink" title="集合框架的概述"></a>集合框架的概述</h1><h2 id="集合与数组的比较"><a href="#集合与数组的比较" class="headerlink" title="集合与数组的比较"></a>集合与数组的比较</h2><ul>
<li><p>集合与数组都是对多个数据进行存储的，简称Java容器</p>
<ul>
<li><p>说明：<strong>此时的存储主要是内存层面的存储</strong>，不涉及到持久化(硬盘)的存储。例如.txt,.sql都是硬盘存储</p>
<h4 id="数组在存储多个数据方面的优缺点"><a href="#数组在存储多个数据方面的优缺点" class="headerlink" title="数组在存储多个数据方面的优缺点"></a>数组在存储多个数据方面的优缺点</h4></li>
<li><p>优点：</p>
<ul>
<li>一旦初始化以后，<strong>长度是确定的</strong></li>
<li>数组一旦定义好，元素的类型也确定了，只能操作<strong>确定类型</strong>的数据。Object[] arr可以实现<strong>多态</strong></li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>一旦初始化好，长度不可修改</li>
<li>数组中提供的操作等<strong>方法非常有限</strong>，效率低</li>
<li>获取数组中<strong>实际元素的个数，数组中没有</strong>现成的方法</li>
<li>数组存储数据的特点：<strong>有序，可重复</strong>。对于无序，不可重复的需求，不能满足</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="集合框架体系"><a href="#集合框架体系" class="headerlink" title="集合框架体系"></a>集合框架体系</h2><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>大概分为Collection和Map两种体系</p>
<ul>
<li>Collection接口，单列集合，用来存储一个一个的对象<ul>
<li>List：有序，可重复。<strong>“动态”</strong>数组</li>
<li>Set：无序，不可重复。类似于高中课本上的集合</li>
</ul>
</li>
<li>Map接口：双列集合，用来存储一对（key，value）的数组。类似于高中课本上的函数y = value（key），一个key不可以对应多个value</li>
</ul>
<hr>
<h3 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h3><h4 id="方法总结"><a href="#方法总结" class="headerlink" title="方法总结"></a>方法总结</h4><h5 id="add"><a href="#add" class="headerlink" title="add()"></a>add()</h5><h5 id="addAll"><a href="#addAll" class="headerlink" title="addAll()"></a>addAll()</h5><ul>
<li>将一个集合中的元素全部加到当前集合</li>
</ul>
<h5 id="isEmpty"><a href="#isEmpty" class="headerlink" title="isEmpty()"></a>isEmpty()</h5><h5 id="clear"><a href="#clear" class="headerlink" title="clear()"></a>clear()</h5><ul>
<li>清空集合元素的<strong>数据</strong></li>
</ul>
<h5 id="contains"><a href="#contains" class="headerlink" title="contains()"></a>contains()</h5><ul>
<li><p>判断当前集合中是否包含括号内元素</p>
</li>
<li><p>调用的是括号内类元素的内置<strong>equals()方法</strong>，String类（重写了equals()方法，比的是变量）和一般的没有重写equals()方法的类contains()结果会有出入</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> Collection coll = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        coll.add(<span class="keyword">new</span> String(<span class="string">"Tom"</span>));</span><br><span class="line">        coll.add(<span class="keyword">new</span> Person(<span class="string">"jerry"</span>,<span class="number">20</span>));</span><br><span class="line">		System.out.println(coll.contains(<span class="keyword">new</span> String(<span class="string">"Tom"</span>)));<span class="comment">//equals比内容</span></span><br><span class="line">		System.out.println(coll.contains(<span class="keyword">new</span> Person(<span class="string">"jerry"</span>,<span class="number">20</span>)));<span class="comment">//equals比地址</span></span><br><span class="line">输出：</span><br><span class="line">    <span class="keyword">true</span></span><br><span class="line">    <span class="keyword">false</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="containsAll"><a href="#containsAll" class="headerlink" title="containsAll()"></a>containsAll()</h5><ul>
<li>判断括号内集合中的元素是否<strong>都包含</strong>在当前集合内</li>
</ul>
<h5 id="remove"><a href="#remove" class="headerlink" title="remove()"></a>remove()</h5><ul>
<li>也会调用<strong>equals()</strong>方法</li>
</ul>
<h5 id="removeAll"><a href="#removeAll" class="headerlink" title="removeAll()"></a>removeAll()</h5><ul>
<li><strong>差集</strong></li>
<li>从当前集合移除括号内集合所有的元素</li>
</ul>
<h5 id="retainAll"><a href="#retainAll" class="headerlink" title="retainAll()"></a>retainAll()</h5><ul>
<li>当前集合和括号内集合的<strong>交集</strong></li>
</ul>
<h5 id="equals"><a href="#equals" class="headerlink" title="equals()"></a>equals()</h5><ul>
<li>比较括号内元素是否相等</li>
</ul>
<h5 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode()"></a>hashCode()</h5><ul>
<li>根据集合内元素，返回哈希值</li>
</ul>
<h5 id="toArray"><a href="#toArray" class="headerlink" title="toArray()"></a>toArray()</h5><ul>
<li>集合转换为数组</li>
<li>数组转变为集合：<ul>
<li>ArrayList list = Arrays.asList({1,2,3})</li>
<li><strong>ArrayList list = Arrays.asList(new int[]{1,2,3})</strong>会出错，被认为是一个数组元素</li>
<li><strong>ArrayList list = Arrays.asList(new Integer[]{1,2,3})</strong>正确，包装类被认为是两个元素</li>
</ul>
</li>
</ul>
<h5 id="iterator"><a href="#iterator" class="headerlink" title="iterator()"></a>iterator()</h5><ul>
<li><p>集合元素的遍历，实现了Iterator接口</p>
</li>
<li><p>hasNext()和next()方法的使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Iterator iterator = coll1.iterator();<span class="comment">//iterator是一个对象实现了Iterator接口，不是容器</span></span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>迭代器执行原理</p>
<ul>
<li>hasNext()只是判断下一个地址有没有数据</li>
<li>next()是指针下移一个位置，指针一开始再第一个的钱一个位置</li>
</ul>
</li>
<li><p>错误写法</p>
<ul>
<li><pre><code class="java"><span class="keyword">while</span>((iterator.next() != <span class="keyword">null</span>)){<span class="comment">//每次调用next()都会下移一位，会丢数据</span>
    <span class="comment">//有可能while循环里的元素是最后一个，不是空，但是执行完之后下移一个，指针变为空，会出空指针现异常</span>
            System.out.println(iterator.next());
        }
&lt;!--￼<span class="number">2</span>--&gt;</code></pre>
</li>
</ul>
</li>
<li><p>每次调用iterator()方法，会生成一个迭代器</p>
</li>
<li><p>remove()方法</p>
<ul>
<li><pre><code class="java"><span class="comment">//删除集合中的"Tom"元素</span>
<span class="keyword">while</span>(iterator.hasNext()){
            Object obj = iterator.next();
            <span class="keyword">if</span>(obj.equals(<span class="string">"Tom"</span>)){
                iterator.remove();
            }
        }
&lt;!--￼<span class="number">3</span>--&gt;</code></pre>
</li>
</ul>
</li>
<li><p><strong>内部调用的还是Iterator</strong></p>
</li>
</ul>
<h4 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h4><h5 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h5><ul>
<li><strong>有序，可重复</strong></li>
<li>每个元素都有对应的顺序索引</li>
<li>ArrayList,LinkedList和Vector区别和联系<ul>
<li>相同点：<ul>
<li>都实现了List接口，存储有序，可重复的</li>
</ul>
</li>
<li>不同点<ul>
<li>Vector是1.2出现的，古老版本。<strong>效率低，线程安全</strong>。底层使用<strong>Object[]</strong>实现。利用了synchronized关键字。</li>
<li>ArrayList：<strong>效率高，线程不安全</strong>。底层使用<strong>Object[]</strong>实现。删除操作时顺序执行。例如，在10000个元素中删掉第三个元素，从第4个到第10000个元素都得变化。</li>
<li>LinkedList：底层是使用<strong>双向链表</strong>。对于频繁插入和<strong>删除</strong>操作，效率比ArrayList高</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h5><h6 id="源码分析（jdk7）"><a href="#源码分析（jdk7）" class="headerlink" title="源码分析（jdk7）"></a>源码分析（jdk7）</h6><ul>
<li><p>底层：Object[] element</p>
</li>
<li><p>构造函数：ArrayList list = new ArrayList（）。<strong>默认</strong>初始有<strong>10</strong>个元素</p>
<ul>
<li><pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>{
        <span class="keyword">super</span>();
        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)
            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+
                                               initialCapacity);
        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];
    }
<span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>{
        <span class="keyword">this</span>(<span class="number">10</span>);
    }
&lt;!--￼<span class="number">4</span>--&gt;</code></pre>
</li>
</ul>
</li>
<li><p><strong>扩容源码</strong></p>
<ul>
<li><pre><code class="java"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>{
        <span class="comment">// overflow-conscious code</span>
        <span class="keyword">int</span> oldCapacity = elementData.length;
        <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);<span class="comment">//变更为1.5倍</span>

    <span class="comment">//如果不够，变为传过来的参数minCapacity</span>
        <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)
            newCapacity = minCapacity;

    <span class="comment">//如果还不够，变为一个提前设置的最大值</span>
    <span class="comment">//再不够，到整型最大值，不够就error</span>
        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)
            newCapacity = hugeCapacity(minCapacity);
        <span class="comment">// minCapacity is usually close to size, so this is a win:建立一个新的数组，把原来的值copy进去，再赋值给elementData</span>
        elementData = Arrays.copyOf(elementData, newCapacity);
    }
&lt;!--￼<span class="number">5</span>--&gt;</code></pre>
</li>
</ul>
</li>
<li><p>此一次调用<strong>add()</strong>方法时，才创建了长度为10的数组，并将数组添加到集合中、</p>
<ul>
<li><pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>{
        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span>
        elementData[size++] = e;
        <span class="keyword">return</span> <span class="keyword">true</span>;
    }
<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>{
        ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));
    }

<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateCapacity</span><span class="params">(Object[] elementData, <span class="keyword">int</span> minCapacity)</span> </span>{
        <span class="comment">//DEFAULT_CAPACITY为10，是默认值</span>
        <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
            <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);
        }
        <span class="keyword">return</span> minCapacity;
        }
<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>{
        modCount++;

        <span class="comment">// overflow-conscious code</span>
        <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)
            grow(minCapacity);
    }
&lt;!--￼<span class="number">6</span>--&gt;</code></pre>
</li>
</ul>
</li>
<li><p>add()</p>
<ul>
<li><pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>{
        linkLast(e);
        <span class="keyword">return</span> <span class="keyword">true</span>;
    }

<span class="comment">/**</span>
<span class="comment">     * Links e as last element.</span>
<span class="comment">     */</span>
<span class="comment">//链表的尾部加如节点</span>
<span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>{
        <span class="keyword">final</span> Node&lt;E&gt; l = last;
        <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);
        last = newNode;
        <span class="keyword">if</span> (l == <span class="keyword">null</span>)<span class="comment">//空的时候</span>
            first = newNode;
        <span class="keyword">else</span>
            l.next = newNode;
        size++;
        modCount++;
    }
&lt;!--￼<span class="number">7</span>--&gt;
</code></pre>
</li>
</ul>
</li>
</ul>
<h6 id="addAll-ArrayList"><a href="#addAll-ArrayList" class="headerlink" title="addAll(ArrayList)"></a>addAll(ArrayList)</h6><ul>
<li><pre><code class="java">list.addAll(list1)<span class="comment">//list1的元素全部添加到list中</span>
&lt;!--￼<span class="number">8</span>--&gt;
</code></pre>
</li>
</ul>
<h6 id="indexof-Object"><a href="#indexof-Object" class="headerlink" title="indexof(Object)"></a>indexof(Object)</h6><ul>
<li><pre><code class="java"><span class="keyword">int</span> index = list.indexOf(<span class="number">123</span>)<span class="comment">//判断123在list的第一次出现的位置上，没有的化返回-1</span>
&lt;!--￼<span class="number">9</span>--&gt;
</code></pre>
</li>
</ul>
<h6 id="remove-index"><a href="#remove-index" class="headerlink" title="remove(index)"></a>remove(index)</h6><ul>
<li><p>和Collection中的remove()不同，这个是删除索引位置，而前一个是删除指定内容元素</p>
</li>
<li><pre><code class="java">list.remove(<span class="number">4</span>)<span class="comment">//返回删除索引位置4上的元素</span>
list.add(<span class="number">2</span>)
list.remove(<span class="number">2</span>)<span class="comment">//会出现错误，没有调用Collection的remove，而停在了List的remove上</span>
&lt;!--￼<span class="number">10</span>--&gt;
</code></pre>
</li>
</ul>
<h6 id="sublist-indexl，indexr"><a href="#sublist-indexl，indexr" class="headerlink" title="sublist(indexl，indexr)"></a>sublist(indexl，indexr)</h6><ul>
<li><pre><code class="java"><span class="comment">//返回一个左闭右开的一子集和，不会对原来的集合造成影响</span>
list.sublist(<span class="number">2</span>，<span class="number">4</span>)
&lt;!--￼<span class="number">11</span>--&gt;

- ```java
  map.put(key1,value1)<span class="comment">//首先调用key1所在类的hashCode()计算key1哈希值，此哈希值经过某种计算之后，会得到在Entry数组中的存放位置</span>
      <span class="comment">//如果位置上为空，则(key1,value1)添加成功</span>
      <span class="comment">//如果不为空（意味着此位置存在一个或者多个元素（多个存放在链表上）），则需要比较key和其他数据的哈希值</span>
          <span class="comment">//如果key1的哈希值和其他的哈希值都不相同，则添加成功</span>
          <span class="comment">//如果存在哈希值相同，调用key1所在类的equals方法</span>
              <span class="comment">//如果返回false，此时添加成功</span>
              <span class="comment">//如果返回true，使用value1替换相同key的value值。（修改了key1值相同的value值）</span>
  &lt;!--￼<span class="number">12</span>--&gt;

- 底层是以一个数组Entry[]存储，每个数组的对象包含<span class="number">4</span>个属性。其中next将每个数组对象组织成了链表</code></pre>
</li>
<li><p>put(key,value) </p>
<ul>
<li><pre><code class="java"><span class="number">1</span>. <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>{
<span class="number">2</span>. <span class="comment">// HashMap 允许存放 null 键和 null 值。</span>
<span class="number">3</span>. <span class="comment">// 当 key 为 null 时，调用 putForNullKey 方法，将 value 放置在数组第一个位置。</span>
<span class="number">4</span>.         <span class="keyword">if</span> (key == <span class="keyword">null</span>)
<span class="number">5</span>.             <span class="keyword">return</span> putForNullKey(value);
<span class="number">6</span>. <span class="comment">// 根据 key 的 keyCode 重新计算 hash 值。</span>
<span class="number">7</span>.         <span class="keyword">int</span> hash = hash(key.hashCode());
<span class="number">8</span>. <span class="comment">// 搜索指定 hash 值在对应 table 中的索引。</span>
<span class="number">9</span>.         <span class="keyword">int</span> i = indexFor(hash, table.length);
<span class="number">10</span>. <span class="comment">// 如果 i 索引处的 Entry 不为 null，通过循环不断遍历 e 元素的下一个元素。</span>
<span class="number">11</span>.     <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) {
<span class="number">12</span>.         Object k;
<span class="number">13</span>.         <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) {
<span class="number">14</span>.             V oldValue = e.value;
<span class="number">15</span>.             e.value = value;
<span class="number">16</span>.             e.recordAccess(<span class="keyword">this</span>);
<span class="number">17</span>.             <span class="keyword">return</span> oldValue;
<span class="number">18</span>.         }
<span class="number">19</span>.        }
<span class="number">20</span>. <span class="comment">// 如果 i 索引处的 Entry 为 null，表明此处还没有 Entry。</span>
<span class="number">21</span>.     modCount++;
<span class="number">22</span>. <span class="comment">// 将 key、value 添加到 i 索引处。</span>
<span class="number">23</span>.     addEntry(hash, key, value, i);
<span class="number">24</span>.     <span class="keyword">return</span> <span class="keyword">null</span>;
<span class="number">25</span>. }
&lt;!--￼<span class="number">13</span>--&gt;

- resize(<span class="number">2</span> * table.length)

&lt;!--￼<span class="number">14</span>--&gt;

- transfer(newTable, rehash)

  &lt;!--￼<span class="number">15</span>--&gt;


</code></pre>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>*hash(int h)</p>
<ul>
<li><pre><code class="java"><span class="comment">//hash(int h)方法根据 key 的 hashCode 重新计算一次散列。此算法加入了高位计算，防</span>
<span class="comment">//止低位不变，高位变化时，造成的 hash 冲突</span>
<span class="number">1</span>. <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> h)</span> </span>{
<span class="number">2</span>.         h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);
<span class="number">3</span>.         <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);
<span class="number">4</span>. }
&lt;!--￼<span class="number">16</span>--&gt;</code></pre>
</li>
</ul>
</li>
<li><p>get(Object key)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line"><span class="number">2</span>. 		<span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line"><span class="number">3</span>. 			<span class="keyword">return</span> getForNullKey();</span><br><span class="line"><span class="number">4</span>. 		<span class="keyword">int</span> hash = hash(key.hashCode());</span><br><span class="line"><span class="number">5</span>. 		<span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];e != <span class="keyword">null</span>;e = e.next)&#123;</span><br><span class="line"><span class="number">8</span>. 			Object k;</span><br><span class="line"><span class="number">9</span>. 			<span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k)))</span><br><span class="line"><span class="number">10</span>. 			<span class="keyword">return</span> e.value;</span><br><span class="line"><span class="number">11</span>. 		&#125;</span><br><span class="line"><span class="number">12</span>. 	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"><span class="number">13</span>. &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>getForNullKey()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在下标为1的数组元素开始遍历链表，找到key为NULL的value</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">getForNullKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[<span class="number">0</span>]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.key == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> e.value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>构造器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//默认数组长度16和负载因子0.75</span></span><br><span class="line">        <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)<span class="comment">//数组长度非法</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)<span class="comment">//数组长度超出最大值，强行以最大值构造</span></span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))<span class="comment">//负载因子非法</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                               loadFactor);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Find a power of 2 &gt;= initialCapacity</span></span><br><span class="line">        <span class="keyword">int</span> capacity = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (capacity &lt; initialCapacity)</span><br><span class="line">            capacity &lt;&lt;= <span class="number">1</span>;<span class="comment">//从2^0开始，保证数组的长度是2^n，有利于查找时的效率优化h&amp;（length-1）</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="comment">//最大不扩容数组长度 capacity * loadFactor</span></span><br><span class="line">        threshold = (<span class="keyword">int</span>)Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">        table = <span class="keyword">new</span> Entry[capacity];</span><br><span class="line">        useAltHashing = sun.misc.VM.isBooted() &amp;&amp;</span><br><span class="line">                (capacity &gt;= Holder.ALTERNATIVE_HASHING_THRESHOLD);</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<ul>
<li><p>remove</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//简单的链表删除节点操作</span></span><br><span class="line"><span class="comment">//根据hashcode算hash，再根据hash算index然后判断，删除</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">removeEntryForKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key);</span><br><span class="line">        <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">        Entry&lt;K,V&gt; prev = table[i];</span><br><span class="line">        Entry&lt;K,V&gt; e = prev;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">            Object k;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                modCount++;</span><br><span class="line">                size--;</span><br><span class="line">                <span class="keyword">if</span> (prev == e)</span><br><span class="line">                    table[i] = next;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    prev.next = next;</span><br><span class="line">                e.recordRemoval(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">return</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">            prev = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>Fail-Fast机制</p>
<ul>
<li><p>由于HashMap是线程不安全的，所以当有其他的线程修改了Map，modCount这个值就会发生改变，迭代器初始化过程中会将这个值赋值为expectedModCount。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. HashIterator() &#123;</span><br><span class="line"><span class="number">2</span>. 		expectedModCount = modCount;</span><br><span class="line"><span class="number">3</span>. 		<span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123; <span class="comment">// advance to first entry</span></span><br><span class="line"><span class="number">4</span>. 			Entry[] t = table;</span><br><span class="line"><span class="number">5</span>. 			<span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>)</span><br><span class="line"><span class="number">6</span>. 				;</span><br><span class="line"><span class="number">7</span>. 		&#125;</span><br><span class="line"><span class="number">8</span>. &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在迭代过程中，会判断expectedModCount 和 modCount值是否相等，不相等就会抛出ConcurrentModificationException异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. <span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">nextEntry</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="number">2</span>.	 	<span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line"><span class="number">3</span>.	 		<span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br></pre></td></tr></table></figure>
</li>
<li><p>编写依赖于此异常的程序的做法是错误的，正确做法是：迭代器的快速失败行为应该仅用于检测程序错误</p>
</li>
</ul>
</li>
</ul>
<h6 id="jdk8"><a href="#jdk8" class="headerlink" title="jdk8"></a>jdk8</h6><ul>
<li><p>一开始没有创建数组，put时创建</p>
</li>
<li><p>HashMap的属性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认的初始容量为 16</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br><span class="line"><span class="comment">//最大的容量上限为 2^30</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="comment">//默认的负载因子为 0.75</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"><span class="comment">//变成树型结构的临界值为 8</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"><span class="comment">//恢复链式结构的临界值为 6</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"><span class="comment">//哈希表</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"><span class="comment">//哈希表中键值对的个数</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"><span class="comment">//哈希表被修改的次数</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"><span class="comment">//它是通过 capacity*load factor 计算出来的，当 size 到达这个值时，</span></span><br><span class="line">就会进行扩容操作</span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"><span class="comment">//负载因子</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"><span class="comment">//当哈希表的大小超过这个阈值，才会把链式结构转化成树型结构，否则仅采取扩容来尝试减少冲突</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>HashMap中的节点不再是Entry，而实Node,具体作用和Entry相同</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"> <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line"> <span class="keyword">final</span> K key;</span><br><span class="line"> V value;</span><br><span class="line"> Node&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>get()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//get 方法主要调用的是 getNode 方法，所以重点要看 getNode 方法的实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">	Node&lt;K,V&gt; e;</span><br><span class="line">	<span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span>: e.value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">	Node&lt;K,V&gt;[] tab; </span><br><span class="line">   Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">	<span class="comment">//如果哈希表不为空 &amp;&amp; key 对应的桶上不为空</span></span><br><span class="line">	<span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;(first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="comment">//是否直接命中</span></span><br><span class="line">		<span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">		((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">			<span class="keyword">return</span> first;</span><br><span class="line">		<span class="comment">//判断是否有后续节点</span></span><br><span class="line">		<span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">//如果当前的桶是采用红黑树处理冲突，则调用红黑树的 get 方法去获取节点</span></span><br><span class="line">			<span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">				<span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">			<span class="comment">//不是红黑树的话，那就是传统的链式结构了，通过循环的方法判断链中是否存在该 key</span></span><br><span class="line">		 <span class="keyword">do</span> &#123;</span><br><span class="line">			 <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; </span><br><span class="line">			key.equals(k))))</span><br><span class="line">					<span class="keyword">return</span> e;</span><br><span class="line">					 &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>put()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">//如果哈希表为空，新创建一个新哈希表</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">//如果哈希表的对应位置为空，则直接插入键值对</span></span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            <span class="comment">//如果哈希值和key值都相等，那么出现重复的键值对，到最后换value即可</span></span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                e = p;</span><br><span class="line">            <span class="comment">//如果链表的结构已经编程了红黑树，那么进行红黑树插值处理</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="comment">//如果不是红黑树结构，那么就是链表结构，进行遍历查找相同key值节点</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                    <span class="comment">//如果没找到相等key值得节点，那么就在链表的末尾直接插入节点</span></span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                        <span class="comment">//如果一个链表的长度大于等于8，就会判断数组长度是否大于64</span></span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//如果找到了key值相同的节点，那么将p的信息修改为相同节点的信息</span></span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//修改key值相同的节点的value值</span></span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>resize()</strong></p>
<ul>
<li><strong>和jdk7有所不同，表现在从旧表网新表插入数据时的方法</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">        <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;<span class="comment">//旧表的长度</span></span><br><span class="line">        <span class="keyword">int</span> oldThr = threshold;<span class="comment">//旧表的阈值</span></span><br><span class="line">        <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//如果旧表的长度大于0</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//如果旧表的长度大于最大值，赋值最大值，不可再扩容</span></span><br><span class="line">            <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">                threshold = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">return</span> oldTab;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果新表的长度（2倍）合法的话，阈值也翻一倍</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">                newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//带有初始阈值参数的构造器，哈希表长度变为传进来的参数</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">            newCap = oldThr;</span><br><span class="line">    <span class="comment">//如股票还没有创建表，则初始化表的长度和阈值</span></span><br><span class="line">        <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">            newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">            newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//如果新的阈值等于0，则根据哈希表的长度计算阈值</span></span><br><span class="line">        <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                      (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        threshold = newThr;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">    <span class="comment">//根据新表的长度创建新表</span></span><br><span class="line">            Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">        table = newTab;</span><br><span class="line">        <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">                Node&lt;K,V&gt; e;</span><br><span class="line">                <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="comment">//如果位置为空，直接插入</span></span><br><span class="line">                    <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                        newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                    <span class="comment">//有树结构，树插入</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                    <span class="comment">//链表插入</span></span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    扩容每次乘以2的原因：增加了1位数据，n-1 相比 之前的 n - 1必定是多了一位1</span></span><br><span class="line"><span class="comment">                    这一位和原来的hash值进行 &amp; 操作时，只有两种情况：</span></span><br><span class="line"><span class="comment">                    等于0，计算结果和原来相同，位置不变</span></span><br><span class="line"><span class="comment">                    等于1，计算结果比原来相比，多了一个固定的值：2^( n-1 )</span></span><br><span class="line"><span class="comment">                    这样一来  原来位置的数据必定分成两拨存储：一部分在x，另一部分在x + 2^( n-1 )存，这样必定减少了冲突的概率</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                    <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                        Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; next;</span><br><span class="line">                        <span class="keyword">do</span> &#123;</span><br><span class="line">                            next = e.next;</span><br><span class="line">                            <span class="comment">////不需要移动的数据</span></span><br><span class="line">                            <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;  </span><br><span class="line">                                <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                    loHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = e;</span><br><span class="line">                                loTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">//需要移动的数据</span></span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                  hiHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = e;</span><br><span class="line">                                hiTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; </span><br><span class="line">                        <span class="comment">//分批插入新的链表中</span></span><br><span class="line">                        <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j] = loHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j + oldCap] = hiHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newTab;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>红黑树插值操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">putTreeVal</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">int</span> h, K k, V v)</span> </span>&#123;</span><br><span class="line">            Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">boolean</span> searched = <span class="keyword">false</span>;</span><br><span class="line">            TreeNode&lt;K,V&gt; root = (parent != <span class="keyword">null</span>) ? root() : <span class="keyword">this</span>;</span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> dir, ph; K pk;</span><br><span class="line">                <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                    dir = -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                    dir = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="keyword">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">                    <span class="keyword">return</span> p;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                          (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                         (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!searched) &#123;</span><br><span class="line">                        TreeNode&lt;K,V&gt; q, ch;</span><br><span class="line">                        searched = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="keyword">if</span> (((ch = p.left) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                             (q = ch.find(h, k, kc)) != <span class="keyword">null</span>) ||</span><br><span class="line">                            ((ch = p.right) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                             (q = ch.find(h, k, kc)) != <span class="keyword">null</span>))</span><br><span class="line">                            <span class="keyword">return</span> q;</span><br><span class="line">                    &#125;</span><br><span class="line">                    dir = tieBreakOrder(k, pk);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">                <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    Node&lt;K,V&gt; xpn = xp.next;</span><br><span class="line">                    TreeNode&lt;K,V&gt; x = map.newTreeNode(h, k, v, xpn);</span><br><span class="line">                    <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                        xp.left = x;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        xp.right = x;</span><br><span class="line">                    xp.next = x;</span><br><span class="line">                    x.parent = x.prev = xp;</span><br><span class="line">                    <span class="keyword">if</span> (xpn != <span class="keyword">null</span>)</span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)xpn).prev = x;</span><br><span class="line">                    moveRootToFront(tab, balanceInsertion(root, x));</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>红黑树获取节点操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">getTreeNode</span><span class="params">(<span class="keyword">int</span> h, Object k)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> ((parent != <span class="keyword">null</span>) ? root() : <span class="keyword">this</span>).find(h, k, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line"> <span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">find</span><span class="params">(<span class="keyword">int</span> h, Object k, Class&lt;?&gt; kc)</span> </span>&#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; p = <span class="keyword">this</span>;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> ph, dir; K pk;</span><br><span class="line">                TreeNode&lt;K,V&gt; pl = p.left, pr = p.right, q;</span><br><span class="line">                <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                    p = pl;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                    p = pr;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="keyword">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">                    <span class="keyword">return</span> p;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (pl == <span class="keyword">null</span>)</span><br><span class="line">                    p = pr;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (pr == <span class="keyword">null</span>)</span><br><span class="line">                    p = pl;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((kc != <span class="keyword">null</span> ||</span><br><span class="line">                          (kc = comparableClassFor(k)) != <span class="keyword">null</span>) &amp;&amp;</span><br><span class="line">                         (dir = compareComparables(kc, k, pk)) != <span class="number">0</span>)</span><br><span class="line">                    p = (dir &lt; <span class="number">0</span>) ? pl : pr;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((q = pr.find(h, k, kc)) != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> q;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    p = pl;</span><br><span class="line">            &#125; <span class="keyword">while</span> (p != <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>remove()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ?</span><br><span class="line">            <span class="keyword">null</span> : e.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, index;</span><br><span class="line">    <span class="comment">//如果哈希表不为空，且哈希表的长度大于0，并且计算出来的位置信息不是空，继续</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node&lt;K,V&gt; node = <span class="keyword">null</span>, e; K k; V v;</span><br><span class="line">            <span class="comment">//如果找到了hash值和key值都相等的节点，记录节点信息</span></span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                node = p;</span><br><span class="line">            <span class="comment">//如果在哈希表的元素上已经形成了链表，那么进行遍历操作</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//如果已经形成了红黑树，进行红黑树查询节点操作</span></span><br><span class="line">                <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">                <span class="comment">//如果没有形成红黑树，那么进行链表查询</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//</span></span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                            ((k = e.key) == key ||</span><br><span class="line">                             (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                            node = e;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        p = e;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                                 (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">                <span class="comment">//查找得到的Node是红黑树节点，那么进行树的删除节点操作</span></span><br><span class="line">                <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</span><br><span class="line">                <span class="comment">//如果节点是哈希表中存放的链表头，那么直接指向下一个节点即可</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                    tab[index] = node.next;</span><br><span class="line">                <span class="comment">//如果是链表里面的节点，那么进行链表删除节点操作</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    p.next = node.next;</span><br><span class="line">                ++modCount;</span><br><span class="line">                --size;</span><br><span class="line">                afterNodeRemoval(node);</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>红黑树删除节点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">removeTreeNode</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> n;</span><br><span class="line">            <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">int</span> index = (n - <span class="number">1</span>) &amp; hash;</span><br><span class="line">            TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index], root = first, rl;</span><br><span class="line">            TreeNode&lt;K,V&gt; succ = (TreeNode&lt;K,V&gt;)next, pred = prev;</span><br><span class="line">            <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">                tab[index] = first = succ;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                pred.next = succ;</span><br><span class="line">            <span class="keyword">if</span> (succ != <span class="keyword">null</span>)</span><br><span class="line">                succ.prev = pred;</span><br><span class="line">            <span class="keyword">if</span> (first == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span> (root.parent != <span class="keyword">null</span>)</span><br><span class="line">                root = root.root();</span><br><span class="line">            <span class="keyword">if</span> (root == <span class="keyword">null</span> || root.right == <span class="keyword">null</span> ||</span><br><span class="line">                (rl = root.left) == <span class="keyword">null</span> || rl.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">                tab[index] = first.untreeify(map);  <span class="comment">// too small</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            TreeNode&lt;K,V&gt; p = <span class="keyword">this</span>, pl = left, pr = right, replacement;</span><br><span class="line">            <span class="keyword">if</span> (pl != <span class="keyword">null</span> &amp;&amp; pr != <span class="keyword">null</span>) &#123;</span><br><span class="line">                TreeNode&lt;K,V&gt; s = pr, sl;</span><br><span class="line">                <span class="keyword">while</span> ((sl = s.left) != <span class="keyword">null</span>) <span class="comment">// find successor</span></span><br><span class="line">                    s = sl;</span><br><span class="line">                <span class="keyword">boolean</span> c = s.red; s.red = p.red; p.red = c; <span class="comment">// swap colors</span></span><br><span class="line">                TreeNode&lt;K,V&gt; sr = s.right;</span><br><span class="line">                TreeNode&lt;K,V&gt; pp = p.parent;</span><br><span class="line">                <span class="keyword">if</span> (s == pr) &#123; <span class="comment">// p was s's direct parent</span></span><br><span class="line">                    p.parent = s;</span><br><span class="line">                    s.right = p;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    TreeNode&lt;K,V&gt; sp = s.parent;</span><br><span class="line">                    <span class="keyword">if</span> ((p.parent = sp) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (s == sp.left)</span><br><span class="line">                            sp.left = p;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            sp.right = p;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> ((s.right = pr) != <span class="keyword">null</span>)</span><br><span class="line">                        pr.parent = s;</span><br><span class="line">                &#125;</span><br><span class="line">                p.left = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> ((p.right = sr) != <span class="keyword">null</span>)</span><br><span class="line">                    sr.parent = p;</span><br><span class="line">                <span class="keyword">if</span> ((s.left = pl) != <span class="keyword">null</span>)</span><br><span class="line">                    pl.parent = s;</span><br><span class="line">                <span class="keyword">if</span> ((s.parent = pp) == <span class="keyword">null</span>)</span><br><span class="line">                    root = s;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.left)</span><br><span class="line">                    pp.left = s;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    pp.right = s;</span><br><span class="line">                <span class="keyword">if</span> (sr != <span class="keyword">null</span>)</span><br><span class="line">                    replacement = sr;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    replacement = p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (pl != <span class="keyword">null</span>)</span><br><span class="line">                replacement = pl;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (pr != <span class="keyword">null</span>)</span><br><span class="line">                replacement = pr;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                replacement = p;</span><br><span class="line">            <span class="keyword">if</span> (replacement != p) &#123;</span><br><span class="line">                TreeNode&lt;K,V&gt; pp = replacement.parent = p.parent;</span><br><span class="line">                <span class="keyword">if</span> (pp == <span class="keyword">null</span>)</span><br><span class="line">                    root = replacement;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.left)</span><br><span class="line">                    pp.left = replacement;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    pp.right = replacement;</span><br><span class="line">                p.left = p.right = p.parent = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            TreeNode&lt;K,V&gt; r = p.red ? root : balanceDeletion(root, replacement);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (replacement == p) &#123;  <span class="comment">// detach</span></span><br><span class="line">                TreeNode&lt;K,V&gt; pp = p.parent;</span><br><span class="line">                p.parent = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (pp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (p == pp.left)</span><br><span class="line">                        pp.left = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.right)</span><br><span class="line">                        pp.right = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (movable)</span><br><span class="line">                moveRootToFront(tab, r);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>hash()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h;</span><br><span class="line">    <span class="comment">//为什么不直接用hashCode的值参加计算，而实使用 (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</span></span><br><span class="line">    <span class="comment">//为了避免hashCode在N很小的情况下，如果hashCode的高16位变化很大，而低16位很少变化；即使变化了，也只有低16位和n-1进行与操作，很容易造成冲突</span></span><br><span class="line">        <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//哈希表的长度必定会被设置成为一个2的整数次幂</span></span><br><span class="line"><span class="comment">//如果为13会是16，27会成为32</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line"> n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line"> n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line"> n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line"> n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line"> n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line"> <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_C</span><br><span class="line">APACITY : n + <span class="number">1</span>; &#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><pre><code class="java"> <span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">putTreeVal</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</span></span>
<span class="function"><span class="params">                                       <span class="keyword">int</span> h, K k, V v)</span> </span>{
            Class&lt;?&gt; kc = <span class="keyword">null</span>;
            <span class="keyword">boolean</span> searched = <span class="keyword">false</span>;
            TreeNode&lt;K,V&gt; root = (parent != <span class="keyword">null</span>) ? root() : <span class="keyword">this</span>;
            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) {
                <span class="keyword">int</span> dir, ph; K pk;
                <span class="keyword">if</span> ((ph = p.hash) &gt; h)
                    dir = -<span class="number">1</span>;
                <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)
                    dir = <span class="number">1</span>;
                <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="keyword">null</span> &amp;&amp; k.equals(pk)))
                    <span class="keyword">return</span> p;
                <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;
                          (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||
                         (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>) {
                    <span class="keyword">if</span> (!searched) {
                        TreeNode&lt;K,V&gt; q, ch;
                        searched = <span class="keyword">true</span>;
                        <span class="keyword">if</span> (((ch = p.left) != <span class="keyword">null</span> &amp;&amp;
                             (q = ch.find(h, k, kc)) != <span class="keyword">null</span>) ||
                            ((ch = p.right) != <span class="keyword">null</span> &amp;&amp;
                             (q = ch.find(h, k, kc)) != <span class="keyword">null</span>))
                            <span class="keyword">return</span> q;
                    }
                    dir = tieBreakOrder(k, pk);
                }

                TreeNode&lt;K,V&gt; xp = p;
                <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) {
                    Node&lt;K,V&gt; xpn = xp.next;
                    TreeNode&lt;K,V&gt; x = map.newTreeNode(h, k, v, xpn);
                    <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)
                        xp.left = x;
                    <span class="keyword">else</span>
                        xp.right = x;
                    xp.next = x;
                    x.parent = x.prev = xp;
                    <span class="keyword">if</span> (xpn != <span class="keyword">null</span>)
                        ((TreeNode&lt;K,V&gt;)xpn).prev = x;
                    moveRootToFront(tab, balanceInsertion(root, x));
                    <span class="keyword">return</span> <span class="keyword">null</span>;
                }
            }
        }
&lt;!--￼<span class="number">33</span>--&gt;</code></pre>
</li>
<li><p>有三个HashMap引用的方法</p>
<ul>
<li><pre><code class="java"><span class="comment">//将节点放到链表尾部</span>
<span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>{ <span class="comment">// move node to last</span>
        LinkedHashMap.Entry&lt;K,V&gt; last;
        <span class="keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) {
            LinkedHashMap.Entry&lt;K,V&gt; p =
                (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;
            p.after = <span class="keyword">null</span>;
            <span class="keyword">if</span> (b == <span class="keyword">null</span>)
                head = a;
            <span class="keyword">else</span>
                b.after = a;
            <span class="keyword">if</span> (a != <span class="keyword">null</span>)
                a.before = b;
            <span class="keyword">else</span>
                last = b;
            <span class="keyword">if</span> (last == <span class="keyword">null</span>)
                head = p;
            <span class="keyword">else</span> {
                p.before = last;
                last.after = p;
            }
            tail = p;
            ++modCount;
        }
    }
&lt;!--￼<span class="number">34</span>--&gt;</code></pre>
</li>
<li><pre><code class="java"><span class="comment">//删除头节点，在哈希表插入节点时使用</span>
<span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>{ <span class="comment">// possibly remove eldest</span>
        LinkedHashMap.Entry&lt;K,V&gt; first;
        <span class="keyword">if</span> (evict &amp;&amp; (first = head) != <span class="keyword">null</span> &amp;&amp; removeEldestEntry(first)) {
            K key = first.key;
            removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);
        }
    }
&lt;!--￼<span class="number">35</span>--&gt;</code></pre>
</li>
</ul>
</li>
<li><p>values(),遍历顺序和key一样</p>
<ul>
<li><pre><code class="java">Collection values = map.values()
&lt;!--￼<span class="number">36</span>--&gt;
</code></pre>
</li>
</ul>
</li>
</ul>
<h4 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h4><ul>
<li><p>TreeMap是按照key进行排序的，key必须是由同一个类创建的对象</p>
<ul>
<li><p>自然排序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//key所在的对象实现Compaaeble，实现ToComparable方法</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>定制排序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TreeMap map = new TreeMap(new Comparator()&#123;</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(object o1,object o2)</span></span>&#123;</span><br><span class="line">....</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h4 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h4><h5 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h5><ul>
<li><p>处理配置文件，key和value都是String类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Properties pros = <span class="keyword">new</span> Properties;</span><br><span class="line">String name = pros.getProperty(<span class="string">"name"</span>);</span><br></pre></td></tr></table></figure>





</li>
</ul>
<h4 id="Collections工具类"><a href="#Collections工具类" class="headerlink" title="Collections工具类"></a>Collections工具类</h4><h5 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h5><ul>
<li><p>可以操作Collection和Map的工具类</p>
</li>
<li><p>Collections和Collection的区别</p>
</li>
</ul>
<h5 id="常用方法（都是static方法）"><a href="#常用方法（都是static方法）" class="headerlink" title="常用方法（都是static方法）"></a>常用方法（都是static方法）</h5><h6 id="reverse-list"><a href="#reverse-list" class="headerlink" title="reverse(list)"></a>reverse(list)</h6><ul>
<li><p>反转List中元素的顺序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collections.reverse(list)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h6 id="shuffle-list"><a href="#shuffle-list" class="headerlink" title="shuffle(list)"></a>shuffle(list)</h6><ul>
<li><p>list随机排列，每次都不一样</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collections.shuffle(list)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h6 id="sort-list"><a href="#sort-list" class="headerlink" title="sort(list)"></a>sort(list)</h6><ul>
<li>自然排序</li>
</ul>
<h6 id="sort-list-Comparator"><a href="#sort-list-Comparator" class="headerlink" title="sort(list,Comparator)"></a>sort(list,Comparator)</h6><ul>
<li>定制排序</li>
</ul>
<h6 id="swap-list-i-j"><a href="#swap-list-i-j" class="headerlink" title="swap(list,i,j)"></a>swap(list,i,j)</h6><ul>
<li>交换list中i和j位置的数据</li>
</ul>
<h6 id="max-Collection"><a href="#max-Collection" class="headerlink" title="max(Collection)"></a>max(Collection)</h6><ul>
<li>自然排序最大/小值</li>
</ul>
<h6 id="max-Collection-Comparator"><a href="#max-Collection-Comparator" class="headerlink" title="max(Collection,Comparator)"></a>max(Collection,Comparator)</h6><ul>
<li>定制排序最大/小值</li>
</ul>
<h6 id="frequency-Collection-Object"><a href="#frequency-Collection-Object" class="headerlink" title="frequency(Collection,Object)"></a>frequency(Collection,Object)</h6><ul>
<li>返回集合指定元素的个数</li>
</ul>
<h6 id="copy-list1-list2"><a href="#copy-list1-list2" class="headerlink" title="*copy(list1,list2)"></a>*copy(list1,list2)</h6><ul>
<li><p>错误做法1</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ArrayList list2 = <span class="keyword">new</span> ArrayList();</span><br><span class="line">Collections.copy(list2,list1);</span><br><span class="line"><span class="comment">//抛出异常，list2的长度是0，不合适</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>错误做法2</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ArrayList list2 = <span class="keyword">new</span> ArrayList(list1.size());</span><br><span class="line">Collections.copy(list2,list1);</span><br><span class="line"><span class="comment">//只是造了一个list1.size()的数组（没有存元素），list1.size()表示的是存由元素的数组元素的个数。</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>正确做法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List dest = Arrays.asList(<span class="keyword">new</span> Object[list.size()])</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>list2中的元素复制到list1中</p>
<ul>
<li>多了之后只覆盖前面的list2的个数</li>
</ul>
</li>
</ul>
<h6 id="replaceAll-list-oldVal-newVal"><a href="#replaceAll-list-oldVal-newVal" class="headerlink" title="replaceAll(list,oldVal,newVal)"></a>replaceAll(list,oldVal,newVal)</h6><ul>
<li>newVal替换list中所有的oldVal值</li>
</ul>
<h6 id="线程安全集合"><a href="#线程安全集合" class="headerlink" title="线程安全集合"></a>线程安全集合</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List list1 = Collections.synchronizedList(list);</span><br><span class="line"><span class="comment">//list1就会变成线程安全的</span></span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/111zx/111zx.github.io/2020/03/31/%E9%9B%86%E5%90%88/" data-id="ckbbzdvt0000jt8ub5j9406kz" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/05/12/leetcode/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          leetcode
        
      </div>
    </a>
  
  
    <a href="/2020/03/27/java%E9%9D%A2%E8%AF%95%E7%82%B9/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">java面试点</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/07/06/%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%E7%B3%BB%E7%BB%9F/">文件传输系统</a>
          </li>
        
          <li>
            <a href="/2020/07/05/1.%20%E7%82%B9%E5%87%BB%E6%96%87%E4%BB%B6%E6%A0%91%E6%98%BE%E7%A4%BA%E6%96%87%E4%BB%B6%E5%88%97%E8%A1%A8/">1. 点击文件树显示文件列表</a>
          </li>
        
          <li>
            <a href="/2020/06/22/IO%E6%B5%81/">IO流</a>
          </li>
        
          <li>
            <a href="/2020/06/10/%E6%B3%9B%E5%9E%8B/">泛型</a>
          </li>
        
          <li>
            <a href="/2020/06/09/%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E8%AF%BE%E7%A8%8B%E6%8A%A5%E5%91%8A/">软件体系结构课程报告</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 zx<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>